COMMAND SETUP(
	NOISE "ABBREVIATIONS"
	     );
BEGIN
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM 0 Z";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM 1 LOCK";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM B BATCH";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM C CONTINUE";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM CL CLEAR";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM D DEVICE";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM F FAST";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM I INFORMATION";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM J JOB";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM L LINE";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM O OUTPUT";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM P POP";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM PO POP";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM PU PUSH";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM PL PLOT";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM Q QUEUE";
!    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM RET RETRIEVAL";
!    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM RETR RETRIEVE";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM S SERVICE";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM SE SET";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM SY SYSTAT";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM U USER";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM W WATCH";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM X XOFF";
    DOCOMMAND "DECLARE /NOCONFIRM SYNONYM XO XON";
END

COMMAND ABORT ;

BEGIN
    STRING CMDIN ;
    LET CMDIN = "OPR RESPOND (to message number) " ;
    PARSE NOISE "PRINT BY REPLY TO MESSAGE" ;
    PARSE NUMBER (HELP "decimal message number" , RADIX 10) ;
    LET CMDIN = CMDIN + $STRING ($VALUE , 10) ;
    PARSE EOL ;
    LET CMDIN = CMDIN + " ABORT" ;
    DOCOMMAND CMDIN ;
END

COMMAND B63 ;

BEGIN
    STRING CMDIN ;
    LET CMDIN = "OPR MODIFY BATCH-REQUEST " ;
    PARSE NOISE "BATCH-REQUEST" ;
    PARSE NUMBER (HELP "decimal request number" , RADIX 10) ;
    LET CMDIN = CMDIN + $STRING ($VALUE , 10) ;
    PARSE EOL ;
    LET CMDIN = CMDIN + " PRIORITY (to be) 63 " ;
    DOCOMMAND CMDIN ;
END

COMMAND BATCH(
	NOISE "IN QUEUE"
	     );
BEGIN
    DOCOMMAND "INFORMATION BATCH-REQUEST" ;
END

COMMAND CDDEF ;

BEGIN
    STRING CMDOUT ;
    INTEGER LBEGIN ;
    PARSE EOL ;
    DOCOMMAND "DEFINE CD: " + $ConnectedDirectory ;
    DOCOMMAND "INFORMATION LOGICAL CD:" TO CMDOUT ;
    LBEGIN = $SEARCH(CMDOUT,"CD:") ;
    DISPLAY NORETURN CMDOUT[LBEGIN:$SEARCH(CMDOUT,$CR,LBEGIN)-LBEGIN] ;
END

COMMAND CENTER (
	NOISE "ACTIVITY"
	       );

BEGIN
    EXTERNAL STRING SYSTAT ;
    STRING SAVE_VAR ;
    SAVE_VAR = SYSTAT ;
    DOCOMMAND "LINE 1 2 3 4 5 44 46 47 66 67 70 72 75 76 77 100 ";
    SYSTAT = SAVE_VAR ;
END

COMMAND CLASS ;

BEGIN
    EXTERNAL STRING SYSTAT ;
    STRING CMDPRS ;
    PARSE NOISE "SYSTAT" ;
    PLOOP:
    PARSE (
    USERNAME:
    BEGIN
        LET CMDPRS = CMDPRS + " " + $Atom ;
        GOTO PLOOP ;
    END ;
    NUMBER (HELP "decimal job number" , RADIX 10):
    BEGIN
	LET CMDPRS = CMDPRS + " " + $STRING ($VALUE , 10) ;
        GOTO PLOOP ;
    END ;
    KEYWORD (WORDS (LINE:1)):
    BEGIN
        PARSE NUMBER (HELP "octal line number" , RADIX 8) ;
	LET CMDPRS = CMDPRS + " LINE " + $STRING ($VALUE , 8) ;
	GOTO PLOOP ;
    END ;
    EOL ;
          );
    IF $LENGTH (CMDPRS) = 0
        THEN DOCOMMAND "SYSTAT CLASS NO OPERATOR"
        ELSE
        BEGIN
            DOCOMMAND "SYSTAT SYSTEM HEADER CLASS" + CMDPRS ;
            LET SYSTAT = "CLASS (SYSTAT)" + CMDPRS ;
        END;
END

COMMAND CLEAR(
	NOISE "SCREEN AND RESET"
	     );
BEGIN
    DOCOMMAND "BLANK";
    DOCOMMAND "SYSTAT SYSTEM";
    DOCOMMAND "COOKIE";
    DOCOMMAND "DOIT";
    DOCOMMAND "RESET";
    DOCOMMAND "FORK";
END

COMMAND DEVICE(
	NOISE "IN QUEUE"
	      );
BEGIN
    DOCOMMAND "INFORMATION MOUNT-REQUEST";
END

COMMAND DISPLAY ;

BEGIN
    STRING FILDES ;
    PARSE NOISE "FILE" ;
    PARSE INPUTFILE ;
    PARSE EOL ;
    LET FILDES = $FILES ;
    DISPLAY BINARY "[?2l" ;
    DOCOMMAND "TERMINAL VT52" ;
    DOCOMMAND "VIEW.EXE " + FILDES ;
    DOCOMMAND "RESET" ;
    DISPLAY BINARY "<" ;
    DOCOMMAND "TERMINAL VT100" ;
END

COMMAND ECHO ;

BEGIN
    STRING TEXT ;
    PARSE NOISE "TEXT" ;
    PARSE TEXT ;
    PARSE EOL ;
    DISPLAY $ATOM ;
END

COMMAND FAST ;

BEGIN
    EXTERNAL STRING SYSTAT ;
    STRING CMDPRS ;
    PARSE NOISE "SYSTAT" ;
    PLOOP:
    PARSE (
    USERNAME:
    BEGIN
        LET CMDPRS = CMDPRS + " " + $Atom ;
        GOTO PLOOP ;
    END ;
    NUMBER (HELP "decimal job number" , RADIX 10):
    BEGIN
	LET CMDPRS = CMDPRS + " " + $STRING ($VALUE , 10) ;
        GOTO PLOOP ;
    END ;
    KEYWORD (WORDS (LINE:1)):
    BEGIN
        PARSE NUMBER (HELP "octal line number" , RADIX 8) ;
	LET CMDPRS = CMDPRS + " LINE " + $STRING ($VALUE , 8) ;
	GOTO PLOOP ;
    END ;
    EOL ;
          );
    IF $LENGTH (CMDPRS) = 0
        THEN DOCOMMAND "SYSTAT STATE TIME NO OPERATOR"
        ELSE
        BEGIN
            DOCOMMAND "SYSTAT SYSTEM HEADER STATE TIME" + CMDPRS ;
            LET SYSTAT = "FAST (SYSTAT)" + CMDPRS ;
        END;
END

COMMAND IGNORE ;

BEGIN
    STRING CMDIN ;
    LET CMDIN = "OPR RESPOND (to message number) " ;
    PARSE NOISE "LIMIT BY REPLY TO MESSAGE" ;
    PARSE NUMBER (HELP "decimal message number" , RADIX 10) ;
    LET CMDIN = CMDIN + $STRING ($VALUE , 10) ;
    PARSE EOL ;
    LET CMDIN = CMDIN + " IGNORE" ;
    DOCOMMAND CMDIN ;
END

COMMAND JOB ;

BEGIN
    EXTERNAL STRING SYSTAT ;
    STRING CMDOUT ;
    STRING CMDPRS ;
    PARSE NOISE "SYSTAT" ;
    PLOOP:
    PARSE (
    NUMBER (HELP "decimal job number" , RADIX 10):
    BEGIN
	LET CMDPRS = CMDPRS + " " + $STRING ($VALUE , 10) ;
        GOTO PLOOP ;
    END ;
    EOL ;
           ) ;
    IF $LENGTH (CMDPRS) = 0
        THEN DOCOMMAND "SYSTAT STATE DIRECTORY NO OPERATOR"
        ELSE
        BEGIN
            DOCOMMAND "SYSTAT HEADER STATE DIRECTORY" + CMDPRS  TO CMDOUT ;
            LET SYSTAT = "JOB (SYSTAT)" + CMDPRS ;
            IF $LENGTH (CMDOUT) = 0
                THEN BEGIN
		     DISPLAY "%Job(s) not in use" ;
		     RETURN ;
		     END
                ELSE DISPLAY NORETURN CMDOUT ;
        END ;
END

COMMAND KILLGAUSSIAN ;

BEGIN
    STRING CMDOUT ;
    DOCOMMAND "INFORMATION STRUCTURE SS:" TO CMDOUT ;
    IF CMDOUT[1:1] = "?" THEN EXIT ;
    DOCOMMAND "MOUNT STRUCTURE SS:" ;
    DOCOMMAND "CONNECT SS:<CTA>" ;
    DOCOMMAND "RUN US:<CTA.GAUSSIAN>GAUEXI.EXE" ;
    DOCOMMAND "CONNECT PS:<OPERATOR>" ;
    DOCOMMAND "DISMOUNT STRUCTURE SS:" ;
END

COMMAND LINE ;

BEGIN
    EXTERNAL STRING SYSTAT ;
    STRING CMDOUT ;
    STRING CMDPRS ;
    STRING LINNBR ;
    PARSE NOISE "SYSTAT" ;
    PLOOP:
    PARSE (
    NUMBER (HELP "octal line number" , RADIX 8):
    BEGIN
        LET CMDPRS = CMDPRS + " LINE " + $STRING ($VALUE , 8) ;
        LET LINNBR = LINNBR + " " + $STRING ($VALUE , 8) ;
        GOTO PLOOP ;
    END;
    EOL ;
          ) ;
    IF $LENGTH (CMDPRS) = 0
        THEN DOCOMMAND "SYSTAT STATE DIRECTORY NO OPERATOR"
        ELSE
        BEGIN
            DOCOMMAND "SYSTAT HEADER STATE DIRECTORY" + CMDPRS  TO CMDOUT ;
            LET SYSTAT = "LINE (SYSTAT)" + LINNBR ;
            IF $LENGTH (CMDOUT) = 0
                THEN BEGIN
		     DISPLAY "%Line(s) not active" ;
		     RETURN ;
		     END
                ELSE DISPLAY NORETURN CMDOUT ;
        END ;
END

COMMAND LOCK(
	NOISE "TERMINAL"
	    );
BEGIN
    DOCOMMAND "CLEAR";
    DOCOMMAND "XOFF";
    DISPLAY "
[Locked]
";
    DOCOMMAND "RUN LOCK.EXE";
    DOCOMMAND "RESET";
END

COMMAND OPR (
	NOISE "COMMAND" ;
	TEXT (HELP "OPR command" ,DEFAULT "SHOW QUEUES") : CMDTXT
	    );
BEGIN
    DISPLAY "Please wait ..." ;
    DOCOMMAND "DO OPR " + CMDTXT ;
END

COMMAND OUTPUT(
	NOISE "IN QUEUE"
	      );
BEGIN
    DOCOMMAND "INFORMATION OUTPUT-REQUEST";
END

COMMAND P10 ;

BEGIN
    STRING CMDIN ;
    LET CMDIN = "OPR MODIFY PRINTER-REQUEST " ;
    PARSE NOISE "PRINTER-REQUEST" ;
    PARSE NUMBER (HELP "decimal request number" , RADIX 10) ;
    LET CMDIN = CMDIN + $STRING ($VALUE , 10) ;
    PARSE EOL ;
    LET CMDIN = CMDIN + " PRIORITY (to be) 10 " ;
    DOCOMMAND CMDIN ;
END

COMMAND PCL ;

BEGIN
    EXTERNAL STRING PCL_FILE ;
    EXTERNAL STRING PCL_COMMAND ;
    STRING CMDOUT ;
    INTEGER FIRSTC ;
    INTEGER NUMBRC ;
    PARSE KEYWORD (WORDS (BEGIN:1,END:2,INFORMATION:3,RESET:4,TEST:5,
	  UNDECLARE:6),DEFAULT "TEST") ;
    CASE $Value FROM 1 TO 6 OF
    BEGIN
        [1] : !{BEGIN}!
	      BEGIN
	      PARSE NOISE "Test from file" ;
	      PARSE FILE (INPUT, DEFAULT_EXT "PCL") ;
	      PARSE EOL ;
	      PCL_FILE = $FileS ;
	      PCL_COMMAND = "Undefined" ;
	      END ;
	[2] : !{END}!
	      BEGIN
	      PARSE NOISE "Test" ;
	      PARSE EOL ;
	      IF PCL_FILE = "" THEN ABORT "No test started" ;
	      PCL_FILE = "" ;
	      PCL_COMMAND = "" ;
	      END ;
	[3] : !{INFORMATION}!
	      BEGIN
	      PARSE NOISE "About current test" ;
	      PARSE EOL ;
	      IF PCL_FILE = "" THEN ABORT "No test started" ;
	      DISPLAY "File tested : " + PCL_FILE ;
	      DISPLAY "Command tested : " + PCL_COMMAND ;
	      END ;
	[4] : !{RESET}!
	      BEGIN
	      PARSE NOISE "All" ;
	      PARSE EOL ;
	      PROMPT "[Confirm] " ;
	      PARSE EOL ;
	      DOCOMMAND "UNDECLARE /NOCONFIRM COMMAND " + PCL_COMMAND ;
	      PCL_FILE = "" ;
	      PCL_COMMAND = "" ;
	      END ;
	[5] : !{TEST}!
	      BEGIN
	      PARSE NOISE "Command" ;
	      PARSE EOL ;
	      IF PCL_FILE = "" THEN ABORT "No test started" ;
	      DOCOMMAND "DECLARE PCL-ROUTINES " + PCL_FILE TO CMDOUT ;
	      FIRSTC = $SEARCH(CMDOUT," ") + 1 ;
	      NUMBRC = $SEARCH(CMDOUT," ",FIRSTC) - FIRSTC ;
	      PCL_COMMAND = CMDOUT[FIRSTC:NUMBRC] ;
	      DISPLAY NORETURN CMDOUT ;
	      END ;
	[6] : !{UNDECLARE}!
	      BEGIN
	      PARSE NOISE "Tested command" ;
	      PARSE EOL ;
	      IF PCL_FILE = "" THEN ABORT "No test started" ;
	      DOCOMMAND "UNDECLARE /NOCONFIRM COMMAND " + PCL_COMMAND ;
	      PCL_COMMAND = "Undefined"
	      END ;
    END ;
END

COMMAND PLOT(
	NOISE "IN QUEUE"
	    );

BEGIN
    STRING SRVOUT ;
    STRING SRVSTS ;
    EXTERNAL PROCEDURE FLUSHL ;
    INVOKE "SYS:QUEUE.EXE" ;
    CLEARTYPEOUT ;
    TYPEIN "SHOW OUTPUT" ;
    GETTYPEOUT SRVOUT ;
    CLEARTYPEOUT ;
    TYPEIN "SHOW STATUS" ;
    GETTYPEOUT SRVSTS ;
    TYPEIN "EXIT" ;
    KILLPROGRAM ;
    CALL FLUSHL (SRVOUT,"SHOW OUTPUT") ;
    CALL FLUSHL (SRVOUT,"QUEUE>") ;
    CALL FLUSHL (SRVSTS,"SHOW STATUS") ;
    CALL FLUSHL (SRVSTS,"QUEUE>") ;
    DISPLAY SRVOUT ;
    DISPLAY NORETURN "Spooler status :";
    DISPLAY SRVSTS ;
!    DISPLAY "For device BENSON :" ;
!    DOCOMMAND "DIRECTORY PS:<BENSON>*.PLT.* ,
!NO HEADING
!NO SUMMARY-LINE
!NO CRAM
!SEPARATE
!SIZE
!TIMES CREATION
!USER CREATE
!";
!    DOCOMMAND "";
!    DISPLAY "Spooler status :";
!    DOCOMMAND "Systat Header Where What State Time Class Who Line 44"
END

COMMAND POOL(
	NOISE "USAGE"
	    );

BEGIN
    EXTERNAL STRING SYSTAT ;
    STRING SAVE_VAR ;
    SAVE_VAR = SYSTAT ;
    DISPLAY "For pool 1 :" ;
    DOCOMMAND "LINE 6 7 10 11 12 13 14 15 16 17 64 65 " ;
    DISPLAY "For pool 2 :" ;
    DOCOMMAND "LINE 101 102 103 104 105 106 107 110 " ;
    SYSTAT = SAVE_VAR ;
END

COMMAND PURGE ;

BEGIN
    STRING CMDOUT ;
    STRING CMDIN ;
    STRING DIRNAM ;
    STRING FILDES ;
    INTEGER FLDPOS ;
    PARSE NOISE "SAVE FILES FROM DIRECTORY" ;
    LET DIRNAM = $ConnectedDirectory ;
    PARSE DIRECTORY (DEFAULT DIRNAM) ;
    PARSE EOL ;
    LET DIRNAM = $atom ;
    LET FILDES = DIRNAM + "[SAVE].*.*" ;
    DOCOMMAND "QD " + FILDES TO CMDOUT ;
    IF CMDOUT[1:1] <> "%" THEN DOCOMMAND "UNDELETE " + FILDES TO CMDOUT ;
    LET CMDIN = "DELETE " + FILDES + " ," + $CR + "EXPUNGE" + $CR ;
    DOCOMMAND CMDIN TO CMDOUT ;
    IF $SEARCH (CMDOUT,"%") <> 0 THEN EXIT ;
    LET FLDPOS = $SEARCH (CMDOUT,DIRNAM) ;
    IF FLDPOS = 0 THEN EXIT ;
    DISPLAY NORETURN CMDOUT[FLDPOS:*] ;
END

COMMAND QUEUE(
	NOISE "REQUESTING OPERATOR INTERVENTION"
	     );
BEGIN
    DOCOMMAND "BLANK";
    DISPLAY NORETURN "Queues as of ";
    DOCOMMAND "DAYTIME";
    DISPLAY "About Mount requests :";
    DOCOMMAND "DEVICE";
    DISPLAY "About Output requests :";
    DOCOMMAND "OUTPUT";
    DISPLAY "About Retrieval requests :";
    DOCOMMAND "RETRIEVAL";
END

COMMAND REDO ;

BEGIN
    EXTERNAL STRING SYSTAT ;
    PARSE NOISE "LAST PCL SYSTAT COMMAND" ;
    PARSE EOL ;
    DISPLAY "[=>" + SYSTAT + "] " ;
    DOCOMMAND SYSTAT ;
END

COMMAND RETRIEVAL(
	NOISE "IN QUEUE"
	         );
BEGIN
    DOCOMMAND "INFORMATION RETRIEVAL-REQUEST";
END

COMMAND SEND ;

BEGIN
    STRING USRNAM ;
    STRING USRTTY ;
    STRING STEXT1 ;
    STRING STEXT2 ;
    STRING SEPLIN ;
    STRING TMPTXT ;
    INTEGER MAXTTY ;
    INTEGER TTYNUM ;
    INTEGER JSYS ;
    INTEGER CHNNUM ;
    INTEGER MEMADR ;
    INTEGER MEMPNT ;
    INTEGER CRPOS1 ;
    INTEGER CRPOS2 ;
    MAXTTY = 8%110 ;
    TTYNUM = 0 ;
    SEPLIN = "====================================================" ;
    MEMADR = $GET_MEM (500) ;
    PARSE NOISE "MESSAGE TO" ;
    PARSE (
    NUMBER (HELP "Octal line number" , RADIX 8) : TTYNUM = $VALUE ;
    USERNAME : USRNAM = $Atom ;
    KEYWORD (WORDS (ALL:1,GROUP:2)) : 
    CASE $Value FROM 1 TO 3 OF
    BEGIN
        [1] : !{ALL}!
	      BEGIN 
	      TTYNUM = (-2+1) ;
	      END ;
	[2] : !{GROUP}!
	      BEGIN
	      PARSE USERNAME (HELP "Top level user name for the group") ;
	      USRNAM = $Atom + "*" ;
	      END ;
    END ;
          ) ;
    PARSE (
    EOL (HELP "Confirm for input from terminal") :
    BEGIN
	MEMPNT = 8%777777000000 + MEMADR ;
        DISPLAY "Enter text, end with CR followed by ESC or ^Z :" ;
	CHNNUM = 8%400000000000 + 2000 ;
	JSYS = $JSYS(8%523,MEMPNT,CHNNUM,0) ;
	IF JSYS = 0 THEN
	BEGIN
	    CALL $RET_MEM (MEMADR,500) ;
	    ABORT "RDTTY Jsys error" ;
	END ;
	STEXT2 = $SGET (MEMADR) ;
	TMPTXT = "" ;
	CRPOS1 = 1 ;
	CRPOS2 = $SEARCH (STEXT2,$CR) ;
	IF CRPOS2 = 0 THEN TMPTXT = "Message vide ..." + $CRLF + " ";
	UNTIL CRPOS2 = 0  DO
	BEGIN
	    TMPTXT = TMPTXT + STEXT2[CRPOS1:CRPOS2+2-CRPOS1] + $CVITC(9) ;
	    CRPOS1 = CRPOS2+2 ;
	    CRPOS2 = $SEARCH (STEXT2,$CR,CRPOS1) ;
	END ;
	STEXT2 = $CRLF + "      =>" + TMPTXT[1:$LENGTH(TMPTXT)-1] ; 
	DISPLAY "" ;
    END ;
    INPUTFILE (HELP "Text file") :
    BEGIN
	PARSE EOL ;
	CHNNUM=$OPEN($FILES,$INPUT);
	STEXT2=$CRLF+"      =>"+$READ(CHNNUM);
	IF $EOF(CHNNUM)<>0 THEN STEXT2=STEXT2+"Message vide ..."+$CRLF+" ";
	WHILE $EOF(CHNNUM)=0 DO 
	BEGIN
	    STEXT2=STEXT2+$CRLF+$CVITC(9)+$READ(CHNNUM);
	END ;
	CALL $CLOSE(CHNNUM) ;
	STEXT2 = STEXT2[1:$LENGTH(STEXT2)-1] ; 
    END ;
          ) ;
    STEXT1 = $CRLF + SEPLIN + $CRLF + "[" + $TIME ;
    STEXT1 = STEXT1 + "  Message from user " + $UserName ;
    STEXT1 = STEXT1 + " at terminal " + $STRING($TermNumber,8) + "]";
    STEXT1 = STEXT1 + STEXT2 + SEPLIN + $CRLF ;
    MEMPNT = 8%777777000000 + MEMADR ;
    CALL $SPUT (STEXT1,MEMADR) ;
    IF TTYNUM = -1 THEN
    BEGIN
	PROMPT "Sending message to All [Confirm] " ;
	PARSE EOL ;
	JSYS = $JSYS (8%775,TTYNUM,MEMPNT) ;
	IF JSYS = 0 THEN
	BEGIN
	    CALL $RET_MEM (MEMADR,500) ;
	    ABORT "TTMSG Jsys error" ;
	END ;
	CALL $WAIT($LENGTH(STEXT1)*100) ;
    END 
    ELSE IF TTYNUM = 0 THEN
    BEGIN
	DOCOMMAND "SYSTAT NO WHAT NO WHO " + USRNAM TO USRTTY ;
	IF $LENGTH(USRTTY) = 0 THEN
	BEGIN
	    DISPLAY "%User not logged in" ;
	    CALL $RET_MEM (MEMADR,500) ;
	    EXIT ;
	END ;
	CRPOS1 = 1 ;
	CRPOS2 = $SEARCH (USRTTY,$CR) ;
	DISPLAY NORETURN "Line " ;
	UNTIL CRPOS2 = 0  DO
	BEGIN
	    TMPTXT = USRTTY[CRPOS1:CRPOS2+2-CRPOS1] ;
	    CRPOS1 = CRPOS2+2 ;
	    CRPOS2 = $SEARCH (USRTTY,$CR,CRPOS1) ;
	    TTYNUM = $INTEGER(TMPTXT[8:3],8) ;
	    IF TTYNUM > 0 THEN IF TTYNUM <= MAXTTY THEN
	    BEGIN
		DISPLAY NORETURN $STRING(TTYNUM,8) + " " ;
		TTYNUM = TTYNUM + 8%400000 ;
		JSYS = $JSYS (8%775,TTYNUM,MEMPNT) ;
		IF JSYS = 0 THEN
		BEGIN
		    CALL $RET_MEM (MEMADR,500) ;
		    ABORT "TTMSG Jsys error" ;
		END ;
		CALL $WAIT($LENGTH(STEXT1)*10) ;
	    END ;
	END ;
    DISPLAY "" ;
    END 
    ELSE IF TTYNUM > 0 THEN IF TTYNUM <= MAXTTY THEN
    BEGIN 
	TTYNUM = TTYNUM + 8%400000 ;
	JSYS = $JSYS (8%775,TTYNUM,MEMPNT) ;
	IF JSYS = 0 THEN
	BEGIN
	    CALL $RET_MEM (MEMADR,500) ;
	    ABORT "TTMSG Jsys error" ;
	END ;
    END
    ELSE
    BEGIN
	CALL $RET_MEM (MEMADR,500) ;
	ABORT "Line number out of range" ;
    END ;
    CALL $WAIT($LENGTH(STEXT1)*10) ;
    CALL $RET_MEM (MEMADR,500) ;
    DISPLAY "Message sent at " + $TIME ;
END

COMMAND SERVICE(
	NOISE "JOBS"
	        );
BEGIN
    DOCOMMAND "SYSTAT SYSTEM HEADER ALL NO LIMIT OPERATOR";
END

COMMAND STRUCTURE ;

BEGIN
    STRING CMDIN ;
    STRING CMDOUT ;
    LET CMDIN = "INFORMATION STRUCTURE ";
    PARSE NOISE "STATUS";
    PARSE (
	EOL (HELP "for all structure" , STDHELP ) :
	BEGIN
	    LET CMDIN = CMDIN + "*" ;
	    GOTO DOIT ;
	END;
	TOKEN "." (HELP "[.] for connected directory") :
	BEGIN
	    !Nothing to do in this case!;
	END;
	DEVICE (HELP "structure name") :
	BEGIN
	    LET CMDIN = CMDIN + $ATOM + ":" ;
	END;
	);
    PARSE EOL ;
DOIT:
    DOCOMMAND CMDIN TO CMDOUT ;
    IF CMDOUT[1:1] = "?" THEN ABORT "Invalid stucture name" ;
    DISPLAY NORETURN CMDOUT ;
END ;

COMMAND USER ;

BEGIN
    EXTERNAL STRING SYSTAT ;
    STRING CMDOUT ;
    STRING CMDPRS ;
    PARSE NOISE "SYSTAT" ;
    PLOOP:
    PARSE (
    USERNAME:
    BEGIN
	LET CMDPRS = CMDPRS + " " + $Atom ;
        GOTO PLOOP ;
    END ;
    EOL ;
           ) ;
    IF $LENGTH (CMDPRS) = 0
        THEN DOCOMMAND "SYSTAT SYSTEM HEADER STATE DIRECTORY " + $UserName
        ELSE
        BEGIN
            DOCOMMAND "SYSTAT HEADER STATE DIRECTORY" + CMDPRS  TO CMDOUT ;
            LET SYSTAT = "USER (SYSTAT)" + CMDPRS ;
            IF $LENGTH (CMDOUT) = 0
                THEN BEGIN
		     DISPLAY "%User(s) not logged in" ;
		     RETURN ;
		     END
                ELSE DISPLAY NORETURN CMDOUT ;
        END ;
END

COMMAND WATCH(
	NOISE "SYSTEM"
	     );

BEGIN
    DOCOMMAND "CONTINUE SYSDPY";
END

COMMAND XOFF(
	NOISE "AT END-OF-PAGE"
	    );

BEGIN
    DOCOMMAND "TERMINAL NO PAUSE END-OF-PAGE";
END

COMMAND XON(
	NOISE "AT END-OF-PAGE"
	   );

BEGIN
    DOCOMMAND "TERMINAL PAUSE END-OF-PAGE";
END

COMMAND Z ;

BEGIN
    STRING GARBAGE ;
    PARSE NOISE "ADVANCE PAPER" ;
    PARSE EOL ;
    DOCOMMAND "TAKE P2" TO GARBAGE ;
END

PROCEDURE FLUSHL (STRING BIGTXT,SMLTXT) ;

BEGIN
    STRING WRKTXT ;
    INTEGER SMLBEG ;
    INTEGER LINBEG ;
    INTEGER LINEND ;
    SMLBEG = $SEARCHRAISED (BIGTXT,SMLTXT) ;
    IF SMLBEG = 0 THEN RETURN ;
    LINEND = $SEARCH (BIGTXT,$CRLF) ;
    IF LINEND > SMLBEG THEN
    BEGIN
	BIGTXT = BIGTXT [LINEND+2:*] ;
	RETURN ;
    END;
    IF LINEND = 0 THEN 
    BEGIN
	BIGTXT = "" ;
	RETURN ;
    END;
LBLOOP:
    LINBEG = LINEND ;
    LINEND = $SEARCH (BIGTXT,$CRLF,LINBEG+2) ;
    IF LINEND = 0 THEN
    BEGIN
	BIGTXT = BIGTXT [1:LINBEG-1] ;
	RETURN ;
    END;
    IF LINEND < SMLBEG THEN GOTO LBLOOP ;
    WRKTXT = BIGTXT [1:LINBEG-1] ;
    WRKTXT = WRKTXT + BIGTXT [LINEND+2:*] ;
    BIGTXT = WRKTXT ;
    RETURN ;
END

STRING PCL_FILE ;
STRING PCL_COMMAND ;
STRING SYSTAT ;
  