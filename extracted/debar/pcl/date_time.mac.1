;DATE AND TIME
;THE POSSIBILE THINGS ARE:
;
;1)	SPECIFIC DATE AND TIME (OR JUST TIME, WHICH ASSUMES TODAY)
;
;2)	"+" OR "-" FOLLOWED BY AMOUNT OF TIME, WHICH MEANS NOW + - AMOUNT
;
;3)	KEYWORD, FOLLOWED BY KEYWORD-DEPENDENT DATA

DA%DAY==1B18			;BIT TO MEAN DAY OF THE WEEK

;KEYWORD TABLE FOR DATE AND TIME

$DKEYS:	TABLE
	T FRIDAY,,DA%DAY+4
	T MONDAY,,DA%DAY+0	;TOO BAD THIS HAS TO BE ALPHABETICAL
	T SATURDAY,,DA%DAY+5
	T SUNDAY,,DA%DAY+6
	T THURSDAY,,DA%DAY+3
	T TODAY
	T TOMORROW
	T TUESDAY,,DA%DAY+1
	T WEDNESDAY,,DA%DAY+2
        T YESTERDAY
	TEND

DTR$:	MOVEI A,1		;SAY WE WANT TIME RELATIVE TO NOW
	JRST DT1

!
! sense values:
! /before -1
! /after   0
! relative 1

DT$:	TDZA A,A		;SAY WE WANT TIME IN THE FUTURE
DTP$:	MOVNI A,1		;SAY WE WANT TIME IN THE PAST
DT1:	TRVAR <RETBTS,TODAY,SENSE,DAYWEK,NOW,TOMORO,BTIME,<STRNG0,10>>
	MOVEM A,SENSE		;REMEMBER WHETHER FUTURE OR PAST
	SETZM RETBTS		;INITIALLY, NO RETURN BITS
	CALL GETHLP
!
! get the current date
!
	GTAD			;GET CURRENT TIME AND DATE
	MOVEM A,NOW
	MOVSI B,1
!
! computing internal date for tomorrow. Goes in round about way,
! why not simply zero the right half and add 1 to the left half ?
!
	ADD B,A			;GET TOMORROW SAME TIME IN A
	HRROI A,STRNG0		;WRITE TO SCRATCH
	MOVX C,OT%NTM		;WE WANT ONLY DATE
	ODTIM			;GET STRING FOR TOMORROW'S DATE
	HRROI B,[ASCIZ / 0:0:0/]
	MOVEI C,0
	SOUT			;MAKE DATE AND TIME FOR BEGINNING OF TOMORROW
	HRROI A,STRNG0		;POINT AT FULL STRING
	MOVEI B,0		;NO SPECIAL FORMAT
	IDTIM			;GET INTERNAL FORMAT FOR TOMORROW
	 CALL JERR		;SHOULDN'T FAIL
	MOVEM B,TOMORO		;REMEMBER VALUE FOR TOMORROW
!
! store date for beginning of today:
! tomorrow - 1 in the left half ???? again, quite a detour.
! Should check: if right half is EXACTLY zero, then this is it
!

	SUB B,[1B17]		;CREATE BEGINNING OF TODAY
	MOVEM B,TODAY
!
! select the correct chains of flddbs depending on
! relative time/after/before options.
!

	MOVX A,CM%IDA+CM%ITM
	MOVEM A,CMDAT		;FIRST FUNCTION IN CHAIN IS DATE AND TIME
	MOVE A,[CMTAD+[FLDDB. .CMTAD,CM%SDH,CM%IDA,,,[
		FLDDB. .CMTAD,CM%SDH,CM%ITM,,,[
		FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /+/]>,<"+" to enter amount of time from now>,,[
		FLDDB. .CMKEY,CM%SDH,$DKEYS,<day of the week or TODAY>]]]]]
	SKIPGE SENSE		;DIFFERENT CHOICES FOR DATE AND TIME IN PAST
	MOVE A,[CMTAD+[FLDDB. .CMTAD,CM%SDH,CM%IDA,,,[
		FLDDB. .CMTAD,CM%SDH,CM%ITM,,,[
		FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /-/]>,<"-" to enter amount of time in past>,,[
		FLDDB. .CMKEY,CM%SDH,$DKEYS,<day of the week or TODAY>]]]]]
!
! do the parse
!

	CALL $WORK
	 RET			;BAD INPUT TYPED
!
! get the result and dispatch accordingly
!
	LDB D,[331100,,(C)]	;GET FUNCTION FLAVOR
	CAIN D,.CMKEY		;KEYWORD?
	JRST DAKEY		;YES, GO HANDLE IT
	CAIN D,.CMTOK		;"+" OR "-"?
	JRST GETPLM		;YES, GO HANDLE IT
!
! User has typed a date or a time
!
	MOVE D,.CMDAT(C)	;GET CONTROL BITS
	MOVX A,DATBIT		;GET BIT SAYING USER TYPED A DATE
!    if parsed a date, remember it and go exit.
	TXNE D,CM%IDA		;IS IT A DATE?
	JRST	[IORM A,RETBTS	;YES, REMEMBER
		 JRST DTEXIT]	;GO DO STANDARD EXIT
!    if not doing before or after, exit
	SKIPLE A,SENSE		;IS TIME INDEPENDENT?
	 JRST DTEXIT		;YES, NO FIXUP NEEDED
!    if need to add time to current value, add it.
	CAMG B,NOW		;COMPUTE VALUE TO ADD
	ADDI A,1
	JUMPE A,DTEXIT		;DON'T BOTHER IF ZERO
	HRLZS A			;PUT VALUE IN LEFT HALF
	ADD B,A			;FIX UP DATE-TIME
	JRST DTEXIT		;TAKE STANDARD EXIT

!
! parsed a + or a -, 
!    Calls GETAMT to parse a time only, and add/substract it.
!
GETPLM:	CALL GETAMT		;GOT A DATE IN THE PAST OR FUTURE -  GET AMOUNT
	 RET			;SYNTAX ERROR
	SKIPGE SENSE
	MOVN A,A		;HANDLE "DIRECTORY SINCE -4:0:0"
	ADD A,NOW		;ADD TO NOW
	MOVE B,A		;RETURN RESULT IN B AND FALL INTO EXIT
	;...

;DTEXIT is the common exit for time-and-date parsing.  It returns bits in
;A declaring what the user typed.

DTEXIT:	MOVE A,RETBTS		;GET RETURN BITS
	RETSKP			;SKIP TO DENOTE SUCCESS

;ROUTINE TO INPUT AN AMOUNT OF TIME.
;RETURNS:
;	+1	SYNTAX ERROR
;	+2	A/	INTERNAL FORMAT
;		B/	SECONDS

GETAMT::STKVAR <CTIM>
!
! Parse a decimal number (hours)
!
	DECX <Amount of time in form hh:mm>
	 RET			;GIVE UP IF CAN'T READ HOURS
	IMULI B,^D3600		;CHANGE TO SECONDS
	MOVEM B,CTIM		;SAVE NUMBER OF SECONDS
!
! parse a colon
!
	COLONX <Colon to separate hours and minutes>
	 JRST ONENUM		;ONLY ONE NUMBER BEING TYPED
!
! parse a decimal number (minutes)
!
	DECX <Minutes>
	 RET			;ERROR IF NO NUMBER AFTER COLON
	IMULI B,^D60		;CHANGE MINUTES TO SECONDS
	ADDM B,CTIM		;ACCUMULATE RESULT
!
! parse a colon
!
	COLONX <Colon, if seconds are being entered>
	 JRST NOSECS		;NO SECONDS FORTHCOMING (THAT'S O.K.)
!
! parse a decimal number (seconds)
!
	DECX <Seconds>
	 RET			;ERROR IF SECOND COLON AND NO SECONDS
!
! convert to correct internal format
!
	ADD B,CTIM		;GET TOTAL SECONDS
T22:	MOVEM B,CTIM		;REMEMBER SECONDS
	MUL B,[1B17]		;IN INTERNAL FORMAT, RIGHT HALF OVER 1B17 IS FRACTION OF A DAY
	DIV B,[^D86400]		;DIVIDE BY SECONDS IN A DAY
	CAILE C,^D86400/2	;ROUND
	AOJ B,
	MOVE A,B		;RETURN RESULT IN A
	MOVE B,CTIM		;RETURN SECONDS IN B
	RETSKP

ONENUM:	MOVE B,CTIM		;GET NUMBER OF SECONDS GIVEN HOURS
	IDIVI B,^D60		;TREAT NUMBER AS THOUGH IT WERE ORIGINALLY MINUTES
	JRST T22

NOSECS:	MOVE B,CTIM		;NO SECONDS FORTHCOMING
	JRST T22

;KEYWORD TYPED AFTER /AFTER:

!
! typed a keyword of the form Today, etc
! After call to getkey p3 contains the right half of Table MONDAY,xxx
! which is eithet da%day+"day-offset", or the name of a routine to
! call

DAKEY:	CALL GETKEY		;GET KEYWORD DATA
	TXNN P3,DA%DAY		;DAY OF THE WEEK?
	JRST (P3)		;NO, DO SPECIFIC THING
! 
! Day of the week
!
!   if tomorrow is tuesday, 
!   if we want wednesday:
!       (wednesday-tueday) = +2 days !!
!   BUT if /after:wednesday --> first thing on thursday (DEC OPTION)
!       if /before:wednesday -> means the "real" date

	ANDI P3,7		;DAY OF THE WEEK, KEEP ONLY IT
	MOVEM P3,DAYWEK		;REMEMBER DAY
	MOVE B,TOMORO		;PUT TOMORROW REAL EARLY MORNING IN B
	MOVEI D,0		;NO SPECIAL BITS
	ODCNV			;SEE WHAT DAY OF WEEK TOMORROW IS
	SKIPN SENSE
! do here /after bit
	JRST [	MOVNI C,-1(C)	;NEGATE DAY OF WEEK AND FLUSH DAY OF MONTH
		HRRE C,C	;FOR SUNDAY, GET RID OF 777777 IN LEFT HALF
		ADD C,DAYWEK	;GET NUMBER OF DAYS FROM TOMORROW IS DESIRED
		CAIGE C,0
		ADDI C,7	;FOR FUTURE, "SUBMIT /AFTER:MONDAY" MEANS NEXT TUESDAY OR LATER
		JRST SL]
! /before or relative
	SUB C,DAYWEK
	MOVNI C,(C)		;GET NEGATIVE NUMBER OF DAYS BEFORE TOMORROW WE WANT, AND FLUSH DAY OF MONTH
	HRRE C,C		;IN CASE C WAS NEGATIVE BEFORE
	SKIPLE SENSE		;RELATIVE TO NOW?
	 JRST SL		;YES - CHECK LATER
! do here the relative bit
	CAIL C,0
	SUBI C,7		;FOR PAST, "DIRECTORY SINCE MONDAY" MEANS FILES WRITTEN LAST MONDAY OR MORE RECENTLY"
SL:	ASH C,22		;SHIFT INTO POSITION FOR INTERNAL FORMAT
	ADD C,TOMORO		;GET INTERNAL REPRESENTATION FOR DAY SPECIFIED
	MOVEM C,BTIME
	JRST DAPLSQ		;MAYBE USER TYPING "+" AFTER THE DAY

;USER HAS TYPED /AFTER:TODAY OR SINCE TODAY

.TODAY:	MOVE A,TOMORO		;GET VALUE FOR TOMORROW
	SKIPE SENSE
	MOVE A,TODAY		;FOR TIME IN PAST, BASE IS BEGINNING OF TODAY
	MOVEM A,BTIME		;REMEMBER IT AS BASE VALUE
DAPLSQ:	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<-1,,[ASCIZ /+/]>,<Optional "+" to add amount of time>]
	CALL FLDSKP		;IS USER TYPING "+"?
	JRST NOPLUS		;NO
	CALL GETAMT		;YES, GET AMOUNT OF TIME
	 RET			;IF ERROR, NON-SKIP
DAA1:	ADD A,BTIME
	MOVE B,A		;RETURN INTERNAL DATE-AND-TIME IN B
	SKIPG SENSE		;RELATIVE TO NOW?
	 JRST DTEXIT		;NO - DONE
	CAMG B,NOW		;TIME IN FUTURE?
	 ADD B,[7B17]		;NO - JUMP AHEAD 1 WK
	JRST DTEXIT		;RETURN

NOPLUS:	MOVEI A,0		;NO PLUS, SO NO MODIFICATION OF BASE TIME
	JRST DAA1
