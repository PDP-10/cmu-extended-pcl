










                                  TOPS-20                                  TOPS-20                                  TOPS-20


                       PROGRAMMABLE COMMAND LANGUAGE                       PROGRAMMABLE COMMAND LANGUAGE                       PROGRAMMABLE COMMAND LANGUAGE


                               USER'S GUIDE                               USER'S GUIDE                               USER'S GUIDE


                                    AND                                    AND                                    AND


                             REFERENCE MANUAL                             REFERENCE MANUAL                             REFERENCE MANUAL
























     Copyright (C) 1982 Carnegie Mellon University Computation CenterProgrammable Command Language                                        Page 1


                                 CHAPTER 1                                 CHAPTER 1                                 CHAPTER 1

                               INTRODUCTION                               INTRODUCTION                               INTRODUCTION



1.1. Programmable Command Language1.1. Programmable Command Language1.1. Programmable Command Language

  The  PCL  Extension to the TOPS-20 EXEC puts a language and executor into

the TOPS-20 EXEC.  With this high level language and its extensions,  users

can  easily  to  write  their  own  PCL  programs which will will look like

existing TOPS commands complete with  parameter  substitution  and  TOPS-20

style recognition.



1.2. PCL Uses1.2. PCL Uses1.2. PCL Uses

  PCL  may used in a variety of different ways.  Users might write friendly

front ends to existing programs.   The  command  parsing  with  recognition

makes  a  very  easy way to do parameter passing to a program.  Periodic or

repetitive tasks can be coded in PCL routines which would reduce the amount

of typing needed to accurately execute all the steps necessary to  complete

a piece of production.



  PCL  also  will provide a means for implementing completely new functions

which are not possible in the current EXEC.  For example, if the user has a

graphics terminal which takes special support  then  PCL  can  be  used  to

provide new support commands.



  System  administrators  can  tailor  their EXEC to provide local commands

that  override  the  function  of  standard  commands.    For  example,  an

administrator may wish to eliminate the PLOT command if there is no plotterProgrammable Command Language                                        Page 2


on the system.



1.3. PCL Features1.3. PCL Features1.3. PCL Features

  The main features of PCL are:


   - ALGOL-like language constructs

   - string manipulation

   - callable procedures with parameters

   - system services

   - flexible user interface

   - program interface

   - input/output capabilitiesProgrammable Command Language                                        Page 3


                                 CHAPTER 2                                 CHAPTER 2                                 CHAPTER 2

                              EXEC INTERFACE                              EXEC INTERFACE                              EXEC INTERFACE

  PCL  commands  can be written with any text editor.  The source for these

commands is stored in files with the default type  PCL.  Source  files  are

                                                 DECLARE                                                 DECLAREcompiled  into a command by the new EXEC command DECLARE.  Once the command

is successfully compiled, it is stored in the EXEC and becomes  a  part  of

the  list  of commands that the user has available during that job.  If the

DECLAREDECLAREDECLARE command detects an error in the PCL source, an error  message  will

be  typed  on  the  terminal  along  with  the  line in error and a pointer

indicating about where the error occurred.  Once an error is  detected  the

compilation stops at that point.



  Any  user command which has the same name as an existing command overlays

                                            ORIGINAL                                            ORIGINALthe existing command.  The new EXEC command ORIGINAL may be used to execute

any of the standard  EXEC  commands.  Commands  may  be  removed  with  the

UNDECLAREUNDECLAREUNDECLARE command.



  In  addition  to  declaring  PCL  commands,  the user may use the DECLARE

                   __________command to declare procedures which  may  be  called  from  user  commands,

______  _________       _______ _________string  variables,  and integer variables.  One PCL source file may contain

many command, procedure, and variable declarations.  The variables  may  be

                               SET                                STRING                               SET                                STRINGgiven  values  by  using  the  SET  command  with the new options STRING or

INTEGERINTEGERINTEGER.  For example:


    SET STRING        (TO)    SET STRING        (TO)    SET STRING myname (TO) scott


                    ______The string variable myname may be accessed from  any  declared  command  orProgrammable Command Language                                        Page 4


procedure.



                                                   PCL-OBJECTS                                                   PCL-OBJECTS  A  new  option  to  the INFORMATION command, the PCL-OBJECTS option, will

show the user all user defined commands, procedures, and variables.


             INFORMATION         PCL-OBJECTS             INFORMATION         PCL-OBJECTS            @INFORMATION (ABOUT) PCL-OBJECTS
             Commands: DRP, REMIND, NETMAILCHECK, DIALUPLINE, COURIER
             Procedures: MATCH
             Variables: String MYNAME, Integer MYJOB


Once the user has a set of procedures and commands defined,  these  may  be

                                     ENVIRONMENT                   PRESERVE               ___________           ENVIRONMENT                   PRESERVEsaved  in  an  ENVIRONMENT using the ENVIRONMENT option to the new PRESERVE

command.  To recall an  environment,  use  the  DECLARE  command  with  the

ENVIRONMENT  option.    Commands  and  procedures  in environment files are

stored in an internal format, so they are  not  recompiled  when  they  are

declared.  The user may declare multiple environment files and the commands

from each environment will be added to the user's EXEC command list.Programmable Command Language                                        Page 5


                                 CHAPTER 3                                 CHAPTER 3                                 CHAPTER 3

                             THE PCL LANGUAGE                             THE PCL LANGUAGE                             THE PCL LANGUAGE



3.1. General Command Format3.1. General Command Format3.1. General Command Format

  The simple definition of a command is:


    COMMAND    COMMAND ____    COMMAND name;
            ___ _________            PCL statement


A simple example would be:


            COMMAND            COMMAND            COMMAND simple;
            Display "This is a simple command"


                                      simple.pcl                                      simple.pclIf the above 2 lines were in the file simple.pcl then


            @DECLARE PCL simple.pcl


would enter the command simple into the users EXEC.  If the user types:


            SIMPLE


at the "@" prompt then 


           This is a simple command


would be typed on the user's terminal.



  A more general (and useful) simple definition of a command is:


            COMMAND            COMMAND ____            COMMAND name;
               Begin               Begin               Begin
                 ...;
                 ...
               End               End               EndProgrammable Command Language                                        Page 6


where  any number of PCL statements separated by semi-colons may be between

the BEGIN-END pair.  Statement labels may be up to 40 characters  long  and

are terminated with a colon.  Comments may be placed anywhere in PCL source

files.  A comment should begin with an exclamation mark.


            COMMAND simple;
            BEGIN
             ...;
            LAB1:            LAB1:            LAB1:
             !The above line is a label
                           !This is a comment                           !This is a comment             Display "Hi"  !This is a comment
            End



3.2. PCL Variables3.2. PCL Variables3.2. PCL Variables

  The PCL language provides for integer and string variables, which must be

declared at the beginning of a routine.  For example:


            COMMAND simple;
            BEGIN
             STRING             STRING             STRING name_in_full;
             INTEGER             INTEGER             INTEGER count;
              ...
            END


would  define  an integer and a string variable.  Variable names may be any

combination of letters, numbers, and the under-score character.  Names  may

be up to 40 characters in length.



  Variables may be assigned values using the assignment statement.Programmable Command Language                                        Page 7


            COMMAND simple;
            BEGIN
             STRING name_in_full;
             INTEGER count;
             count = 3;             count = 3;             count = 3;
             name in full = "J. Ray Scott"             name in full = "J. Ray Scott"             name_in_full = "J. Ray Scott";
              ...
            END



3.3. String Manipulation3.3. String Manipulation3.3. String Manipulation

  Strings may be concatenated using simple addition statements.


    conc_string = "Welcome " + name_in_full



  Substrings may be extracted from strings:  


           extr_string = conc_string[n:m]


       _                                      _where  n is the starting character number and m is the number of characters

to extract.  The leftmost character is character position 1.  The user  may
                               th
                              _use [n:*] to extract from the n   character to the end of the string.



                                                    $LENGTH                                                    $LENGTH  The  length of a string may be obtained using the $LENGTH system service.




                   $LENGTH                   $LENGTH           count = $LENGTH(conc_string)


                                      ____ ______would assign the length of the string conc_string to the  integer  variable

_____count.



  The  PCL  routine  may  search  for  a substring of a string by using the

$SEARCH$SEARCH$SEARCH system service.Programmable Command Language                                        Page 8


                   $SEARCH                   $SEARCH           count = $SEARCH(conc_string,"SCOTT")


                                                   _____    _____would  assign  the starting location of the string SCOTT to count if it was

                    ____ ______found in the string conc_string).



3.4. Procedures3.4. Procedures3.4. Procedures

  The format of a procedure definition in a source file is the same at that

of a command definition except that the word COMMAND is replaced  with  the

     PROCEDURE     Return     PROCEDURE     Returnword PROCEDURE.  A Return statement will return to the calling PCL routine.


            PROCEDURE            PROCEDURE            PROCEDURE doit;
            Begin
             ...
            Return            Return            Return
            End



  To  use  the  procedure  DOIT  in  a command it must be declared and then

called.


            COMMAND callit;
            Begin
             EXTERNAL PROCEDURE             EXTERNAL PROCEDURE             EXTERNAL PROCEDURE doit;
             ...
             CALL             CALL             CALL doit;
             ...
            End



  Parameters to procedures are declared by placing the list  of  parameters

in  parenthesis  after  the  procedure name.  The parameters must be typed,

i.e., they must be specified as being either integers or strings.


                           (INTEGER                STRING       )                           (INTEGER                STRING       )            PROCEDURE doit (INTEGER para_1,para_2; STRING para_1);Programmable Command Language                                        Page 9


  Procedures  may  have  a  type  and thus return a value.  To have a typed

                   INTEGER    STRING                   INTEGER    STRINGprocedure the word INTEGER or STRING is placed in front  of  the  PROCEDURE

keyword  in  the source file.  The value to be returned is placed after the

RETURN.  This may be any expression of the appropriate type.


            INTEGER            INTEGER            INTEGER PROCEDURE upone (INTEGER in);
                   in+1                   in+1            RETURN in+1



3.5. PCL Flow Control3.5. PCL Flow Control3.5. PCL Flow Control

  PCL provides several ways to control the sequence of execution.


   - DO WHILE UNTIL

   - IF ... THEN ... ELSE

   - CASE

   - SELECT

   - GOTO


3.5.1. DO, WHILE3.5.1. DO, WHILE3.5.1. DO, WHILE

  DO     WHILE  DO     WHILE  DO and WHILE are available for program loops.  These may be used  in  the

following combinations:


      DO               WHILE      DO ___ _________ WHILE _______ __________   1. DO PCL statement WHILE logical expression

      WHILE                    DO      WHILE _______ __________ DO ___ _________   2. WHILE logical expression DO PCL statement


3.5.2. IF3.5.2. IF3.5.2. IF

       IF       IF  The  IF  statement will execute a PCL statement if the condition is true.

IF             ELSEIF             ELSEIF may have an ELSE clause.Programmable Command Language                                       Page 10


            IF            IF            IF str_val = "xyz"
            THEN            THEN            THEN
                ___ _________                PCL statement
            ELSE            ELSE            ELSE
                ___ _________                PCL statement


3.5.3. CASE3.5.3. CASE3.5.3. CASE

       CASE       CASE  The  CASE statement provides a method of choosing among integer values in

a specified range.  The user may also execute a PCL statement if the  value

is in the specified range.


            CASE       FROM   to   of            CASE       FROM   to   of            CASE count FROM 1 to 5 of
                BEGIN
                1:        BEGIN ... END;
                2:        BEGIN ... END;
                5:        BEGIN ... END;
                INRANGE                INRANGE                INRANGE:  BEGIN ... END;
                OUTRANGE                OUTRANGE                OUTRANGE: BEGIN ... END
                END


3.5.4. SELECT3.5.4. SELECT3.5.4. SELECT

       SELECT       SELECT  The  SELECT  statement  is  similar  to  the  CASE statement.  Instead of

                                                     SELECT                                                     SELECTchoosing among a set of integer values in a  range,  SELECT  chooses  among

arbitrary  expressions.   The expression and the test values must be of the

same type, either integer or string.


            SELECT         of            SELECT         of            SELECT str_var of
                BEGIN
                "abc":     BEGIN ... END;
                "xyz":     BEGIN ... END;
                OTHERWISE                OTHERWISE                OTHERWISE: Display "Not found"
                END



                             ___ ___                         ___  In the above example.  If  str_var  contains  the  string  abc  then  the

                                             _____  _statements  in the BEGIN-END pair after the ["abc"]_: will be executed.  If

                                        OTHERWISE___ ___            ___     ___          OTHERWISEstr_var is neither abc nor xyz then the OTHERWISE clause will be  executed,Programmable Command Language                                       Page 11


in this case it will display 


           Not found


                                                                     SELECT                                                                     SELECTon  the  terminal  and  proceed  to the next PCL statement after the SELECT

statement.


3.5.5. GOTO3.5.5. GOTO3.5.5. GOTO

      GOTO      GOTO  The GOTO PCL statement causes an unconditional transfer to a label.


            COMMAND xfer;
             BEGIN
             ...;
             loop1:             loop1:             loop1:
             ...;
             GOTO loop1;             GOTO loop1;             GOTO loop1;
             ...
            ENDProgrammable Command Language                                       Page 12


                                 CHAPTER 4                                 CHAPTER 4                                 CHAPTER 4

                              USER INTERFACE                              USER INTERFACE                              USER INTERFACE

  Parameters  are  often  passed  to  commands from the terminal, just like

normal Exec commands.  PCL  allows  the  user  to  specify  such  parameter

parsing  using  the same monitor call as the Exec uses, so the user is able

to write commands which look like standard Exec commands.



  When creating commands, it is easiest first to parse all  the  parameters

and  to  store  them in appropriate variables, then to parse the end of the

line to allow the user to confirm the command, and only then to perform the

actions which comprise the command.  It is possible, using the COMND% JSYS,

to make programs which parse a few arguments, do some  irreversible  action

(such  as  deleting  a  file),  and  then  parse a few more arguments; such

programs upset users who, for instance, type ^U while entering  those  last

parameters,  since  the program has already deleted the file.  PCL enforces

and encourages the more desirable mode of operation, in part by  performing

an  assumed  End-of-line  Parse  before  performing  major  actions such as

DoCommand.



  Command parsing is done a line at a time, where the user types a line and

the program parses it.  This means that once a line has been confirmed with

an End-of-line  Parse,  no  more  fields  can  be  parsed  with  the  Parse

statement,  since  there  is  no  command  line  to parse from.  The Prompt

statement can be used to allow the user to enter another line to be parsed;

see Prompt on page 75.Programmable Command Language                                       Page 13


  If  a PCL command contains none of the three forms of command parsing, it

is built as if it started off with an End-of-line Parse.



4.1. Parse formats4.1. Parse formats4.1. Parse formats

  There are three ways to cause PCL to parse such parameters; in each  case

the  user  specifies  what type of parameter is expected, and PCL parses it

from the command line and delivers it to the PCL command.


4.1.1. Simple PARSE4.1.1. Simple PARSE4.1.1. Simple PARSE

             PARSE             PARSE  The simple PARSE statement may be placed anywhere within the command.


            COMMAND getarg;
            BEGIN
            INTEGER repeat_count;
             ...;
            PARSE            PARSE            PARSE NUMBER;
                           $VALUE                           $VALUE            repeat_count = $VALUE;
             ...;
            PARSE            PARSE            PARSE EOL;
             ...
            END


would parse for a number, store it in a variable for use, execute some more

PCL statements, and then parse for a carriage return.  The PARSE  statement

                                                                   $VALUE                                                                   $VALUEwould store the value that the user entered in the system variable $VALUE.


4.1.2. Complex PARSE4.1.2. Complex PARSE4.1.2. Complex PARSE

                                           PARSE                                           PARSE  The complex parse provides a way for one PARSE statement to parse for any

                                                           PARSE                                                           PARSEone  of  several  parse types.  The syntax of this form of PARSE looks very

much like the SELECT verb.Programmable Command Language                                       Page 14


            COMMAND CMPLX;
            BEGIN
             ...;
            PARSE            PARSE            PARSE
                BEGIN                BEGIN                BEGIN
                NUMBER: BEGIN ... END;                NUMBER: BEGIN ... END;                NUMBER: BEGIN ... END;
                EOL   : BEGIN ... END                EOL   : BEGIN ... END                EOL   : BEGIN ... END
                END;                END;                END;
             ...
            END


This  would  allow  the user to enter either a number or a carriage return;

the corresponding statements (enclosed in BEGIN - END)  would  be  executed

depending  on  which  field  type matched the user's input.  In either case

more information would be available from variables like $VALUE.


4.1.3. Command Arguments4.1.3. Command Arguments4.1.3. Command Arguments

  The easiest way to specify the arguments is  to  use  command  arguments.

These  must be specified in the command declaration (the statement with the

keyword COMMAND and the name of the command).  The user specifies the  type

of  parameter  to be parsed and the variable to store the result into.  The

              ___variable must not be declared later;  the  use  in  the  command  arguments

completely declares the variable.


                              (NUMBER:count)                              (NUMBER:count)            COMMAND AllAtOnce (NUMBER:count);
            BEGIN
            !No INTEGER declaration necessary
            DISPLAY $STRING(count)
            END



4.2. Parse Options4.2. Parse Options4.2. Parse Options

  In  each  of  these  3 methods, the user may specify options to the parse

type.  Parse options are enclosed  in  parentheses  immediately  after  the

parse  type.    There are many options that the user can specify, e.g., theProgrammable Command Language                                       Page 15


default value to use if the user skips this parameter, or a help message to

type  if  the  user  enters  a  question  mark at the parameter.  The parse

options available vary with the parse type.


            COMMAND optn
            BEGIN
            ...;
            PARSE NUMBER(Help "Value of count",Default "2");
            ...
            END


If the user DECLARES this command and then types:  


           optn ?


at the "@" prompt, the system will respond:  


           Value of count


as it would in any EXEC command.  If the user skips the field by typing:  


           optn<return>


at the "@" prompt or if the user uses ESCAPE to complete the  command  then

the PARSE will return the default value, in this case 2.



4.3. FILELIST4.3. FILELIST4.3. FILELIST

  One  powerful extension to the parse system is the FILELIST.  This allows

the user to parse for file names which may contain wild cards, be separated

by commas, or both.    The  name  of  the  first  file  which  matches  the

specification  that  the  user  entered  is  returned  in  the usual system

variables ($FileL, $FileN, etc.) and successive file names may be  returned

             $NEXTFILE             $NEXTFILEby using the $NEXTFILE system service procedure.Programmable Command Language                                       Page 16


            COMMAND allfiles;
            BEGIN
             ...;
                  FILELIST                  FILELIST            PARSE FILELIST;
             ...;
               $NEXTFILE               $NEXTFILE            IF $NEXTFILE = 0 THEN EXIT;
             ...
            END


The user may type:  


           allfiles ABC.*,XYZ%Y.*,A.Z


The  first  file  that matches the specification of ABC.* will be returned.

                 $NEXTFILE                 $NEXTFILEFor each call to $NEXTFILE the system will return file names that match the

                                _____wild cards until all that match ABC.* have been exhausted .  Next, it  will

                            _______look  for  files that match XYZ%Y.*.  Finally, it will return the file name

___A.Z.



      FILELIST      FILELIST  The FILELIST may only be specified once per command and it may only be in

a simple parse.



4.4. Parse error handling4.4. Parse error handling4.4. Parse error handling

  Errors found during parsing are handled differently  depending  on  which

                                  _______ _________type  of  parse was executed.  In command arguments, the user can specify a

                                ERROR                                ERRORlabel to branch to by using the ERROR parse option.  This is only available

for command arguments.  The command will begin execution at that  label  if

the  user  entered  something  which  was not legal for the specified parse

type.Programmable Command Language                                       Page 17


                                 ERROR notnum                                 ERROR notnum            COMMAND oops (NUMBER(ERROR notnum) : count);
             ...;
            notnum:            notnum:            notnum:
             ...



      ______  _______  In  simple  parsing,  the  command  is  terminated and the standard error

                                                                    _______message for that parse type is displayed  at  the  terminal.    In  complex

                              OTHERWISE_______                       OTHERWISEparsing, the user may have an OTHERWISE parse option which will be executed

if the parse fails.


            COMMAND CMPLX;
            BEGIN
             ...
            PARSE
                BEGIN
                NUMBER:    BEGIN ... END;
                EOL:       BEGIN ... END;
                OTHERWISE                OTHERWISE                OTHERWISE: BEGIN
                           Display "Error in parameter";
                           Exit
                           END
                END;
             ...
            ENDProgrammable Command Language                                       Page 18


                                 CHAPTER 5                                 CHAPTER 5                                 CHAPTER 5

                       PROGRAM AND COMMAND INTERFACE                       PROGRAM AND COMMAND INTERFACE                       PROGRAM AND COMMAND INTERFACE



5.1. Running Programs5.1. Running Programs5.1. Running Programs

       INVOKE       INVOKE                                                   ___  The  INVOKE  PCL  statement runs a program much like the EXEC run command

does now.  The PCL command  continues  to  execute  when  the  program  has

started.  If the PCL routine exits, the program is left in a ^C state.  The

TYPEINTYPEINTYPEIN  PCL  statement "types" characters into the program.  TYPEIN takes a

string argument which contains the name of the program  to  run.    When  a

TYPEIN  is  executed, the PCL command will wait until the program goes into

terminal input wait.  It will then send the characters to the  program  and

                                            GETTYPEOUT                                            GETTYPEOUTcontinue  to  execute  PCL statements.  The GETTYPEOUT statement is used to

return the data that the program would have typed on the terminal,  placing

                                                    GETTYPEOUT                                                    GETTYPEOUTit  in  the  string  that  the  user specifies; the GETTYPEOUT will get all

                     INVOKE                   GETTYPEOUT         PASSOUTPUT                     INVOKE                   GETTYPEOUT         PASSOUTPUTcharacters since the INVOKE or since the last GETTYPEOUT.   The  PASSOUTPUT

                INVOKE                INVOKEoption  to  the INVOKE statement causes all of the data from the program to

                                     CLEARTYPEOUT                                     CLEARTYPEOUTgo to the controlling terminal.  The CLEARTYPEOUT command will  throw  away

all  the  program type out that has accumulated.  This may be used in place

     GETTYPEOUT     GETTYPEOUTof a GETTYPEOUT to get rid of unwanted startup messages from programs.


            COMMAND prog;
            BEGIN
             STRING prog_data;
              ...;
             INVOKE             INVOKE             INVOKE "payrol.exe";
             CLEARTYPEOUT             CLEARTYPEOUT             CLEARTYPEOUT;
             TYPEIN             TYPEIN             TYPEIN "update";
             GETTYPEOUT             GETTYPEOUT             GETTYPEOUT prog_data;
             DISPLAY prog_data;
              ...
            ENDProgrammable Command Language                                       Page 19


5.2. Executing EXEC Commands5.2. Executing EXEC Commands5.2. Executing EXEC Commands

      DOCOMMAND      DOCOMMAND  The DOCOMMAND PCL statement takes a string argument and performs the EXEC

command that is in the string.


            COMMAND whome;
            DOCOMMAND            DOCOMMAND            DOCOMMAND "systat " + $UserName


             _____After typing whome at the "@" prompt the user would see:


             Job  Line Program  User
              30*   44  SYSTAT  JS5A


at  the terminal.  The output from the command is displayed on the terminal

                    TO                    TOunless the optional TO parameter is specified.  In this case the  type  out

from the command is placed in the string.  


    DOCOMMAND              TO    DOCOMMAND              TO    DOCOMMAND "systat all" TO exec_string


To execute a command and ignore the output, do 


    DOCOMMAND         TO $NUL    DOCOMMAND         TO $NUL    DOCOMMAND command TO $NULProgrammable Command Language                                       Page 20


                                 CHAPTER 6                                 CHAPTER 6                                 CHAPTER 6

                               INPUT/OUTPUT                               INPUT/OUTPUT                               INPUT/OUTPUT

  PCL  provides simple file manipulation facilities.  Up to 36 files may be

open in input, output, or append mode.  Only record level reads and  writes

are  possible;  a record is terminated by a carriage return/line feed pair.

    $OPEN    $OPENThe $OPEN system service takes the name of the file and whether it is to be

                                            $OPEN                                            $OPENopened for input, output, or append access; $OPEN returns the  PCL  channel

number to be associated with the file.


                      $OPEN            $INPUT                      $OPEN            $INPUT            channel = $OPEN("mail.txt",$INPUT)


     $READ     $READThe  $READ  service  is a string procedure which takes a channel number and

                                      $WRITE                                      $WRITEreturns the next record in the file.  $WRITE takes a channel number  and  a

string and writes the string to the file.


                        $READ                        $READ            In_record = $READ(channel);
                 $WRITE                 $WRITE            Call $WRITE(channel,in_record);



                                                     $EOF                                                     $EOF  The  user  may test for end of file by calling the $EOF system procedure.

     $READ                               $EOF                          $EOF     $READ                               $EOF                          $EOFIf a $READ reaches the end of file, then $EOF will return non-zero.    $EOF

takes the channel number of the file as an argument.



                                     $CLOSE        $CLOSE                                     $CLOSE        $CLOSE  Files  may  be  closed  with  the  $CLOSE call.  $CLOSE takes the channel

number of the file to close.  It may not be necessary to close  files  open

for  input,  as  they  will  be  closed automatically at the end of the PCL

command.Programmable Command Language                                       Page 21


                                 CHAPTER 7                                 CHAPTER 7                                 CHAPTER 7

                                 REFERENCE                                 REFERENCE                                 REFERENCEProgrammable Command Language                                       Page 22


                                EXPRESSIONS                                EXPRESSIONS                                EXPRESSIONS



7.1. Expressions7.1. Expressions7.1. Expressions

  Expressions  are the fundamental arithmetic, string, and logical entities

of the PCL language.


7.1.1. Integer expressions7.1.1. Integer expressions7.1.1. Integer expressions

  Integer expressions are composed of integer constants, integer variables,

and integer procedure calls, operated on by arithmetic operators.  PCL  has

the   usual   operators  for  addition,  subtraction,  multiplication,  and

division, with  the  usual  precedence  rules,  and  allowing  the  use  of

parentheses to add to the default precedence.


            count*(shift+1) + offset(commandstring)


7.1.2. String expressions7.1.2. String expressions7.1.2. String expressions

  String  expressions  and  likewise  composed  of string variables, string

constants, and string procedure calls,  operated  on  by  operators.    The

string  operators  are  concatenation  (indicated  by  the  "+" symbol) and

substring extraction (indicated by square brackets).   Concatenation  takes

two  strings  and  generates  a new string from them.  Substring extraction

looks like 


    substring = str[start:count]


      _____                                                        _____where start is the location of the first character to extract, and count is

the number of characters to extract.  An asterisk can be used for the count

to extract to the end of the string.Programmable Command Language                                       Page 23


7.1.3. Logical expressions7.1.3. Logical expressions7.1.3. Logical expressions

  Logical  expressions  are  only  used  to control conditional statements;

there are no logical variables.  Logical  expressions  are  generated  from

typed  variables, constants, or procedure calls (either integer or string),

compared with relational operators:  "<", "<=", "=", "<>", ">=", and ">".Programmable Command Language                                       Page 24


                                STATEMENTS                                STATEMENTS                                STATEMENTS



7.2. Statements7.2. Statements7.2. Statements

  Statements  are  the  fundamental execution entities of the PCL language.

They may be grouped together to form a  compound  statement,  by  enclosing

them in a BEGIN/END pair, and separating them by semicolons.  Anywhere that

                                                   _________the  documentation  for  a  statement  says that a statement may be used, a

compound statement may be used just as well.  


            IF i EQL 0
            THEN
                BEGIN
                j=6;
                k=10
                END
            ELSE
                j=0Programmable Command Language                                       Page 25


                                   ABORT                                   ABORT                                   ABORT



7.3. Abort7.3. Abort7.3. Abort


________Function


       ABORT       ABORT  The  ABORT PCL statement will abort a PCL execution with an error message

typed to the user.



______Format


            ABORT            ABORT ______            ABORT string





_____Notes


          ______   1. The string error message will be typed on the terminal.


_______Example


            COMMAND ohdear;
            BEGIN
            ...;
            IF $LENGTH(input_line) > 120
            THEN
                ABORT                ABORT                ABORT "Line too long";
            ...
            END


_______Related


 EXIT - page 45
 RETURN - page 77Programmable Command Language                                       Page 26


                                ASSIGNMENT                                ASSIGNMENT                                ASSIGNMENT



7.4. Assignment7.4. Assignment7.4. Assignment


________Function


  The assignment statement generates a value and deposits it in a variable.



______Format


                  =    ________ ____ = __________    variable name = expression





_____Notes


   1. The  expression  must  be either integer or string, depending on
      the type of the variable.


_______Example


            COMMAND look;
            BEGIN
            ...;
            target_user = $Atom;
            ...
            END


_______Related


 Expressions - page 22Programmable Command Language                                       Page 27


                                   BEGIN                                   BEGIN                                   BEGIN



7.5. Begin7.5. Begin7.5. Begin


________Function


  BEGIN                        END  BEGIN                        END  BEGIN  is  paired  with  an  END to group several PCL statements into one

statement.



______Format


    BEGIN    BEGIN    BEGIN
     ___ _________     PCL statement; . . .
    END





_____Notes


            BEGIN                           END            BEGIN                           END   1. Every BEGIN must have a corresponding END.

   2. A BEGIN/END pair may  enclose  any  number  of  PCL  statements.
      Anywhere a PCL statement is called for, a BEGIN/END grouping may
      be substitued.

   3. It is not necessary to have a semi-colon following the final PCL
                              END                              END      statement  before  the  END.    If  present, a null statement is
      formed which will not affect the execution of the PCL command.


_______Example


    IF $JOBNO > 6
    THEN
        BEGIN        BEGIN        BEGIN
        Display "Job number greater than 6";
        A = 5;
        name = "Scott";
        ENDProgrammable Command Language                                       Page 28


_______Related


 ENDProgrammable Command Language                                       Page 29


                                   CALL                                   CALL                                   CALL



7.6. Call7.6. Call7.6. Call


________Function


      CALL      CALL  The CALL PCL statement will call a previously declared procedure.



______Format


    Format 1.
            CALL            CALL _________ ____            CALL procedure name
    Format 2.
            CALL            CALL _________ ____  ________ ________ ________            CALL procedure name (argument,argument,argument,...)





_____Notes


      CALL      CALL   1. CALL may call system procedures or user declared procedures.

   2. Arguments  are expressions, either integer or string as expected
      by the called procedure.    Those  arguments  which  are  to  be
      modified by the procedure must be simple variables.

   3. Parameters  are always passed by reference; all accesses made by
      the  called  procedure  are  actually  made  to   the   caller's
      variables.


_______Example


            COMMAND a_rtn;
             BEGIN
              EXTERNAL PROCEDURE match;
              ...;
              CALL              CALL              CALL match;
              ...
             ENDProgrammable Command Language                                       Page 30


_______Related


 EXTERNAL - page 47
 PROCEDURE - page 73Programmable Command Language                                       Page 31


                                   CASE                                   CASE                                   CASE



7.7. Case7.7. Case7.7. Case


________Function


       CASE       CASE  The  CASE  statement  provides  an orderly way of choosing one of several

paths to take based on the current value of an  integer  expression.    The

statement  tagged  with  the  current value is executed, and all others are

ignored.  


______Format


            CASE                    FROM            CASE _______ __________ FROM _______ ________            CASE integer expression FROM integer constant
                    TO                  OF                    TO _______ ________ OF                    TO integer constant OF
                BEGIN
                _______ ________   _________                integer constant : statement;
                _______ ________   _________                integer constant : statement;
                ...;
                INRANGE                INRANGE   _________                INRANGE : statement                 ! Optional
                OUTRANGE                OUTRANGE   _________                OUTRANGE : statement                ! Optional
                END





_____Notes


          FROM     TO          FROM     TO   1. The FROM and TO keywords precede integers  defining  the  lowest
      and  highest  permissible  value  of  the  expression.    If the
      expression is  outside  the  limits  and  an  OUTRANGE  tag  was
      specified,  the  statement  labelled  by  the  OUTRANGE  tag  is
      executed.  If the  expression  is  outside  the  limits  and  no
      OUTRANGE tag was specified, PCL issues an error.

          INRANGE          INRANGE   2. The INRANGE keyword indicates that the tagged statement is to be
                       _______ __________      executed  if the integer expression is within the range allowed,
                                                               _______      but is not explicitly provided for by any of the  other  integer
                          INRANGE      ________            INRANGE      constant tags.  The INRANGE tag must be the last in the list.

                                                   FROM-TO               _______  __________                 FROM-TO   3. If  the  integer  expression  is  within the FROM-TO limits, butProgrammable Command Language                                       Page 32


      there  is  no  statement tagged with that value, and there is no
      INRANGE      INRANGE      INRANGE tag, then nothing is done and execution  continues  with
                                  CASE                                  CASE      the statement following the CASE.


_______Example


    COMMAND casetest(NUMBER:theswitch);
    BEGIN
    CASE           FROM   TO   OF    CASE           FROM   TO   OF    CASE theswitch FROM 1 TO 4 OF
        BEGIN
        1:       DISPLAY "a 1 was entered";
        4:       DISPLAY "a 4 was entered";
        INRANGE        INRANGE        INRANGE: DISPLAY "something else in the range was entered"
        END
    END


_______Related


 Expressions - page 22
 SELECT - page 79Programmable Command Language                                       Page 33


                               CLEARTYPEOUT                               CLEARTYPEOUT                               CLEARTYPEOUT



7.8. ClearTypeOut7.8. ClearTypeOut7.8. ClearTypeOut


________Function


       CLEARTYPEOUT       CLEARTYPEOUT  The  CLEARTYPEOUT  PCL  statement  will  discard type out from an INVOKED

program.



______Format


            CLEARTYPEOUT            CLEARTYPEOUT            CLEARTYPEOUT





_____Notes


          CLEARTYPEOUT          CLEARTYPEOUT   1. The CLEARTYPEOUT PCL statement is  useful  for  getting  rid  of
      unwanted text from a program such as startup messages.

      CLEARTYPEOUT      CLEARTYPEOUT   2. CLEARTYPEOUT  is more efficient than doing a GETTYPEOUT and then
      not using the returned data.


_______Example


            COMMAND runprog (text (help "program to run):prog_to_run);
            BEGIN
            STRING program_text;
            ...;
            INVOKE prog_to_run;
            ...;
            CLEARTYPEOUT            CLEARTYPEOUT            CLEARTYPEOUT;
            ...;
            TYPEIN "week";
            ...
            ENDProgrammable Command Language                                       Page 34


_______Related


 GETTYPEOUT - page 49
 INVOKE - page 58
 KILLPROGRAM - page 60
 TYPEIN - page 83Programmable Command Language                                       Page 35


                                  COMMAND                                  COMMAND                                  COMMAND



7.9. Command7.9. Command7.9. Command


________Function


    COMMAND    COMMAND  A COMMAND definition in a PCL source file creates a command.



______Format


    Format 1.
            COMMAND            COMMAND ____    _______ _________            COMMAND name [ (command arguments) ] ;
            ___ _________            PCL statement
    Format 2.
            COMMAND            COMMAND ____    _______ _________            COMMAND name [ (command arguments) ] ;
            BEGIN
              ________ ____________            [ variable declarations; ]
            _________            statement;
            _________            statement;
            ...;
            _________            statement
            END

          _______ _________    where command arguments are
            _____ ____   _______     ________ ____            field type [(options)] : variable name;
            ...;
            _____ ____    _______    ________ ____            field type( [(options] : variable name

        ________ ____________    and variable declarations are
            ____ ____ ____ ____            type name,name,name,...;
            ...;
            ____ ____ ____ ____            type name,name,name,...;

            ____    and the types are INTEGER and STRING.





_____Notes


           COMMAND           COMMAND   1. The  COMMAND  keyword  must  be  the  first  word  in  a command
      definition.Programmable Command Language                                       Page 36


                                        ____   2. The   command   will  be  called  name.    It  may  contain  any
      alphanumeric characters, including the underscore which will  be
      converted to a hyphen when it is entered into the Exec's command
      table.

   3. The  use  of  command  arguments  allows  the  parameters to the
      command to be specified on the command  declaration  line.    In
      this  case the command may not do any Parse statements unless it
      uses subcommands. See PROMPT on page 75.


_______Example


            COMMAND            COMMAND            COMMAND newone;
            ...

            COMMAND            COMMAND            COMMAND more (NUMBER:job_val;TEXT:entry_type);
            ...


_______Related


 PROCEDURE - page 73
 Statements - page 24Programmable Command Language                                       Page 37


                                  DECLARE                                  DECLARE                                  DECLARE



7.10. Declare7.10. Declare7.10. Declare


________Function


  EXEC  command  to  merge  user written commands, procedures, or variables

into the EXEC.



______Format


    DECLARE    DECLARE    DECLARE (for PCL)
            /Confirm     ENVIRONMENT            /Confirm     ENVIRONMENT              _________            /Confirm     ENVIRONMENT (from files) FileName1, ...
            /NoConfirm   INTEGER-VARIABLE            /NoConfirm   INTEGER-VARIABLE         _______            /NoConfirm   INTEGER-VARIABLE (named) string1
                         PCL-ROUTINES                         PCL-ROUTINES               _________                         PCL-ROUTINES (from files) [FileName2, ...]
                         STRING-VARIABLE                         STRING-VARIABLE         _______                         STRING-VARIABLE (named) string2





_____Notes


          DECLARE          DECLARE   1. The DECLARE command will confirm its action with a message typed
      to the user's terminal.  The user may alter this  default  on  a
                             SET DEFAULT DECLARE                             SET DEFAULT DECLARE      permanent basis with a SET DEFAULT DECLARE command.  To override
                                                  Confirm    NoConfirm                                                  Confirm    NoConfirm      the  default,  the  user  may  specify  the Confirm or NoConfirm
      switches.

   2. When PCL routines are declared, the source  files  specified  by
           _________      the  FileName2  list are read, compiled into an internal format,
      and stored in the  EXEC.    The  source  file  may  contain  any
      combination  of  procedures, commands, and variable definitions.
                                     _________      If the user does not specify a FileName2 then the  source  input
      is  read  from  the terminal.  For procedures which will be used
      often,  the  EXEC  environment  should  be   saved   using   the
      ENVIRONMENT  switch  of  the SAVE command.  This environment may
                                DECLARE ENVIRONMENT                                DECLARE ENVIRONMENT      then be recalled with the DECLARE ENVIRONMENT command.  The user
      may declare a  command  with  the  same  name  as  a  predefined
      command.    If the user wishes to execute the predefined command
               ORIGINAL               ORIGINAL      then the ORIGINAL command should be used.

   3. The PCL environment is the entire  collection  of  user  definedProgrammable Command Language                                       Page 38


      objects,  which  must have unique names.  This includes commands
      and variables.  The user may save the  PCL  environment  at  any
      time  using  the  SAVE  command.    To  re-establish  a previous
      environment use the ENVIRONMENT option of the  DECLARE  command.
      The  default  file name is EXEC.ENV.  A list of files containing
      environments may be specified.   The  requested  environment  is
      merged  into  the  existing  environment  so  all  commands  and
      variables already declared will remain.

          INTEGER-VARIABLE     STRING-VARIABLE                 DECLARE          INTEGER-VARIABLE     STRING-VARIABLE                 DECLARE   4. The INTEGER-VARIABLE and STRING-VARIABLE options to the  DECLARE
      command   will  create  variables  in  the  EXEC  which  may  be
      referenced  by  user  written  commands  or  procedures.    This
      provides  a  mechanism  for  one command to pass data to another
      command  or  for  one  global  value  that  many  commands   may
      reference.   These variables may be assigned values by using the
      SET command if at the EXEC level or by the a  simple  assignment
      statement  if in a command.  The user may view the current value
                                                 INFORMATION  VARIABLE                                                 INFORMATION  VARIABLE      of these global variables  by  using  the  INFORMATION  VARIABLE
      command.


_______Example


             DECLARE PCL-ROUTINE             DECLARE PCL-ROUTINE            @DECLARE PCL-ROUTINE new-commands.pcl
            [Command GIGI defined]
            [Command GAPL defined]
            [Command GTYPE defined]
            [Command SAVE defined, old definition replaced]
            [Command GCOLOR defined]

             DECLARE STRING-VARIABLE             DECLARE STRING-VARIABLE _______            @DECLARE STRING-VARIABLE message


_______Related


 INFORMATION - page 56
 ORIGINAL - page 62
 SAVE - page 71
 SET - page 81Programmable Command Language                                       Page 39


                                  DISPLAY                                  DISPLAY                                  DISPLAY



7.11. Display7.11. Display7.11. Display


________Function


      DISPLAY      DISPLAY  The DISPLAY statement will type its argument on the terminal.



______Format


            DISPLAY  NORETURN   BINARY            DISPLAY  NORETURN   BINARY  __________            DISPLAY [NORETURN] [BINARY] expression





_____Notes


                    DISPLAY                    DISPLAY   1. By  default,  DISPLAY  will  type  out  the  string or number in
      ordinary character mode with a carriage return added.

               NORETURN               NORETURN   2. With the NORETURN option, it will  not  type  out  the  carriage
      return.

                 BINARY                 BINARY   3. With  the  BINARY  option, it will display without any character
      conversion.  This is useful for controlling display or  graphics
      terminals.


_______ExampleProgrammable Command Language                                       Page 40


            COMMAND showoff;
            BEGIN
            STRING status;
            INTEGER value;
            ...;
            DISPLAY            DISPLAY            DISPLAY "starting";
            ...;
            DISPLAY            DISPLAY            DISPLAY status;
            ...;
            DISPLAY            DISPLAY            DISPLAY value * 37;
            ...;
            DISPLAY BINARY            DISPLAY BINARY            DISPLAY BINARY "$H$J";
            ...
            ENDProgrammable Command Language                                       Page 41


                                    DO                                    DO                                    DO



7.12. Do7.12. Do7.12. Do


________Function


      DO      DO  The DO PCL statement provides loop control within PCL commands.



______Format


    DO               WHILE    DO ___ _________ WHILE _______ __________    DO PCL statement WHILE logical expression





_____Notes


      ___  _________   1. PCL  statement  may  be any legal PCL statement, either a single
      statement or a compound statement enclosed in a BEGIN/END pair.

                                                   _______  __________   2. The DO statement will loop as long  as  the  logical  expression
                                                                   ___      after  the  WHILE is true.  Presumably some statement in the PCL
      _________      statement will alter something  that  is  being  tested  in  the
                                           DO      _______  __________                  DO      logical  expression.   Otherwise the DO may loop forever.  There
      is no ENDLOOP or ESCAPE command.  The user may wish to GOTO  out
      of the loop but this is not recommended.

           ___  _________   3. The  PCL  statement  will always be executed at least once.  The
      _______ __________                                ___  _________      logical expression is not checked until after the PCL  statement
      has been executed.


_______ExampleProgrammable Command Language                                       Page 42


    COMMAND DoWhile;
    BEGIN
    INTEGER i;
    i = 5;
    DO    DO    DO
        BEGIN
        DISPLAY $String(i);
        i = i - 1
        END
    WHILE    WHILE    WHILE
        i = 0;
    EXIT
    END

    Execution:
            @DoWhile
            5
            4
            3
            2
            1


_______Related


 WHILE - page 85
 Expressions - page 22
 Statements - page 24Programmable Command Language                                       Page 43


                                 DOCOMMAND                                 DOCOMMAND                                 DOCOMMAND



7.13. DoCommand7.13. DoCommand7.13. DoCommand


________Function


      DOCOMMAND      DOCOMMAND  The DOCOMMAND PCL statement passes commands to the EXEC.



______Format


    Format 1.
            DOCOMMAND  ORIGINAL            DOCOMMAND  ORIGINAL  ______            DOCOMMAND [ORIGINAL] string
    Format 2.
            DOCOMMAND  ORIGINAL           TO            DOCOMMAND  ORIGINAL  ______ _ TO ______ _            DOCOMMAND [ORIGINAL] string_1 TO string_2





_____Notes


                              ORIGINAL            DOCOMMAND                              ORIGINAL            DOCOMMAND   1. The  optional  keyword  ORIGINAL causes the DOCOMMAND to execute
      the EXEC's original definition of a command and not  the  user's
      declared command.

   2. Format 1 will type the results of the command on the terminal.

                                                         ______ _   3. Format  2 will place the results of the command in string_2; the
      output will be formatted  as  if  the  Exec  were  typing  to  a
      terminal  with a width of zero, since this is most easily parsed
      by programs.

   4. A carriage return will  be  added  to  the  end  of  the  string
      containing the command.

   5. The DoCommand statement can be abbreviated DCM.


_______ExampleProgrammable Command Language                                       Page 44


            COMMAND bigeez;
            DOCOMMAND            DOCOMMAND            DOCOMMAND "vdir,
                            larger 100

                            "Programmable Command Language                                       Page 45


                                   EXIT                                   EXIT                                   EXIT



7.14. Exit7.14. Exit7.14. Exit


________Function


      EXIT      EXIT  The EXIT PCL statement will cause the PCL command to return to the EXEC.



______Format


    Format 1.
            EXIT            EXIT            EXIT
    Format 2.
            EXIT SAVE            EXIT SAVE            EXIT SAVE
    Format 3.
            EXIT TOPROGRAM            EXIT TOPROGRAM            EXIT TOPROGRAM





_____Notes


      EXIT      EXIT   1. EXIT  will  always go back to the EXEC even if executed within a
      procedure.

                                                                  EXIT                                                                  EXIT   2. If the PCL command executes to the END of the command,  an  EXIT
      will be simulated.

   3. It is permissable to have more than one exit in a PCL command or
      procedure.

   4. Formats 2 and 3 assume a program has been invoked.

   5. When a PCL command exits, any invoked programs are killed during
      the  cleanup.   The SAVE option will prevent the invoked program
      from being killed.

   6. Format 3 will exit the  PCL  command  and  then  do  a  CONTINUE
      command for the invoked program.Programmable Command Language                                       Page 46


_______Example


            COMMAND checkvalue;
            BEGIN
             INTEGER count;
             ...;
                               EXIT                               EXIT             IF count > 6 THEN EXIT;
             ...;
             EXIT             EXIT             EXIT
            END


_______Related


 ABORT - page 25
 RETURN - page 77
 INVOKE - page 58Programmable Command Language                                       Page 47


                                 EXTERNAL                                 EXTERNAL                                 EXTERNAL



7.15. External7.15. External7.15. External


________Function


       EXTERNAL       EXTERNAL  The  EXTERNAL  PCL  option  allows  commands  to  use  externally defined

procedures and global variables.



______Format


    Format 1.
            EXTERNAL            EXTERNAL ____ ____            EXTERNAL type name, ...
    Format 2.
            EXTERNAL PROCEDURE            EXTERNAL PROCEDURE ____            EXTERNAL PROCEDURE name, ...
    Format 3.
                     ____                     ____                     ____            EXTERNAL type PROCEDURE            EXTERNAL type PROCEDURE ____            EXTERNAL type PROCEDURE name, ...





_____Notes


   1. Format 1 allows a PCL command to reference a  variable  declared
      at the EXEC level with the DECLARE command.

   2. Formats  2 and 3 are necessary for any PCL command to be able to
      CALL PCL procedures.

                                                                  ____                                                                  ____                                                                  ____                                                                  TYPE                                                                  TYPE   3. Format 3 is used to declare external typed procedures.  The TYPE
      may be either STRING or INTEGER.


_______ExampleProgrammable Command Language                                       Page 48


            COMMAND outside;
            BEGIN
             EXTERNAL STRING             EXTERNAL STRING             EXTERNAL STRING message;
             EXTERNAL INTEGER             EXTERNAL INTEGER             EXTERNAL INTEGER job_number;
             EXTERNAL INTEGER PROCEDURE             EXTERNAL INTEGER PROCEDURE             EXTERNAL INTEGER PROCEDURE finger;
             ...
            END


_______Related


 CALL - page 29
 DECLARE - page 37
 PROCEDURE - page 73Programmable Command Language                                       Page 49


                                GETTYPEOUT                                GETTYPEOUT                                GETTYPEOUT



7.16. GetTypeOut7.16. GetTypeOut7.16. GetTypeOut


________Function


                       GETTYPEOUT                       GETTYPEOUT  The  PCL  statement  GETTYPEOUT  will  place  the terminal output from an

invoked program into a string.



______Format


            GETTYPEOUT            GETTYPEOUT ______            GETTYPEOUT string





_____Notes


             GETTYPEOUT             GETTYPEOUT   1. When a GETTYPEOUT statement is  excuted,  PCL  will  gather  all
      terminal  output  from  the  invoked program since the INVOKE or
                     GETTYPEOUT                     GETTYPEOUT                   ______      since the last GETTYPEOUT and put it in the string.    When  the
                                                            GETTYPEOUT                                                            GETTYPEOUT      invoked  program  goes  into terminal input wait, the GETTYPEOUT
      will return with the type out in the string.

   2. A CLEARTYPEOUT PCL statement is  more  efficient  that  doing  a
      GETTYPEOUT      GETTYPEOUT      GETTYPEOUT and then not using the returned data.


_______Example


            COMMAND runprog (text (help "program to run):prog_to_run);
            BEGIN
            STRING program_text;
            ...;
            INVOKE prog_to_run;
            ...;
            GETTYPEOUT            GETTYPEOUT            GETTYPEOUT program_text;
            ...
            ENDProgrammable Command Language                                       Page 50


_______Related


 INVOKE - page 58
 TYPEIN - page 83
 CLEARTYPEOUT - page 33
 KILLPROGRAM - page 60Programmable Command Language                                       Page 51


                                   GOTO                                   GOTO                                   GOTO



7.17. GoTo7.17. GoTo7.17. GoTo


________Function


       GOTO       GOTO  The  GOTO  statement  alters  the  flow  of  execution of PCL.  It causes

execution to jump directly to a labeled  statement.    Its  use  should  be

minimized  because  of  the great possibility of confusion, but at times it

may be essential.



______Format


            GOTO            GOTO _____            GOTO label





_____Notes


      _____  The label must be defined somewhere in the command or procedure.Programmable Command Language                                       Page 52


                                   GUIDE                                   GUIDE                                   GUIDE



7.18. Guide7.18. Guide7.18. Guide


________Function


       GUIDE       GUIDE  The  GUIDE  statement can be used in conjunction with the PARSE statement

to provide a  pleasing  user  interface.    It  tells  the  system  that  a

particular guide word is to be displayed if the user requests it by hitting

the Escape key.



______Format


    GUIDE    GUIDE ______ ________    GUIDE string constant





_____Notes


           GUIDE           GUIDE   1. The  GUIDE  statement  has  the  same  restrictions as the PARSE
      statement:  It can not be used except where a  command  line  is
      being parsed.

          GUIDE          GUIDE   2. The GUIDE statement is actually a PARSE statement with the NOISE
      field-type.


_______Example


            COMMAND rewind;
            BEGIN
            STRING devname;
            GUIDE            GUIDE            GUIDE "device";
            PARSE DEVICE;
            ...
            ENDProgrammable Command Language                                       Page 53


_______Related


 PARSE - page 63Programmable Command Language                                       Page 54


                                    IF                                    IF                                    IF



7.19. If7.19. If7.19. If


________Function


      IF      IF  The IF statement provides for conditional execution of PCL statements.



______Format


    Format 1.
            IF            IF _______ __________            IF logical expression
            THEN            THEN            THEN
                ___ _________                PCL statement
    Format 2.
            IF            IF _______ __________            IF logical expression
            THEN            THEN            THEN
                ___ _________                PCL statement
            ELSE            ELSE            ELSE
                ___ _________                PCL statement





_____Notes


                                  _________        __________   1. Format  1  will execute the statement if the expression is true;
      if it is false execution will continue to the next statement.

                                      _________         __________   2. Format 2 will execute the first statement if the  expression  is
                                                 _________      true, otherwise it will execute the second statement.


_______ExampleProgrammable Command Language                                       Page 55


    COMMAND loop;
    BEGIN
    ...
    IF    IF    IF i GTR 10
    THEN    THEN    THEN
        ABORT "too much"
    ELSE    ELSE    ELSE
        CALL APPEND(str,i);
    ...
    END


_______Related


 Expressions - page 22
 Statements - page 24
 DO - page 41Programmable Command Language                                       Page 56


                                INFORMATION                                INFORMATION                                INFORMATION



7.20. Information7.20. Information7.20. Information


________Function




                          INFORMATION                          INFORMATION  New options to the EXEC INFORMATION command to give information about the

current PCL environment.  


______Format


            INFORMATION         DEFAULTS       DECLARE            INFORMATION         DEFAULTS       DECLARE            INFORMATION (ABOUT) DEFAULTS (FOR) DECLARE

            INFORMATION         PCL-OBJECTS            INFORMATION         PCL-OBJECTS            INFORMATION (ABOUT) PCL-OBJECTS

            INFORMATION         VARIABLE            INFORMATION         VARIABLE ____            INFORMATION (ABOUT) VARIABLE name





_____Notes


           DEFAULTS  DECLARE           DEFAULTS  DECLARE   1. The  DEFAULTS  DECLARE option lists the defaults for the DECLARE
      command.  The defaults for the DECLARE command are  also  listed
         INFORMATION DEFAULTS ALL         INFORMATION DEFAULTS ALL      by INFORMATION DEFAULTS ALL.

           PCL-OBJECTS           PCL-OBJECTS   2. The  PCL-OBJECTS  option  lists  the  names of all the commands,
      procedures, and variables that are  currently  declared  in  the
      user's  EXEC.    This provides a way for the user to see exactly
      what commands have been  established  and  avoid  any  confusion
      about redefined commands.

           VARIABLE           VARIABLE   3. The  VARIABLE  option will display the current value of a string
                                                    DECLARE STRING                                                    DECLARE STRING      or integer variable which was declared by the DECLARE STRING  or
           DECLARE  INTEGER           DECLARE  INTEGER      the  DECLARE  INTEGER  commands.  It does not display values for
      variables declared inside commands or procedures.Programmable Command Language                                       Page 57


_______Example


                          PCL                          PCL     @INFORMATION (ABOUT) PCL
     Commands: DRP, REMIND, NETMAILCHECK, DIALUPLINE, COURIER
     Procedures: MATCH
     Variables: String MESSAGE
     @

     @set string message (TO) grades are due today
           var           var     @info var message
     grades are due today



_______Related


 DECLARE - page 37
 SET - page 81Programmable Command Language                                       Page 58


                                  INVOKE                                  INVOKE                                  INVOKE



7.21. Invoke7.21. Invoke7.21. Invoke


________Function


                       INVOKE                       INVOKE  The  PCL  statement  INVOKE will start a program running in a lower fork.

This provides the program with only a simple form of terminal  I/O;  it  is

possible  to make programs which expect more advanced terminal control than

PCL can provide.



______Format


    Format 1.
            INVOKE            INVOKE ______            INVOKE string
    Format 2.
            INVOKE PASSOUTPUT            INVOKE PASSOUTPUT ______            INVOKE PASSOUTPUT string





_____Notes


          INVOKE          INVOKE   1. The INVOKE should be used when the user wishes  to  control  the
      type in and type out of the invoked program.

   2. After PCL starts the program, it waits for the program to either
      halt or wait for terminal input.

   3. Data  may  be  sent  to  the  invoked  program  using the TYPEIN
      command.  Type out from the program may be  retrieved  with  the
      GETTYPEOUT command.

   4. Format  2  eliminates the need to do a GETTYPEOUT and a DISPLAY.
      All output from the program is sent directly to the terminal.

   5. The PASSOUTPUT option can be abbreviated PASO.Programmable Command Language                                       Page 59


_______Example


            COMMAND runprog (text (help "program to run):prog_to_run);
            BEGIN
            ...;
            INVOKE            INVOKE            INVOKE prog_to_run;
            ...
            END


_______Related


 GETTYPEOUT - page 49
 CLEARTYPEOUT - page 33
 TYPEIN - page 83
 KILLPROGRAM - page 60Programmable Command Language                                       Page 60


                                KILLPROGRAM                                KILLPROGRAM                                KILLPROGRAM



7.22. KillProgram7.22. KillProgram7.22. KillProgram


________Function


       KILLPROGRAM       KILLPROGRAM  The  KILLPROGRAM  PCL  statement  will  terminate an invoked program.  It

should only rarely be necessary.



______Format


            KILLPROGRAM            KILLPROGRAM            KILLPROGRAM





_____Notes


      KILLPROGRAM      KILLPROGRAM   1. KILLPROGRAM will ^C the invoked program and then do a  RESET  on
      the fork.


_______Example


            COMMAND runprog (text (help "program to run):prog_to_run);
            BEGIN
            STRING program_text;
            ...;
            INVOKE prog_to_run;
            ...;
            GETTYPEOUT program_text;
            ...;
            KILLPROGRAM            KILLPROGRAM            KILLPROGRAM;
            ...
            ENDProgrammable Command Language                                       Page 61


_______Related


 INVOKE - page 58
 GETTYPEOUT - page 49
 TYPEIN - page 83
 CLEARTYPEOUT - page 33Programmable Command Language                                       Page 62


                                 ORIGINAL                                 ORIGINAL                                 ORIGINAL



7.23. Original7.23. Original7.23. Original


________Function


            ORIGINAL            ORIGINAL  The  new  ORIGINAL  command allows users who have redefined standard Exec

commands to reference the original versions of those commands.



______Format


    ORIGINAL    ORIGINAL _______ ____    ORIGINAL command line





_______Example


            @DECLARE PCL-ROUTINES mine.pcl
            [Command FIND defined]
            [Command SYSTAT defined]
            @systat
               This is my own SYSTAT command, which doesn't work
             ORIGINAL             ORIGINAL            @ORIGINAL systat
             Fri 14-Aug-81 11:20:12  Up 125:17:04
             39+6 jobs   Load av   2.01   2.77   4.64
            ...Programmable Command Language                                       Page 63


                                   PARSE                                   PARSE                                   PARSE



7.24. Parse7.24. Parse7.24. Parse


________Function


      _____  The PARSE PCL statement is used to read command input parameters from the

terminal.  Specific types of parameters may be requested such as numbers or

input file specifications.



______Format


      Format 1.
        PARSE        PARSE _____ ____     _____ ______        PARSE field type [ ( field option; ... ) ]

      Format 2.
        PARSE        PARSE        PARSE
            BEGIN
            _____ ____   _____ ______           ___ _________            field type [(field option; ... ]) : PCL statement;
            _____ ____   _____ ______           ___ _________            field type [(field option; ... )] : PCL statement;
            . . .
            END





7.24.1. Field types7.24.1. Field types7.24.1. Field types

              field types              field types  The  parse  field types are a subset of the COMND JSYS function codes for

the expected field to be parsed.  For a complete description of the actions

of these fields, see their corresponding description in the TOPS-20 MONITOR

                     _____ _____CALLS manual.  Legal field types are:


INPUTFILE       allows the user to specify  a  file  that  already  exists.
                This  field  type  does  not  allow  any fields of the file
                specification to be defaulted. (See FILE and FILELIST field
                types.)Programmable Command Language                                       Page 64


KEYWORD         allows  a  list  of keywords to be specified.  The user may
                select one of the keywords  in  the  list.    The  list  is
                defined by using the WORDS field option (See below).


      ______NOISE string    is  mostly  used  for  command arguements.  This field type
                               ______                will cause the string to be typed out in parentheses if the
                user types an escape.  It may be useful in a Parse  if  you
                want  to  know whether the noise word was actually typed in
                or not.


NUMBER          parses an integer input field.    The  RADIX  field  option
                allows for numbers in some radix other than 10.


OUTPUTFILE      causes  the  system  to parse for a file name that does not
                exist.  This field type does not allow any  fields  of  the
                file  specification to be defaulted.  Wild cards may not be
                specified.  (See FILE and FILELIST field types.)


SWITCH          is similar to KEYWORD except that a list of switches  (i.e.
                KEYWORDS  preceded  by  a  slash)  is  parsed.  The list is
                defined by using the WORDS field option (See below)


FILE            is more general than INPUTFILE and OUTPUTFILE.  This  field
                type  has  many  more  options  available.  Defaults may be
                specified for any of the file specification  fields.    The
                user may specify that the field is to be "parse only" which
                                                                      field                                                                      field                merely  checks  for a valid file specification.  (See field
                options                options                options DEFAULT_DEV, DEFAULT_DIR, DEFAULT_EXT, DEFAULT_GEN,
                DEFAULT_NAM, INPUT, OUTPUT, and WILD.)  It is not  possible
                to  have  more  than  one  FILE  field  in  a  single Parse
                statement.


FIELD           parses   an   arbitrary   parameter    delimited    by    a
                nonalphanumeric  character.    No  standard help message is
                available.  (See the HELP field option.)


EOL             parses a carriage return.  If  the  user  is  doing  simple
                parses then the command will continue to execute after each
                                PARSE EOL                                PARSE EOL                parse.   Once a PARSE EOL has been executed the PCL command
                                       PARSE                    PROMPT                                       PARSE                    PROMPT                cannot  do  any  more  PARSE  statements;  see  PROMPT  PCL
                statement  on  page  75.    It  is not necessary, nor is it
                permitted, to specify a EOL when using command arguments.


DIRECTORY       parses a directory name; this includes the angle brackets.Programmable Command Language                                       Page 65


USERNAME        parses a username.


COMMA           parses  a  comma.   Spaces may appear on either side of the
                comma.


DEVICE          parses a device name.


TEXT            parses all the input up to the carriage return.


DAYTIME         inputs a date and time field.  The format  is  any  general
                date/time  format.    Both  date  and  time must be entered
                           date    time                           date    time                unless the date or time parse options are specified.


QUOTEDSTRING    parses a field contained in double quotes.   The  field  is
                returned in $ATOM without the quotes.


      ______                                        ______TOKEN string    parses a field that exactly matches string.


NODE            parses  a  network  node  name.   This must be an available
                node, unless the PARSEONLY option is specified.


FILELIST        allows the user to enter  a  list  of  files  separated  by
                commas,  a  file with wild cards designators, or both.  The
                $NEXTFILE system procedure allows the PCL command  to  loop
                through  the  files that match the wild cards or are in the
                list.


OTHERWISE       is a special field-type which is  meaningful  only  in  the
                complex  Parse.  If specified, it must be the last field in
                the Parse statement.  The Otherwise case will be  taken  if
                the  input  available  matches  none  of  the  field  types
                provided.  The Otherwise field type does not consume any of
                the input; it only indicates that it was not recognizable.Programmable Command Language                                       Page 66


7.24.2. Field options7.24.2. Field options7.24.2. Field options

                                    field options                                    field options  The  above  field  types may have field options.  These options modify or

extend the parse type of the field.  These are also closely related to  the

COMND JSYS.


        ______DEFAULT string  Provides  a  default  for the entire field if the user hits
                Escape or Return.


     ______HELP string     If the user enters a  ?  at  the  field  prompt,  the  help
                           ______                message in string is displayed.


PARSEONLY       For  file parses, allows the command to parse for a validly
                formatted file specification  without  requiring  that  the
                file  actually exist.  For Node parses, allows the node not
                to exist; similarly for Device, Directory, and User.


NOHELP          Turns on  the  CM%SDH  bit  in  the  COMND  JSYS.  This  is
                unnecessary if HELP is used.


STDHELP         Turns  off  the CM%SDH bit.  The standard help message will
                be used.


NOINDIRECT      Specifies that an indirect command file may not be used  at
                this field.  Turns on bit CM%XIF in the COMND JSYS.


INPUT           For  field  types FILE and FILELIST, parses for an existing
                file. Turns on COMND JSYS bit GJ%OLD.


OUTPUT          For field types FILE and FILELIST, parses for a  new  file.
                Turns on COMND JSYS bit GJ%FOU.


INVISIBLE       For  field types FILE and FILELIST, parses for an invisible
                file.  Turns on COMND JSYS bit G1%IIN.


DELETED         For field types FILE and FILELIST,  parses  for  a  deleted
                file.  Turns on COMND JSYS bit GJ%DEL.


WILD            For  FILE  field  type,  allows  the user to specify a wildProgrammable Command Language                                       Page 67


                card.    This  is  useful  if  only  one  file  matches the
                specification.   See  FILELIST  field  option  for  a  more
                general file wild card parsing method.


            ______DEFAULT_DEV string


            ______DEFAULT_DIR string


            ______DEFAULT_NAM string


            ______DEFAULT_EXT string


            ____DEFAULT_GEN code
                For   FILE   and   FILELIST,  specifies  defaults  for  the
                                                                _____                individual fields of a file specification.  The codes are 0
                (highest  generation),  +  (next  generation),   -   (first
                generation), * (all generations), or a generation number.


      _______ ________RADIX Integer constant
                For  field  type NUMBER, specifies that the number typed in
                            _______ ________                is in radix integer constant.


       ____ _ _______ _ ____ _ _______ _WORDS (word_1:integer_1,word_2:integer_2, ...  )
                For field types KEYWORD and SWITCH, the words specified  by
                ____ _                              _______ _                word_n  are  the legal values.  The integer_n) is stored in
                $VALUE and the actual word typed in $ATOM.  The  words  are
                alphanumeric strings.


       ____ _  _______ _ ____ _  _______ _WORDS (word_1::integer_1,word_2::integer_2, ... )
                For  field  type  SWITCH  only,  allows parsing values of a
                                                                 /       :                                                                 /____ _ :                switch.  This will parse a field  of  the  form  /word_n):.
                Once  this  is  parsed,  the  PCL  can  issue another PARSE
                statement to get the value of the switch.  This  cannot  be
                used with command arguments.


TIME            Parse only the time for field type DAYTIME.


DATE            Parse only the date for field type DAYTIME.


      _____                                                _____ERROR Label     for  command  arguements  only,  branch to label on a parse
                error.Programmable Command Language                                       Page 68





_____Notes


                                      _______ ________   1. The  values  for  NUMBER,  the  integer-constant in a KEYWORD or
      SWITCH, and the internal date and time for DAYTIME are  returned
         $VALUE         $VALUE      in $VALUE.

   2. The  value  for  file  parses  is  returned  in system variables
      $FILEN, $FILEL, and $FILES.

   3. The  text  typed  in  for  for  NUMBER,  FIELD,  DEVICE,   TEXT,
      QUOTEDSTRING,  DIRECTORY, USERNAME, KEYWORD, SWITCH, and NODE is
      returned in $ATOM.

   4. If the user specifies a HELP field  option,  then  the  standard
      help  message  is  not used.  Specifying both a HELP field and a
      STDHLP field will cause PCL to use both the user message and the
      standard message.

      PARSE      PARSE   5. PARSE takes  care  of  re-parsing  and  redisplay  if  the  user
      corrects  the  command  line.    The  PCL author should code the
      command as though the user will never make a mistake  or  change
      what was typed in.

                                               PARSE                                               PARSE   6. Once  an  EOL  has  been parsed, no more PARSE statements may be
      executed without first doing a PROMPT statement to  reinitialize
      the  parsing system.  Reparsing will occur only back to the last
      executed prompt statement.

   7. A DoCommand statement generates an implicit Parse EOL statement,
      to require that commands first parse their parameters  and  then
      perform their actions.

   8. A single Parse statement may have only one FILE field type; this
      is a restriction in the COMND JSYS.


_______ExampleProgrammable Command Language                                       Page 69


            COMMAND getinfo;
            BEGIN
            STRING type_in;
            PARSE            PARSE            PARSE text;
            type_in = $ATOM;
            DISPLAY "You entered>> " + type_in;
            PARSE            PARSE            PARSE EOL;
            ...
            END

            COMMAND choice;
            BEGIN
            STRING a_user; INTEGER the_job;
            PARSE            PARSE            PARSE
                BEGIN
                username: BEGIN
                          a_user = $ATOM;
                          DOCOMMAND "systat  " + a_user
                          END;
                number:   BEGIN
                          the_job = $VALUE;
                          DOCOMMAND "systat " + $string(the_job)
                          END
                END;
            ...
            END


                                 choice                                 choice  To the user, the above command choice would look like:


            @decl p choice
            [Command CHOICE defined]
            @
            @choice ? user name
              or decimal number
            @choice te04
              14    42  EMACS   TE04
            @choice 10
              10    13  OPR     IO00
            @


The following command defines a keyword to be parsed.


            COMMAND keywd;
            BEGIN
             ...;
             PARSE KEYWORD             PARSE KEYWORD             PARSE KEYWORD (WORDS(day:1,week:2,year:3));
             ...
            ENDProgrammable Command Language                                       Page 70


                 keywd                 keywdTo the user, the keywd command would look like:


            @keywd ? one of the following:
             DAY    WEEK    YEAR
            @keywd day


_______Related


 PROMPT - page 75Programmable Command Language                                       Page 71


                                 PRESERVE                                 PRESERVE                                 PRESERVE



7.25. Preserve7.25. Preserve7.25. Preserve


________Function


       PRESERVE       PRESERVE  The  PRESERVE command allows the user to save the current PCL environment

for later recall.  It allows system administrators to modify the Exec  with

PCL and then save the entire Exec for use at his or her site.



______Format


    Format 1.
            PRESERVE ENVIRONMENT            PRESERVE ENVIRONMENT ____ ____            PRESERVE ENVIRONMENT file name
    Format 2.
            PRESERVE EXEC            PRESERVE EXEC ____ ____            PRESERVE EXEC file name





_____Notes


           ENVIRONMENT           ENVIRONMENT   1. An   ENVIRONMENT  is  all  the  PCL  commands,  procedures,  and
      variables that the user has defined.

          ENVIRONMENT          ENVIRONMENT   2. The ENVIRONMENT file contains the internal, compiled version  of
      the PCL objects.  It will not be recompiled when declared.

   3. The default file name for environments is EXEC.ENV.

   4. Format 2 is for system administrators.  The EXEC that is written
      may  be  placed  on  <SYSTEM>  for use by the installation.  All
      commands that have been defined may not be  un-declared  by  the
      users.

                                PRESERVE EXEC                                PRESERVE EXEC   5. The default file name for PRESERVE EXEC is EXEC.EXE.Programmable Command Language                                       Page 72


_______Example


            PRESERVE ENVIRONMENT            PRESERVE ENVIRONMENT            PRESERVE ENVIRONMENT payroll.env

            PRESERVE EXEC            PRESERVE EXEC            PRESERVE EXEC exec.exe


_______Related


 DECLARE - page 37
 UNDECLAREProgrammable Command Language                                       Page 73


                                 PROCEDURE                                 PROCEDURE                                 PROCEDURE



7.26. Procedure7.26. Procedure7.26. Procedure


________Function


     PROCEDURE     PROCEDURE  A  PROCEDURE  definition  in  a PCL source file creates a procedure.  All

procedures are declared globally and on the "top level;" there are no inner

procedures.



______Format


    Format 1.
        PROCEDURE        PROCEDURE ____ ________ ____        PROCEDURE name argument-list
    Format 2.
             PROCEDURE        ____ PROCEDURE ____ ________ ____        type PROCEDURE name argument-list;

             ________ ____    where an argument-list is either omitted or
         ____ ____  ____       ____ ____  ____        (type name, name, ...; type name, name, ...; ...)





_____Notes


        PROCEDURE        PROCEDURE   1. A PROCEDURE need not have arguments; if it  has  none  then  the
      parentheses are not necessary.

        PROCEDURE                 INTEGER            STRING        PROCEDURE                 INTEGER            STRING   2. A PROCEDURE may have either INTEGER arguments, STRING arguments,
      or both.

                                            ____   3. Format  2  is a typed procedure.  The type may be either INTEGER
      or STRING.  See the RETURN statement on page 77.

   4. Specifying the names of the  parameters  in  the  argument  list
      defines  them  for all purposes; they need not be declared again
      within the body of the procedure.

   5. A typed procedure may be used in place  of  a  variable  in  PCL
      statements.Programmable Command Language                                       Page 74


_______Example


            PROCEDURE        string            PROCEDURE        string _____ ______ ___ _____            PROCEDURE match (string input_string,str_match;
                                integer                                integer _____ _____                                integer start_point);
            BEGIN
            ...;
            RETURN
            END


                                              finger                                              finger  If  a  user has an integer procedure called finger that looks at a SYSTAT

and returns the job number of the requested user, that procedure  could  be

used:


            findem            findem    COMMAND findem (username:guy);
            BEGIN
                                        finger                                        finger             EXTERNAL INTEGER PROCEDURE finger;
             IF finger(guy) neq -1 THEN
                                                finger                                                finger              DISPLAY guy + " is at " + $string(finger(guy))
             ELSE
              DISPLAY guy + "not on";
             EXIT
            END


              finger              fingerThe procedure finger would look like:


                    PROCEDURE                    PROCEDURE            INTEGER PROCEDURE FINGER (STRING name);
            BEGIN
             STRING gotem;
             DOCOMMAND "systat " + name TO gotem;
            IF $length(gotem) = 0 THEN return -1
            ELSE return $integer(gotem[3:2])
            END


_______Related


 CALL - page 29
 RETURN - page 77Programmable Command Language                                       Page 75


                                  PROMPT                                  PROMPT                                  PROMPT



7.27. Prompt7.27. Prompt7.27. Prompt


________Function


  When  using  PARSE  to parse parameters, it only permits you to parse one

command line; once the line has been completely parsed, with PARSE EOL, you

can not use PARSE again, without causing PCL to obtain and begin parsing  a

                            PROMPT                            PROMPTnew  command  line.    The  PROMPT  PCL statement allows the PCL command to

prompt for more input parameters after a PARSE EOL has been executed.



______Format


            PROMPT  NOECHO            PROMPT  NOECHO  ______ ________            PROMPT [NOECHO] string constant





_____Notes


           PROMPT           PROMPT   1. The  PROMPT  statement  effectively  allows  the  user  to  have
      subcommands to commands.

   2. The  NOECHO  option  turns  off  echoing for that entire line of
      command typein; this must be done at the Prompt because  of  the
      way command typein and echoing is done.

   3. In  command parsing, it is permissible for the user to type in a
      field and have it recognized by PCL  and  then  to  type  enough
      rubouts  or  ^W's  to  make the entire field invalid, or even an
      earlier, already parsed field.  When this  happens,  the  system
      signals  to  the  Exec  that  a "reparse" occurred, and that the
      system will now reset its internal pointer to the  beginning  of
      the command line and start again.  When a reparse happens during
      basic  command  line  parsing,  PCL aborts the executing command
      completely and restarts the command program from the  beginning.
      During subcommand parsing, this is undesirable.  Instead, when a
      reparse occurs during subcommand parsing (properly identified asProgrammable Command Language                                       Page 76


                PROMPT                PROMPT      such by a PROMPT statement), PCL jumps back to the last-executed
      Prompt  statement  as  if  a GoTo had been performed and resumes
      execution of the PCL program from that point.   Then,  when  the
      user's  Parse  statements re-execute, they will match the fields
      which the system will re-present to the program.


_______Example


            COMMAND subcomm;
             BEGIN INTEGER a_value;
             PARSE NUMBER;
             a_value = $VALUE
             ...;
             PARSE EOL;
             ...;
             PROMPT             PROMPT             PROMPT "@@";
             PARSE KEYWORD (Words (first:1,last:2,all:3));
             ...;
             PARSE EOL;
             PROMPT NOECHO             PROMPT NOECHO             PROMPT NOECHO "Please enter your password: "
             PARSE TEXT;
             ...
             END


_______Related


 PARSE - page 63Programmable Command Language                                       Page 77


                                  RETURN                                  RETURN                                  RETURN



7.28. Return7.28. Return7.28. Return


________Function


       RETURN       RETURN  The  RETURN  PCL  statement  causes  a procedure to return to the calling

routine.



______Format


    Format 1.
            RETURN            RETURN            RETURN
    Format 2.
            RETURN            RETURN __________            RETURN expression





_____Notes


        RETURN        RETURN   1. A RETURN always returns  to  the  calling  routine.    If  in  a
      command, the command returns to the EXEC.

   2. Format  2 is used to return the value for typed procedures.  See
      PROCEDURES      PROCEDURES      PROCEDURES on page 73.


_______ExampleProgrammable Command Language                                       Page 78


            PROCEDURE show;
             BEGIN
              display $jobno + " " + $username;
              RETURN              RETURN              RETURN
             END

            INTEGER PROCEDURE calc;
            BEGIN
             INTEGER total;
             ...;
             RETURN             RETURN             RETURN total + 5
            END


_______Related


 ABORT - page 25
 PROCEDURE - page 73Programmable Command Language                                       Page 79


                                  SELECT                                  SELECT                                  SELECT



7.29. Select7.29. Select7.29. Select


________Function


       SELECT       SELECT  The  SELECT  statement provides an orderly way of choosing one of several

paths to  take  based  on  the  current  value  of  an  integer  or  string

expression.  The statement tagged with the expression having the same value

is executed, and all others are ignored.  


______Format


            SELECT            OF            SELECT __________ OF            SELECT expression OF
                BEGIN
                __________   _________                expression : statement;
                __________   _________                expression : statement;
                ...;
                OTHERWISE                OTHERWISE    _________    optional:   OTHERWISE :  statement
                __________   _________    otherwise:  expression : statement
                END





_____Notes


                            __________   1. The type of the first expression must match the types of all the
      tagging expressions; they must be all integer expressions or all
      string expressions.

   2. Unlike  the  CASE statement, the tags may be complex expressions
                                                           __________      instead of constants.  After evaluating the  select  expression,
                                        __________      PCL  will  evaluate  each tagging expression in turn and compare
                                           __________      the value to the value of the select expression.   If  they  are
      equal, the corresponding statement will be executed.

           OTHERWISE           OTHERWISE   3. The  OTHERWISE keyword indicates that the tagged statement is to
      be executed if all the preceding tests fail.

                                             OTHERWISE                                             OTHERWISE   4. If all the tests fail, and there is no OTHERWISE, then executionProgrammable Command Language                                       Page 80


                              SELECT                              SELECT      continues following the SELECT statement.

   5. The  intent of providing SELECT in addition to CASE is that CASE
      is implemented with a table of statement  addresses,  making  it
      appropriate  for  small  ranges of the selection expression, say
      from 1 to 10, whereas SELECT is implemented by a series of tests
      which might as well have been coded by user statements like


                  IF x=1 THEN s1 ELSE IF x=58 THEN s2
                      ELSE IF x=101 THEN s3 ELSE ...


      suitable for a large range in the selection range.


    COMMAND seltest(USERNAME:unam);
    ...
    SELECT      OF    SELECT      OF    SELECT unam OF
        BEGIN
        "OPERATOR":    display "the operator";
        "DIAGNOSTICS": display "the engineers"
        END
    END


_______Related


 Expressions - page 22
 CASE - page 31Programmable Command Language                                       Page 81


                                    SET                                    SET                                    SET



7.30. Set7.30. Set7.30. Set


________Function


                               SET                               SET  New  options  to  the  EXEC  SET  command  will  set the values of global

                          DECLARE                          DECLAREvariables declared by the DECLARE command.



______Format


                INTEGER-VARIABLE                INTEGER-VARIABLE         ________      _____            SET INTEGER-VARIABLE (named) variable (to) value

                STRING-VARIABLE                STRING-VARIABLE         ________      _____            SET STRING-VARIABLE (named) variable (to) value

                     COMMAND-TRACE                     COMMAND-TRACE            SET [NO] COMMAND-TRACE (OF GENERATED COMMANDS)

                        DECLARE /CONFIRM                        DECLARE /CONFIRM            SET DEFAULT DECLARE /CONFIRM
                                 /NOCONFIRM                                 /NOCONFIRM                                 /NOCONFIRM





_____Notes


                                                               DECLARE          ________                                             DECLARE   1. The variable must have been previously  declared  by  a  DECLARE
      command. See page 37.

           INFORMATION           INFORMATION   2. The  INFORMATION command may be used to display the setting of a
      global variable. See page 56.

              COMMAND-TRACE              COMMAND-TRACE   3. Setting COMMAND-TRACE causes PCL to display at the terminal  all
      DoCommand statements as they are executed.

                                 DECLARE                                 DECLARE   4. Setting  the  default  for DECLARE allows you to say whether the
      DECLARE command should, by default, confirm its actions.


_______ExampleProgrammable Command Language                                       Page 82


                 integer-variable                 integer-variable            @SET integer-variable doneflag 0

                 string                 string            @SET string host TOPS-A


_______Related


 INFORMATION - page 56
 DECLARE - page 37Programmable Command Language                                       Page 83


                                  TYPEIN                                  TYPEIN                                  TYPEIN



7.31. TypeIn7.31. TypeIn7.31. TypeIn


________Function


       TYPEIN       TYPEIN  The  TYPEIN  PCL  statement  will  send  a character string to an invoked

program.



______Format


            TYPEIN  NORETURN            TYPEIN  NORETURN  ______            TYPEIN [NORETURN] string





_____Notes


      TYPEIN      TYPEIN           ______   1. TYPEIN will send string to the invoked program as though it  had
      been  typed on the controlling terminal.  A carriage return will
                                     NORETURN                  ______             NORETURN      be added to string, unless the NORETURN option is specified.

                                                                TYPEIN                                                                TYPEIN   2. Several lines may be sent to the invoked program with one TYPEIN
      statement.  PCL will strip the extra line feeds from the  string
      before  sending  it,  because  programs  normally  expect  their
      terminal input to be terminated by carriage returns only.


                          TYPEIN                          TYPEIN                          TYPEIN "tape copytp:
                                      density 1600
                                      ssname area backup"


   3. After the string has been passed to the program, PCL waits until
      the program either halts or waits for more terminal input.


_______ExampleProgrammable Command Language                                       Page 84


            COMMAND runprog (text (help "program to run):prog_to_run);
            BEGIN
            STRING program_text;
            ...;
            INVOKE prog_to_run;
            ...;
            GETTYPEOUT program_text;
            ...;
            TYPEIN            TYPEIN            TYPEIN "weekly";
            ...
            END


_______Related


 INVOKE - page 58
 GETTYPEOUT - page 49
 CLEARTYPEOUT - page 33
 KILLPROGRAM - page 60Programmable Command Language                                       Page 85


                                   WHILE                                   WHILE                                   WHILE



7.32. While7.32. While7.32. While


________Function


      WHILE      WHILE  The WHILE PCL statement provides loop control for PCL routines.



______Format


            WHILE                    DO            WHILE _______ __________ DO ___ _________            WHILE logical expression DO PCL statement





_____Notes


                                             ___ _________   1. If  the condition is not true then the PCL statement will not be
      executed.


_______Related


 DO - page 41Programmable Command Language                                       Page 86


                             SYSTEM FACILITIES                             SYSTEM FACILITIES                             SYSTEM FACILITIES



7.33. System7.33. System7.33. System

  Various  system  services  and  variables are provided to return specific

system information or perform system functions.


7.33.1. System Variables7.33.1. System Variables7.33.1. System Variables

  These may be used like any other variables of the appropriate type; a few

may be written to, but most can only be read.


$Account        STRING - The account of the current job.


$Append         INTEGER - An option to $OPEN for append mode.


$ARPAnet_Node   STRING - The system's ARPAnet node name.  This  is  a  null
                string if the system is not on the ARPAnet.


$Atom           STRING  -  After a PARSE statement, contains the text typed
                in for most parse types (all but  Noise,  EOL,  Comma,  and
                Token.)


$Batch_Job      INTEGER - Non-zero if the job is a batch job.


$ConnectedDirectory
                STRING - The name of the currently connected directory.


$CR             STRING - A string containing just a carriage return.


$CRLF           STRING  -  A string containing a carriage return and a line
                feed.


$CURTAD         INTEGER - The current date  and  time  in  system  internal
                format.


$Date           STRING - Current date in DD-MON-YY format.Programmable Command Language                                       Page 87


$DECnet_Node    STRING  -  The  system's  DECnet node name.  This is a null
                string if the system is not on a DECnet.


$EMACSTerminal  INTEGER - Returns a  1  if  the  current  terminal  can  be
                "effectively" used by EMACS, 0 if not.  [CMU only]


$FBCTL


$FBADR


$FBPRT


$FBCRE


$FBGEN


$FBBYV


$FBSIZ


$FBCRV


$FBWRT


$FBREF


$FBCNT


$FBBK0


$FBBBT


$FBNET


$FBUSWProgrammable Command Language                                       Page 88


$FBTDT


$FBFET


$FileControl


$FileAddress


$FileProtection


$FileCreation


$FileSize


$FileWrite


$FileRead       INTEGER   -   These  constants  are  provided  to  pass  to
                $FileInfo_I to extract information from  the  FDB.    Those
                which  look  like  MONSYM  symbols  are provided along with
                descriptive names.


$Author


$Writer


$FileAccount    STRING - These are similar code numbers for $FileInfo_S.


$FileL          STRING - After executing a PARSE FILE  statement,  or  some
                similar  PARSE,  this contains the file name entered in the
                longest form, DEV:<DIRECTORY>FILE.EXT.VERSION.


$FileN          STRING - In parsing, the file name entered  in  the  normal
                form, FILE.EXT.VERSION.


$FileS          STRING  -  In  parsing,  the  file name entered in the form
                FILE.EXT.  It will contain device: and <directory> if  they
                are different from the connected device and directory.Programmable Command Language                                       Page 89


$FileV          INTEGER - In parsing, contains just the generation number.


$Input          INTEGER - An option to $OPEN for input mode.


$JobNo          INTEGER - The number of the current job.


$LastErrCode    INTEGER - The number of the last JSYS error.


$LastError      STRING - The text of the last JSYS error.


$LF             STRING - A string containing a line feed.


$NUL            STRING  -  Read/write  string  like  NUL:,  returns  a null
                string.


$Output         INTEGER - An option to $OPEN for output mode.


$PromptEnb      STRING - The standard enabled prompt string.


$PromptEnbSub   STRING - The standard enabled subcommand prompt string.


$PromptReg      STRING - The standard prompt string, which can  be  written
                if the usual "@" is not suitable.


$PromptSub      STRING  -  The  standard  subcommand  prompt  string,  also
                writeable.


$Quote          STRING - A string containing a double quote character


$TermNumber     INTEGER - The number of the controlling terminal.


$TermWidth      INTEGER - The terminal width of the controlling terminal.


$Time           STRING - Current time in HH:MM:SS format.


$TType          INTEGER  -  The  terminal  type  index  (GTTYP%)   of   theProgrammable Command Language                                       Page 90


                controlling terminal.


$Typeahead_Count
                INTEGER  -  The number of characters which have been typed-
                ahead on the controlling terminal.


$UserName       STRING - The user name of the current job.


$Value          INTEGER - Contains a number returned by a Parse: The number
                typed in for a Number field, the value  for  a  Keyword  or
                Switch, or the internal date and time for a DayTime.


7.33.2. System Procedures7.33.2. System Procedures7.33.2. System Procedures

  These  predefined  procedures may be called without being declared.  Some

are typed, and some return results in their arguments.


        _______$Close (channel)
                                                _______                Closes the file that is open on channel.


        _______$CVITC (integer)
                STRING - Returns the character whose  value  is  equal  the
                integer.      This   is  useful  for  manipulating  control
                characters.


        ______$CVCTI (string) INTEGER - Converts the first character in the  string  into
                an  integer.  This  is  also  useful  for control character
                manipulation.


     _______$EOF(channel)   INTEGER - Returns a non-zero value if  the  last  $READ  on
                _______                channel reached the end of the file.


              ________   ____   ___  ____ ____ _____ ___  __  _____ ___  __$ExpandTAD   (internal   date   and  time,year,month,day  of  month,day  of
                ____ ____ ______                week,hour,minute)
                Performs an ODCNV% JSYS, expanding the first  integer  into
                the  other  6  integers  (year, month, day of month, day of
                week, hour, minute).  The first integer must be  a  TOPS-20
                internal date and time (TAD).


           ____$File_Dev (file)
                STRINGProgrammable Command Language                                       Page 91


           ____$File_Dir (file)
                STRING


           ____$File_Nam (file)
                STRING


           ____$File_Typ (file)
                STRING  -  These  return just the corresponding part of the
                name  of  the  file  specified  in  the  same   manner   as
                $FileInfo_S.


           ______$InputTAD (string)
                INTEGER  -  Converts  a  string time and date into internal
                format.


          ______  _______$Integer (string[,integer])
                                                           ______                INTEGER  -  Converts  decimal  number  in  string  into  an
                integer.    The optional second argument provides the radix
                to use.  Returns 0 on an error.


         ______$Length (string)
                                                ______                INTEGER - Returns the length of string


           ____ _____ ___ __ _____ ____ ______$MergeTAD (year,month,day of month,hour,minute)
                INTEGER - Performs an IDCNV%  JSYS,  compacting  the  first
                five  integers  (year,  month,  day of month, hour, minute)
                into an internal date and time.


$NextFile       INTEGER - Used to step to the next file in  a  parsed  file
                list. Returns zero at the end of the list.


      ______ _______$Open(string,integer)
                INTEGER  -  Opens  the file named in the string for I/O, in
                the mode specified by the integer (either $Input,  $Output,
                or  $Append).   Returns the PCL channel number assigned, or
                zero if the open could not be done.


            _______$OutputTAD (integer)
                STRING - Convert internal date and time to string.


       _______$Read (channel) STRING - Reads a record from the file opened for  input  on
                _______                channel.Programmable Command Language                                       Page 92


             _______ ______  _______$ReadBinary (integer,string[,integer])
                STRING  -  Reads  from  the  terminal, in binary, up to the
                                   _______                specified number  (integer)  of  characters  or  until  the
                                       ______                specified  character  (string) is read.  This will time out
                and return an empty string if nothing  is  typed  within  a
                second.  An  optional third integer argument can be used to
                provide the number of milliseconds to use for  the  timeout
                period.     This  is  suitable  only  for  reading  control
                information transmitted by the VT100 terminal  in  response
                to  requests  such  as  "send  terminal model ID" and "send
                cursor position."


         ______ ______  _______$Search (string,string[,integer])
                INTEGER - Searches the first string for the  second  string
                and  returns  the index within first string, or zero if not
                found.  With the optional third argument, starts the search
                at that location within the string.


               ______ ______  _______$SearchRaised (string,string[,integer])
                INTEGER - Same as $Search except lower case alphabetics are
                raised to upper case.


         _______  _______$String (integer[,integer])
                STRING - Converts the integer into a string.  The  optional
                second argument provides the radix to use.


             ____  _____ ____$FileInfo_I (file, field code)
                INTEGER


             ____  _____ ____$FileInfo_S (file, field code)
                STRING  These two return information about a file. The file
                is selected by the first argument and  the  information  to
                return  is  selected  by  the second argument.  Permissible
                ____                file values are $Parse for the file currently being parsed,
                or the runtime channel number.


                                    _____ ____                For $FileInfo_I the field code is the name of the index  of
                the  GTFDB  JSYS,  such  as  $FBSIZ and $FBCRV, or mnemonic
                names such as $FileSize and $FileCreation.  For $FileInfo_S
                    _____ _____                the field codes allowed are:   $Author,  the  name  of  the
                author  of  the  file; $Writer, the name of the file's last
                writer; $FileAccount, the  file's  account  number;  or  an
                integer  greater than 63 which calls the JFNS JSYS with the
                                                _____ ____                formatting parameter set to the field code minus 64.Programmable Command Language                                       Page 93


      _______$Wait(integer)  Waits  the  specified number of milliseconds, or forever if
                zero.


       _______ ______$Write(channel,record)
                       ______                                _______                Writes record into the output file opened on channel.Programmable Command Language                                       Page 94


                                 CHAPTER 8                                 CHAPTER 8                                 CHAPTER 8

                              BNF DESCRIPTION                              BNF DESCRIPTION                              BNF DESCRIPTION

  This  section  describes  the  entire  PCL language using a BNF notation.

Non-terminal symbols are enclosed in angle brackets "< >".  Optional  items

are are enclosed in braces "{ }".



8.1. Top Level BNF8.1. Top Level BNF8.1. Top Level BNF


<PCL-file>              ::= <Top-level>
                        ::= <Top-level> {;} <PCL-file>
<Top-level>             ::= <Command-declaration>
                        ::= <Procedure-declaration>
                        ::= <Variable-declaration>

<Command-declaration>   ::= <Command-head> ; <Procedure-body>
<Command-head>          ::= COMMAND <Identifier>
                        ::= COMMAND <Identifier>
                                        ( <Command-argument-list> )
<Command-argument-list> ::= <Command-argument>
                        ::= <Command-argument> ; <Command-argument-list>
<Command-argument>      ::= <Field-specification>
                        ::= <Field-specification> : <Identifier>

<Procedure-declaration> ::= <Procedure-head> ; <Procedure-body>
                        ::= <Simple-type> <Procedure-head> ;
                                <Procedure-body>
<Procedure-head>        ::= PROCEDURE <Identifier>
                        ::= PROCEDURE <Identifier> (<Formal-parm-list>)

<Procedure-body>        ::= <Block>
<Formal-parm-list>      ::= <Simple-type> <Id-list>
                        ::= <Simple-type> <Id-list> ; <Formal-parm-list>

<Block>                 ::= <Block-head> <Compound-tail>
<Block-head>            ::= BEGIN { <Declaration-list> ; }
<Declaration-list>      ::= <Declaration>
                        ::= <Declaration> ; <Declaration-list>
<Compound-statement>    ::= BEGIN <Compound-tail>
<Compound-tail>         ::= <Statement-list> { ; } END
                        ::= END
<Statement-list>        ::= <Statement>
                        ::= <Statement> ; <Statement-list>Programmable Command Language                                       Page 95


8.2. Declaration BNF8.2. Declaration BNF8.2. Declaration BNF



<Declaration>           ::= <Variable-declaration>
                        ::= <External-procedure-declaration>
                        ::= EXTERNAL <Variable-declaration>
<Variable-declaration>  ::= <Simple-type> <Id-list>
<Simple-type>           ::= INTEGER
                        ::= STRING
<Id-list>               ::= <Identifier>
                        ::= <Identifier> , <Id-list>
<External-procedure-declaration>
                        ::= EXTERNAL PROCEDURE <Id-list>
                        ::= EXTERNAL <Simple-type> PROCEDURE <Id-list>




8.3. Statement BNF8.3. Statement BNF8.3. Statement BNF


<Statement>             ::= <Compound-statement>
                        ::= <Assignment-statement>
                        ::= <Conditional-statement>
                        ::= <Go-to-statement>
                        ::= <Do-statement>
                        ::= <Case-statement>
                        ::= <Select-statement>
                        ::= <Return-statement>
                        ::= <Exit-statement>
                        ::= <Procedure-statement>
                        ::= <Parse-statement>
                        ::= <Command-statement>
                        ::= <Program-statement>
                        ::= <No-op-statement>
                        ::= <Label> : <Statement>

<Assignment-statement>  ::= LET <Identifier> = <Expression>
                        ::= <Identifier> = <Expression>
<Conditional-statement> ::= <If-statement>
                        ::= <If-statement> ELSE <Statement>
<If-statement>          ::= IF <Logical-expression> THEN <Statement>
<Go-to-statement>       ::= GOTO <Label-identifier>
<Do-statement>          ::= DO <Statement> WHILE <Logical-expression>
                        ::= WHILE <Logical-expression> DO <Statement>
<Case-statement>        ::= <Case-head> { <Tagged-statement-list> {;} } END
<Case-head>             ::= CASE <Integer-expression>
                                FROM <Integer-constant>
                                TO <Integer-constant> OF BEGIN
<Tagged-statement-list> ::= <Tagged-statement>
                        ::= <Tagged-statement> ; <Tagged-statement-list>Programmable Command Language                                       Page 96


<Tagged-statement>      ::= <Integer-constant> : <Statement>
                        ::= INRANGE : <Statement>
                        ::= OUTRANGE : <Statement>
<Select-statement>      ::= <Select-head> { <Expr-statement-list> {;} } END
<Select-head>           ::= SELECT <Expression> OF BEGIN
<Expr-statement-list>   ::= <Expr-statement>
                        ::= <Expr-statement> ; <Expr-statement-list>
<Expr-statement>        ::= <Expression> : <Statement>
                        ::= OTHERWISE : <Statement>
<Return-statement>      ::= RETURN
                        ::= RETURN <Expression>
<Exit-statement>        ::= EXIT
                        ::= EXIT SAVE
                        ::= EXIT TOPROGRAM
                        ::= ABORT <String-expression>
<Procedure-statement>   ::= CALL <Procedure-Identifier>
                        ::= CALL <Procedure-Identifier> (<Actual-parms>)
<No-op-statement>       ::= NOP



8.4. Parse BNF8.4. Parse BNF8.4. Parse BNF


<Parse-statement>       ::= GUIDE <String-constant>
                        ::= PROMPT <String-constant>
                        ::= PROMPT NOECHO <String-constant>
                        ::= PARSE <Field-specification>
                        ::= PARSE BEGIN <Parse-field-list> END
<Parse-field>           ::= <Field-specification> [ : <Statement> ]
                        ::= OTHERWISE : <Statement>
<Parse-field-list>      ::= <Parse-field>
                        ::= <Parse-field> ; <Parse-field-list>
<Field-specification>   ::= <Field-type>
                        ::= <Field-type> ( <Field-option-list> )
<Field-type>            ::= KEYWORD
                        ::= SWITCH
                        ::= NUMBER
                        ::= NOISE <String-constant>
                        ::= INPUTFILE
                        ::= OUTPUTFILE
                        ::= FILE
                        ::= FIELD
                        ::= EOL        (not available as command argument)
                        ::= DIRECTORY
                        ::= USERNAME
                        ::= COMMA
                        ::= DEVICE
                        ::= TEXT
                        ::= DAYTIME
                        ::= QUOTEDSTRING
                        ::= TOKEN <String-constant>Programmable Command Language                                       Page 97


                        ::= NODE
                        ::= FILELIST
<Field-option-list>     ::= <Field-option> { , <Field-option> }
<Field-option>
                        ::= DEFAULT <String-primary>
                        ::= HELP <String-primary>
                        ::= PARSEONLY
                        ::= NOHELP
                        ::= STDHELP
                        ::= NOINDIRECT
                        ::= INPUT
                        ::= OUTPUT
                        ::= INVISIBLE
                        ::= DELETED
                        ::= WILD
                        ::= DEFAULT_DEV <String-primary>
                        ::= DEFAULT_DIR <String-primary>
                        ::= DEFAULT_NAM <String-primary>
                        ::= DEFAULT_EXT <String-primary>
                        ::= DEFAULT_GEN <Code>
                              The codes are 0 (highest generation), + (next
                              generation), - (first generation), * (all
                              generations), or a generation number.
                        ::= RADIX <Integer-constant>
                        ::= WORDS ( <Word-list> )
                        ::= TIME
                        ::= DATE
                        ::= ERROR <Label-identifier>
<Word-list>             ::= <Word-definition>
                        ::= <Word-definition> , <Word-list>
<Word-definition>       ::= <Identifier> : <Integer-constant>
                        ::= <Integer-constant> : <Integer-constant>
                        ::= <Identifier> :: <Integer-constant>
                        ::= <Integer-constant> :: <Integer-constant>



8.5. Command Statement BNF8.5. Command Statement BNF8.5. Command Statement BNF


<Command-statement>     ::= DOCOMMAND <String-expression> <Command-option>
                        ::= DOCOMMAND ORIGINAL <String-expression>
                                <Command-option>
<Command-option>        ::= <empty>
                        ::= TO <String-identifier> <Command-option>Programmable Command Language                                       Page 98


8.6. Program Statement BNF8.6. Program Statement BNF8.6. Program Statement BNF


<Program-statement>     ::= INVOKE <String-expression>
                        ::= INVOKE PASSOUTPUT <String-expression>
                        ::= KILLPROGRAM
                        ::= TYPEIN <String-expression>
                        ::= TYPEIN NORETURN <String-expression>
                        ::= GETTYPEOUT <String-identifier>
                        ::= CLEARTYPEOUT
                        ::= DISPLAY <String-expression>
                        ::= DISPLAY NORETURN <String-expression>
                        ::= DISPLAY BINARY <String-expression>



8.7. Expression BNF8.7. Expression BNF8.7. Expression BNF


<Logical-expression>    ::= <Relational-expression>
<Relational-expression> ::= <Integer-expression> <Relational-operator>
                                <Integer-expression>
                        ::= <String-expression> <Relational-operator>
                                <String-expression>
<Relational-operator>   ::= <
                        ::= =
                        ::= >
                        ::= <=
                        ::= <>
                        ::= >=

<Expression>            ::= <Integer-expression>
                        ::= <String-expression>

<Integer-expression>    ::= <Term>
                        ::= <Term> <Add-operator> <Term>
<Add-operator>          ::= +
                        ::= -
<Term>                  ::= <Integer-primary>
                        ::= <Integer-primary> <Mult-operator> <Term>
<Mult-operator>         ::= *
                        ::= /
<String-expression>     ::= <String-primary>
                        ::= <String-primary> + <String-expression>
<Integer-primary>       ::= <Integer-identifier>
                        ::= - <Integer-primary>
                        ::= <Integer-constant>
                        ::= <Procedure-call>
                        ::= ( <Integer-expression> )
<String-primary>        ::= <String-identifier>
                        ::= <String-constant>
                        ::= <Procedure-call>Programmable Command Language                                       Page 99


                        ::= <String-primary>
                               [ <Integer-expression> :
                               <Integer-expression> ]
                        ::= <String-primary>
                               [ <Integer-expression> : * ]
<Procedure-call>        ::= <Procedure-identifier>
                        ::= <Procedure-identifier> ( Actual-parms> )
<Actual-parms>          ::= <Expression>
                        ::= <Expression> , <Actual-parms>



8.8. Identifier BNF8.8. Identifier BNF8.8. Identifier BNF


<Integer-identifier>    ::= <Identifier>
                        ::= <System-variable-identifier>
<String-identifier>     ::= <Identifier>
                        ::= <System-variable-identifier>
<Procedure-identifier>  ::= <Identifier>
<Label-identifier>      ::= <Identifier>
<Identifier>            ::= <Alphabetic>
                        ::= <Identifier> <Alphanumeric>
                        ::= <Identifier> _ <Alphanumeric>
<Integer-constant>      ::= <Decimal>
                        ::= <Decimal-constant> <Decimal>
<String-constant>       ::= {sequence of characters enclosed by double-
                             quotes; double-quotes may be inserted in the
                             string by doubling them}Programmable Command Language                                        Page i


Table of ContentsTable of ContentsTable of Contents

1. Introduction1. Introduction1. Introduction                                                           1

     1.1. Programmable Command Language                                   1
     1.2. PCL Uses                                                        1
     1.3. PCL Features                                                    2

2. EXEC Interface2. EXEC Interface2. EXEC Interface                                                         3

3. The PCL Language3. The PCL Language3. The PCL Language                                                       5

     3.1. General Command Format                                          5
     3.2. PCL Variables                                                   6
     3.3. String Manipulation                                             7
     3.4. Procedures                                                      8
     3.5. PCL Flow Control                                                9
          3.5.1. DO, WHILE                                                9
          3.5.2. IF                                                       9
          3.5.3. CASE                                                    10
          3.5.4. SELECT                                                  10
          3.5.5. GOTO                                                    11

4. User Interface4. User Interface4. User Interface                                                        12

     4.1. Parse formats                                                  13
          4.1.1. Simple PARSE                                            13
          4.1.2. Complex PARSE                                           13
          4.1.3. Command Arguments                                       14
     4.2. Parse Options                                                  14
     4.3. FILELIST                                                       15
     4.4. Parse error handling                                           16

5. Program and Command Interface5. Program and Command Interface5. Program and Command Interface                                         18

     5.1. Running Programs                                               18
     5.2. Executing EXEC Commands                                        19

6. Input/Output6. Input/Output6. Input/Output                                                          20

7. Reference7. Reference7. Reference                                                             21

     7.1. Expressions                                                    22
          7.1.1. Integer expressions                                     22
          7.1.2. String expressions                                      22
          7.1.3. Logical expressions                                     23
     7.2. Statements                                                     24
     7.3. Abort                                                          25
     7.4. Assignment                                                     26
     7.5. Begin                                                          27
     7.6. Call                                                           29
     7.7. Case                                                           31Programmable Command Language                                       Page ii


     7.8. ClearTypeOut                                                   33
     7.9. Command                                                        35
     7.10. Declare                                                       37
     7.11. Display                                                       39
     7.12. Do                                                            41
     7.13. DoCommand                                                     43
     7.14. Exit                                                          45
     7.15. External                                                      47
     7.16. GetTypeOut                                                    49
     7.17. GoTo                                                          51
     7.18. Guide                                                         52
     7.19. If                                                            54
     7.20. Information                                                   56
     7.21. Invoke                                                        58
     7.22. KillProgram                                                   60
     7.23. Original                                                      62
     7.24. Parse                                                         63
          7.24.1. Field types                                            63
          7.24.2. Field options                                          66
     7.25. Preserve                                                      71
     7.26. Procedure                                                     73
     7.27. Prompt                                                        75
     7.28. Return                                                        77
     7.29. Select                                                        79
     7.30. Set                                                           81
     7.31. TypeIn                                                        83
     7.32. While                                                         85
     7.33. System                                                        86
          7.33.1. System Variables                                       86
          7.33.2. System Procedures                                      90

8. BNF Description8. BNF Description8. BNF Description                                                       94

     8.1. Top Level BNF                                                  94
     8.2. Declaration BNF                                                95
     8.3. Statement BNF                                                  95
     8.4. Parse BNF                                                      96
     8.5. Command Statement BNF                                          97
     8.6. Program Statement BNF                                          98
     8.7. Expression BNF                                                 98
     8.8. Identifier BNF                                                 99
