;	  0001	! UPD ID= 86, PS:<5-0.PCL.LOCAL>EXECPN.B36.13,  10-Feb-83 12:49:54 by DEBAR
;	  0002	! [fun65] Add $strfix function
;	  0003	! UPD ID= 82, PS:<5-0.PCL.LOCAL>EXECPN.B36.12,  19-Jan-83 13:14:22 by DEBAR
;	  0004	! [fun62] Correct bug in $ret_mem
;	  0005	! UPD ID= 66, PS:<5-0.PCL.LOCAL>EXECPN.B36.11,  24-Nov-82 23:24:17 by DEBAR
;	  0006	! [fun50] Allow $fileSet to accept string spec of file (see [fun49]
;	  0007	! UPD ID= 62, PS:<5-0.PCL.LOCAL>EXECPN.B36.10,  24-Nov-82 13:19:36 by DEBAR
;	  0008	! [fun48] $isfile(string) says if the file does exit
;	  0009	! UPD ID= 53, PS:<5-0.PCL.LOCAL>EXECPN.B36.9,  12-Nov-82 23:55:26 by DEBAR
;	  0010	! [fun43] [fun44] Correct order of calls to pcegop - pcegop returns typ
;	  0011	!   [fun43] involves changes to a lot of the routines in this module,
;	  0012	!           not specifically marked in the text.
;	  0013	! UPD ID= 50, PS:<5-0.PCL.LOCAL>EXECPN.B36.8,  12-Nov-82 11:32:53 by DEBAR
;	  0014	! [fun41] Change order of arguments of $setfield
;	  0015	! UPD ID= 49, PS:<5-0.PCL.LOCAL>EXECPN.B36.7,  10-Nov-82 17:20:18 by DEBAR
;	  0016	! [FUN39] JSYS INTERFACE
;	  0017	! UPD ID= 46, PS:<5-0.PCL.LOCAL>EXECPN.B36.5,   5-Nov-82 16:30:53 by DEBAR
;	  0018	! [fun38] $termlength
;	  0019	! UPD ID= 42, PS:<5-0.PCL.LOCAL>EXECPN.B36.4,   3-Nov-82 16:34:42 by DEBAR
;	  0020	! [fun36] Parse: $Xatom, $Command
;	  0021	! UPD ID= 38, PS:<5-0.PCL.LOCAL>EXECPN.B36.3,  27-Oct-82 22:23:15 by DEBAR
;	  0022	! [fun33] Problem with fileinfo_i when using wild-cards.
;	  0023	! UPD ID= 32, PS:<5-0.PCL.LOCAL>EXECPN.B36.2,  21-Oct-82 21:57:49 by DEBAR
;	  0024	! [fun29] $FileSet
;	  0025	! UPD ID= 30, PS:<5-0.PCL.LOCAL>EXECPN.B36.1,  21-Oct-82 10:16:02 by DEBAR
;	  0026	! [fun28] $directoryinfo_i, $directoryinfo_s
;	  0027	! UPD ID= 25, PS:<5-0.PCL.LOCAL>EXECPU.B36.4,  20-Oct-82 10:08:48 by DEBAR
;	  0028	! [fun27] $getfield, $setfield, $and, $or
;	  0029	
;	  0030	MODULE EXECPN =
;	  0031	BEGIN
;	  0032	
;	  0033	!++
;	  0034	!
;	  0035	! FNDP extensions to EXECPU utilities.
;	  0036	! Copyright (C) 1982, FDNP Computing Center, Belgium
;	  0037	!
;	  0038	!--
;	  0039	
;	  0040	!++
;	  0041	!    This module contains the system service routines which are provided
;	  0042	!  as part of the standard Exec. !! FNDP extensions only.
;	  0043	!--
;	  0044	
;	  0045	!
;	  0046	! Standard definitions
;	  0047	!
;	  0048	
;	  0049	LIBRARY 'EXECPD';		!Get common definitions
;	  0050	LIBRARY 'BLI:TENDEF';		!There are JSYS's in this module
;	  0051	LIBRARY 'BLI:MONSYM';
; WARN#050	........1  L1:0051
; Name already declared in this block:  $CHLFD
; WARN#050	........1  L1:0051
; Name already declared in this block:  $CHCRT
; WARN#050	........1  L1:0051
; Name already declared in this block:  $CHFFD
;	  0052	SWITCHES LINKAGE(EXEC);
;	  0053	
;	  0054	BUILTIN JSYS;
;	  0055	
;	  0056	!
;	  0057	! Table of contents:
;	  0058	!
;	  0059	
;	  0060	FORWARD ROUTINE
;	  0061	                                ! [fun27]+ $getfield, $setfield, $and, $or
;	  0062	    dingfl,                     ! Integer procedure $getfield
;	  0063	    dinsfl,                     ! Integer procedure $setfield
;	  0064	    dinand,                     ! Integer procedure $and
;	  0065	    dinor,                      ! Integer procedure $or
;	  0066	                                ! [fun27]- $getfield, $setfield, $and, $or
;	  0067	                                ! [fun28]+ $directoryinfo_i, $directoryinfo_s
;	  0068	    dindii,                     ! Integer procedure $directoryinfo_i
;	  0069	    dindis,                     ! String procedure $directoryinfo_s
;	  0070	    dinrcd,                     ! do a rcdir
;	  0071	    dingtd,                     ! do a gtdir
;	  0072	                                ! [fun28]- $directoryinfo_i, $directoryinfo_s
;	  0073	                                ! [fun29]: $Fileset
;	  0074	    dinsfi: novalue,            ! system procedure $FileSet
;	  0075	                                ! [fun36]+ Parse: $Xatom, $Command
;	  0076	    dinxat,                     ! system variable $xatom,
;	  0077	    dincmd,                     ! system variable $command.
;	  0078	                                ! [fun36]-
;	  0079	    divtln,                     ! [fun38] $termlength
;	  0080	                                ! [Fun39]+ Jsys Interface
;	  0081	    dingmm,                     ! integer procedure $get_mem
;	  0082	    dinrmm: novalue,            ! procedure $ret_mem,
;	  0083	    dinipm: novalue,            ! procedure $iput
;	  0084	    dinigm,                     ! integer procedure $iget
;	  0085	    dinspm: novalue,            ! procedure $sput
;	  0086	    dinsgm,                     ! string procedure $sget
;	  0087	    dinjfc,                     ! integer prodecure $jfn
;	  0088	    dinjs0,                     ! integer procedure $jsys
;	  0089	    dinjs1: novalue,            ! procedure $jsys1
;	  0090	    dinjsx,                     ! integer procedure serving $jsys0/1
;	  0091	    dinsad,                     ! integer procedure $strloc
;	  0092	                                ! [Fun39]- Jsys Interface
;	  0093	                                ! [FUN48]:
;	  0094	    dinisf,
;	  0095	                                ! [fun65]: Add $strfix function
;	  0096	    dinsfx;                     ! Add $strfix procedure
;	  0097	
;	  0098	!
;	  0099	! Macros:
;	  0100	!
;	  0101	
;	  0102	MACRO ERROR(TXT) = PCEERR(UPLIT(%ASCIZ TXT)) %;
;	  0103	
;	  0104	!
;	  0105	! External references:
;	  0106	!
;	  0107	
;	  0108	EXTERNAL ROUTINE
;	  0109	    PCEERR,			! EXECPX Report execution error
;	  0110	    PCEAST,			! EXECPX Allocate string space
;	  0111	    PCECST,			! EXECPX Make copy of a string
;	  0112	    PCEGOP : exec1,             ! [fun44] EXECPX Get value of operand
;	  0113	    PCEFST: NOVALUE,		! EXECPX Free string storage
;	  0114	    PCMGMM,			! EXECPM General memory allocator
;	  0115	    PCMSTI,			! CVTDBO routine
;	  0116	    RETMEM,			! EXECSU General memory release
;	  0117	    SUBBP,			! EXECSU Subtract two byte pointers
;	  0118	    DIUJFN: exec1;              ! [fun50] EXECPU Get jfn from fil spec
;	  0119	
;	  0120	EXTERNAL
;	  0121	    PCCURC: REF ECB_BLK,	! Current Execution Context Block
;	  0122	    PCLPMT: VECTOR,		! Prompt string table
;	  0123	    XDICT,			! Permanent storage pool
;	  0124	    REDPMT: VECTOR,		! Regular prompt table
;	  0125	    JOBNO,			! Job number of this job
;	  0126	    CUSRNO,			! User number
;	  0127	    CSBUFP: STR_VAL,		! Temporary string buffer pointer
;	  0128	                                ! [fun36]+ Parse: $Xatom, $Command
;	  0129	    ATMBUF: VECTOR,		! Common COMND% atom buffer
;	  0130	    CBUF: VECTOR,               ! exec command buffer
;	  0131	    SBLOCK: VECTOR,             ! exec command state block
;	  0132	                                ! [fun36]-
;	  0133	                                ! [fun39]+ Jsys Interface
;	  0134	    PCSFRE,                     ! pointer to free string memory
;	  0135	    PCVRG1,                     ! $reg1 location
;	  0136	    PCVRG2,                     ! $reg2 location
;	  0137	    PCVRG3,                     ! $reg3 location
;	  0138	    PCVRG4,                     ! $reg4 location
;	  0139	    PCVJSK;                     ! $jsysok location
;	  0140	                                ! [fun39]-
;	  0141	
;	  0142	
;	  0143	
;	  0144	GLOBAL ROUTINE dingfl (ap,cnt) =             ! Integer procedure $getfield
;	  0145	
;	  0146	!++
;	  0147	! Functional description:
;	  0148	! $getfield(from,pos,wid) extracts an unsigned bit field wid bits
;	  0149	! wide, dropping the pos least significant bits. Exits in error if bad
;	  0150	! arguments are given.
;	  0151	!
;	  0152	! Formal parameters:
;	  0153	! Usual for pcl system procedure.
;	  0154	!
;	  0155	! Implicit inputs:
;	  0156	! none
;	  0157	!
;	  0158	! Implicit outputs:
;	  0159	! none
;	  0160	!
;	  0161	! Routine Value:
;	  0162	! extracted bit field
;	  0163	!
;	  0164	! Side effects:
;	  0165	! none
;	  0166	!
;	  0167	!--
;	  0168	
;	  0169	begin
;	  0170	external register z=0;
;	  0171	local
;	  0172	   pos,                         ! position value
;	  0173	   wid;                         ! width of field
;	  0174	builtin
;	  0175	   lsh;
;	  0176	if .cnt neq 3 then error ('Bad arguments to $getfield');
;	  0177	wid = pcegop (.(.ap+2),ste_typ_int);
;	  0178	pos = pcegop (.(.ap+1),ste_typ_int);if .pos lss 0 or .pos gtr 36 or .wid lss 0 or .wid gtr 36 or
;	  0179	   .pos+.wid gtr 36 then error ('Bad arguments to $getfield');
;	  0180	lsh (lsh (pcegop(..ap,ste_typ_int), 36-.pos-.wid), .wid-36)
;	  0181	end;


	TITLE	EXECPN
	TWOSEG


	.REQUEST  SYS:B362LB.REL


	RELOC	400000
P.AAA:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","g","e"		; o $ge
	BYTE	(7)"t","f","i","e","l"		; tfiel
	BYTE	(7)"d",000,000,000,000		; d
P.AAB:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","g","e"		; o $ge
	BYTE	(7)"t","f","i","e","l"		; tfiel
	BYTE	(7)"d",000,000,000,000		; d


	EXTERN	PCEERR, PCEAST, PCECST, PCEGOP, PCEFST, PCMGMM, PCMSTI, RETMEM, SUBBP, DIUJFN, PCCURC
	EXTERN	PCLPMT, XDICT, REDPMT, JOBNO, CUSRNO, CSBUFP, ATMBUF, CBUF, SBLOCK, PCSFRE, PCVRG1
	EXTERN	PCVRG2, PCVRG3, PCVRG4, PCVJSK


AC0=	0
AC1=	1
AC2=	2
AC3=	3
AC4=	4
AC5=	5
AC6=	6
AC7=	7
AC10=	10
AC11=	11
AC12=	12
AC13=	13
AC14=	14
FP=	15
AC16=	16
SP=	17


U.1:
DINGFL::PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,3				; CNT,3
	JRST	L.1				; L.1
	MOVEI	AC1,P.AAA			; AC1,P.AAA
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.1:	MOVE	AC1,2(AC14)			; AC1,2(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC13,AC1			; WID,AC1
	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC12,AC1			; POS,AC1
	JUMPL	AC12,L.2			; POS,L.2
	CAILE	AC12,44				; POS,44
	JRST	L.2				; L.2
	JUMPL	AC13,L.2			; WID,L.2
	CAILE	AC13,44				; WID,44
	JRST	L.2				; L.2
	MOVE	AC1,AC12			; AC1,POS
	ADD	AC1,AC13			; AC1,WID
	CAIG	AC1,44				; AC1,44
	JRST	L.3				; L.3
L.2:	MOVEI	AC1,P.AAB			; AC1,P.AAB
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.3:	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC2,AC1				; AC2,AC1
	MOVE	AC1,AC12			; AC1,POS
	ADD	AC1,AC13			; AC1,WID
	MOVN	AC1,AC1				; AC1,AC1
	LSH	AC2,44(AC1)			; AC2,44(AC1)
	LSH	AC2,-44(AC13)			; AC2,-44(WID)
	MOVE	AC1,AC2				; AC1,AC2
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,

; Routine Size:  42 words


;	  0182	
;	  0183	
;	  0184	
;	  0185	GLOBAL ROUTINE dinsfl (ap,cnt) =             ! Integer procedure $setfield
;	  0186	
;	  0187	!++
;	  0188	! Functional description:
;	  0189	!    int = $setfield(field,value,pos,wid) puts an unsigned bit field wid bits
;	  0190	! wide, dropping the pos least significant bits. Exits in error if bad
;	  0191	! arguments are given.
;	  0192	!
;	  0193	! Formal parameters:
;	  0194	! Usual for pcl system procedure.
;	  0195	!
;	  0196	! Implicit inputs:
;	  0197	! none
;	  0198	!
;	  0199	! Implicit outputs:
;	  0200	! none
;	  0201	!
;	  0202	! Routine Value:
;	  0203	! Modified destination word
;	  0204	!
;	  0205	! Side effects:
;	  0206	! none
;	  0207	!
;	  0208	!--
;	  0209	
;	  0210	begin
;	  0211	external register z=0;
;	  0212	local
;	  0213	   value,                       ! value to modify
;	  0214	   mask,                        ! mask of ones in field position
;	  0215	   pos,                         ! position value
;	  0216	   wid;                         ! width of field
;	  0217	builtin
;	  0218	   lsh;
;	  0219	if .cnt neq 4 then error ('Bad arguments to $setfield');
;	  0220	wid = pcegop (.(.ap+3),ste_typ_int);
;	  0221	pos = pcegop (.(.ap+2),ste_typ_int);
;	  0222	if .pos lss 0 or .pos gtr 36 or .wid lss 0 or .wid gtr 36 or
;	  0223	   .pos+.wid gtr 36 then error ('Bad arguments to $getfield');
;	  0224	value = pcegop (.(.ap+1),ste_typ_int);
;	  0225	mask = lsh( lsh(-1,36-.wid),.wid+.pos-36);      ! ones where we have
;	  0226	                                                ! field
;	  0227	                                ! [fun41]: Change order of arguments of
;	  0228	                                ! $setfield
;	  0229	(.value and (not .mask))
;	  0230	or (lsh(pcegop(.(.ap),ste_typ_int),.pos) and .mask)
;	  0231	
;	  0232	end;


P.AAC:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","s","e"		; o $se
	BYTE	(7)"t","f","i","e","l"		; tfiel
	BYTE	(7)"d",000,000,000,000		; d
P.AAD:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","g","e"		; o $ge
	BYTE	(7)"t","f","i","e","l"		; tfiel
	BYTE	(7)"d",000,000,000,000		; d


U.2:
DINSFL::PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,4				; CNT,4
	JRST	L.4				; L.4
	MOVEI	AC1,P.AAC			; AC1,P.AAC
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.4:	MOVE	AC1,3(AC14)			; AC1,3(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC13,AC1			; WID,AC1
	MOVE	AC1,2(AC14)			; AC1,2(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC11,AC1			; POS,AC1
	JUMPL	AC11,L.5			; POS,L.5
	CAILE	AC11,44				; POS,44
	JRST	L.5				; L.5
	JUMPL	AC13,L.5			; WID,L.5
	CAILE	AC13,44				; WID,44
	JRST	L.5				; L.5
	MOVE	AC1,AC11			; AC1,POS
	ADD	AC1,AC13			; AC1,WID
	CAIG	AC1,44				; AC1,44
	JRST	L.6				; L.6
L.5:	MOVEI	AC1,P.AAD			; AC1,P.AAD
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.6:	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC12,AC1			; VALUE,AC1
	MOVN	AC1,AC13			; AC1,WID
	SETO	AC2,				; AC2,
	LSH	AC2,44(AC1)			; AC2,44(AC1)
	MOVE	AC1,AC13			; AC1,WID
	ADD	AC1,AC11			; AC1,POS
	LSH	AC2,-44(AC1)			; AC2,-44(AC1)
	MOVE	AC13,AC2			; MASK,AC2
	ANDCM	AC12,AC13			; VALUE,MASK
	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	LSH	AC1,0(AC11)			; AC1,0(POS)
	AND	AC1,AC13			; AC1,MASK
	IOR	AC1,AC12			; AC1,AC12
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,

; Routine Size:  52 words


;	  0233	
;	  0234	
;	  0235	GLOBAL ROUTINE dinand (ap,cnt) =             ! integer procedure $and
;	  0236	
;	  0237	!++
;	  0238	! Functional description:
;	  0239	! $and(a,b) returns the logical and of a and b, bit by bit
;	  0240	!
;	  0241	! Formal parameters:
;	  0242	! usual for system pcl procedure
;	  0243	!
;	  0244	! Implicit inputs:
;	  0245	! none
;	  0246	!
;	  0247	! Implicit outputs:
;	  0248	! none
;	  0249	!
;	  0250	! Routine Value:
;	  0251	! And of a and b
;	  0252	!
;	  0253	! Side effects:
;	  0254	! none
;	  0255	!
;	  0256	!--
;	  0257	
;	  0258	begin
;	  0259	external register z=0;
;	  0260	local
;	  0261	   op2;
;	  0262	
;	  0263	if .cnt neq 2 then error ('Bad arguments to $and');
;	  0264	op2 = pcegop(.(.ap+1),ste_typ_int);
;	  0265	pcegop(..ap,ste_typ_int) and .op2
;	  0266	end;


P.AAE:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","a","n"		; o $an
	BYTE	(7)"d",000,000,000,000		; d


U.3:
DINAND::PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,2				; CNT,2
	JRST	L.7				; L.7
	MOVEI	AC1,P.AAE			; AC1,P.AAE
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.7:	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC13,AC1			; OP2,AC1
	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	AND	AC1,AC13			; AC1,OP2
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  18 words


;	  0267	
;	  0268	
;	  0269	GLOBAL ROUTINE dinor (ap,cnt) =             ! integer procedure $or
;	  0270	
;	  0271	!++
;	  0272	! Functional description:
;	  0273	! $or(a,b) returns the logical or of a and b, bit by bit
;	  0274	!
;	  0275	! Formal parameters:
;	  0276	! usual for system pcl procedure
;	  0277	!
;	  0278	! Implicit inputs:
;	  0279	! none
;	  0280	!
;	  0281	! Implicit outputs:
;	  0282	! none
;	  0283	!
;	  0284	! Routine Value:
;	  0285	! And of a and b
;	  0286	!
;	  0287	! Side effects:
;	  0288	! none
;	  0289	!
;	  0290	!--
;	  0291	
;	  0292	begin
;	  0293	external register z=0;
;	  0294	
;	  0295	local
;	  0296	   op2;
;	  0297	
;	  0298	if .cnt neq 2 then error ('Bad arguments to $and');
;	  0299	op2 = pcegop(.(.ap+1),ste_typ_int);
;	  0300	pcegop(..ap,ste_typ_int) or .op2
;	  0301	end;


P.AAF:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","a","n"		; o $an
	BYTE	(7)"d",000,000,000,000		; d


U.4:
DINOR:: PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,2				; CNT,2
	JRST	L.8				; L.8
	MOVEI	AC1,P.AAF			; AC1,P.AAF
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.8:	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC13,AC1			; OP2,AC1
	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	IOR	AC1,AC13			; AC1,OP2
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  18 words


;	  0302	
;	  0303	
;	  0304	GLOBAL ROUTINE dindii (ap,cnt) =        ! integer procedure $directoryinfo_i
;	  0305	
;	  0306	!++
;	  0307	! Functional description:
;	  0308	! $directoryinfo_i("dirname",code)
;	  0309	! Returns integer information about directory according to code.
;	  0310	!  code is gtdir directory block offset, or $cddan for gtdal info.
;	  0311	!
;	  0312	! Formal parameters:
;	  0313	! usual for pcl system procedure
;	  0314	!
;	  0315	! Implicit inputs:
;	  0316	! none
;	  0317	!
;	  0318	! Implicit outputs:
;	  0319	! none
;	  0320	!
;	  0321	! Routine Value:
;	  0322	! integer value requested
;	  0323	!
;	  0324	! Side effects:
;	  0325	! none
;	  0326	!
;	  0327	!--
;	  0328	
;	  0329	begin
;	  0330	external register z=0;
;	  0331	
;	  0332	local
;	  0333	   str : str_val,               ! directory name string value
;	  0334	   code,                        ! code of result needed
;	  0335	   dirnum;                      ! directory number
;	  0336	
;	  0337	if .cnt neq 2 then error ('Bad arguments to $directoryInfo_i');
;	  0338	code = pcegop (.(.ap+1),ste_typ_int);   ! get info code
;	  0339	str = pcegop (..ap,ste_typ_str);        ! get directory name
;	  0340	
;	  0341	dirnum = dinrcd(.str);          ! get directory number
;	  0342	
;	  0343	if ..ap eql opn_tmp_str then pcefst(.str);      ! release temp string argument
;	  0344	
;	  0345	                                ! select proper jsys
;	  0346	if .code gtr 0 and .code leq $cddfe then begin
;	  0347	   local
;	  0348	      dirblk : vector [17],     ! Directory block info
;	  0349	      u_group : vector[30],     ! User group lists
;	  0350	      d_group : vector[30],
;	  0351	      sd_group : vector [30],
;	  0352	      account : vector [ch$allocation(40)];     ! account string
;	  0353	   if dingtd (.dirnum,dirblk,u_group,d_group,sd_group,account) then
;	  0354	      .dirblk[.code]
;	  0355	   else
;	  0356	      0
;	  0357	   end
;	  0358	else if .code geq $cdda1 and .code leq $cdda3 then begin
;	  0359	   register
;	  0360	      r1=1,r2=2,r3=3;
;	  0361	   r1 = .dirnum;
;	  0362	   if not jsys (-1,gtdal,r1,r2,r3) then
;	  0363	       0
;	  0364	   else if .code eql $cdda1 then .r1
;	  0365	   else if .code eql $cdda2 then .r3
;	  0366	   else if .code eql $cdda3 then .r2
;	  0367	   else 0
;	  0368	   end
;	  0369	else
;	  0370	   0
;	  0371	
;	  0372	end;


P.AAG:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","d","i"		; o $di
	BYTE	(7)"r","e","c","t","o"		; recto
	BYTE	(7)"r","y","I","n","f"		; ryInf
	BYTE	(7)"o","_","i",000,000		; o_i


U.5:
DINDII::PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,163				; SP,163
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,2				; CNT,2
	JRST	L.9				; L.9
	MOVEI	AC1,P.AAG			; AC1,P.AAG
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.9:	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC13,AC1			; CODE,AC1
	MOVE	AC14,0(AC14)			; AC14,0(AP)
	MOVE	AC1,AC14			; AC1,AC14
	MOVEI	AC2,1				; AC2,1
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC11,AC1			; STR,AC1
	PUSHJ	SP,U.7				; SP,DINRCD
	MOVE	AC12,AC1			; DIRNUM,AC1
	CAIE	AC14,-100000			; AC14,-100000
	JRST	L.10				; L.10
	MOVE	AC1,AC11			; AC1,STR
	PUSHJ	SP,PCEFST			; SP,PCEFST
L.10:	JUMPLE	AC13,L.11			; CODE,L.11
	CAILE	AC13,21				; CODE,21
	JRST	L.11				; L.11
	MOVEI	AC2,-162(SP)			; AC2,DIRBLK
	MOVEI	AC3,-141(SP)			; AC3,U_GROUP
	MOVEI	AC4,-103(SP)			; AC4,D_GROUP
	MOVEI	AC1,-45(SP)			; AC1,SD_GROUP
	PUSH	SP,AC1				; SP,AC1
	MOVEI	AC1,-10(SP)			; AC1,ACCOUNT
	PUSH	SP,AC1				; SP,AC1
	MOVE	AC1,AC12			; AC1,DIRNUM
	PUSHJ	SP,U.8				; SP,DINGTD
	ADJSP	SP,-2				; SP,-2
	TRNN	AC1,1				; AC1,1
	JRST	L.13				; L.13
	MOVEI	AC1,-162(SP)			; AC1,DIRBLK
	ADD	AC1,AC13			; AC1,CODE
	MOVE	AC1,0(AC1)			; AC1,0(AC1)
	JRST	L.14				; L.14
L.11:	CAIL	AC13,22				; CODE,22
	CAILE	AC13,24				; CODE,24
	JRST	L.13				; L.13
	MOVE	AC1,AC12			; R1,DIRNUM
	JSYS	305				; 305
	JUMP	16,L.13				; 16,L.13
	CAIN	AC13,22				; CODE,22
	JRST	L.14				; L.14
	CAIN	AC13,23				; CODE,23
	JRST	L.12				; L.12
	CAIE	AC13,24				; CODE,24
	SETZ	AC2,				; AC2,
	MOVE	AC3,AC2				; AC3,AC2
L.12:	SKIPA	AC1,AC3				; AC1,AC3
L.13:	SETZ	AC1,				; AC1,
L.14:	ADJSP	SP,-163				; SP,-163
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,

; Routine Size:  65 words


;	  0373	
;	  0374	
;	  0375	
;	  0376	GLOBAL ROUTINE dindis (ap,cnt) =        ! string procedure $directoryinfo_s
;	  0377	
;	  0378	!++
;	  0379	! Functional description:
;	  0380	! $directoryinfo_i("dirname",code)
;	  0381	! Returns string information about directory, selected by code as offset into
;	  0382	! gtdir directory block.
;	  0383	!
;	  0384	! Formal parameters:
;	  0385	! usual for pcl system procedure
;	  0386	!
;	  0387	! Implicit inputs:
;	  0388	! none
;	  0389	!
;	  0390	! Implicit outputs:
;	  0391	! none
;	  0392	!
;	  0393	! Routine Value:
;	  0394	! integer value requested
;	  0395	!
;	  0396	! Side effects:
;	  0397	! none
;	  0398	!
;	  0399	!--
;	  0400	
;	  0401	begin
;	  0402	external register z=0;
;	  0403	
;	  0404	local
;	  0405	   str : str_val,               ! directory name string value
;	  0406	   adr,                         ! temp, address of a string
;	  0407	   code,                        ! code of result needed
;	  0408	   dirnum,                      ! directory number
;	  0409	   stv : str_val,               ! string value used for returning result
;	  0410	   dirblk : vector [17],        ! Directory block info
;	  0411	   u_group : vector[30],     ! User group lists
;	  0412	   d_group : vector[30],
;	  0413	   sd_group : vector [30],
;	  0414	   account : vector [ch$allocation(40)],     ! account string
;	  0415	   sarea : vector[100];         ! result string
;	  0416	
;	  0417	if .cnt neq 2 then error ('Bad arguments to $directoryInfo_i');
;	  0418	code = pcegop (.(.ap+1),ste_typ_int);   ! get info code
;	  0419	str = pcegop (..ap,ste_typ_str);        ! get directory name
;	  0420	
;	  0421	dirnum = dinrcd(.str);          ! get directory number
;	  0422	
;	  0423	if ..ap eql opn_tmp_str then pcefst(.str);      ! release temp string argument
;	  0424	
;	  0425	if not dingtd (.dirnum,dirblk,u_group,d_group,sd_group,account) then 
;	  0426	   return (pcecst (0));           ! return empty string
;	  0427	
;	  0428	                                ! select proper jsys
;	  0429	select .code of set
;	  0430	[$cdugp]:
;	  0431	   adr = u_group;
;	  0432	[$cddgp]:
;	  0433	   adr = d_group;
;	  0434	[$cdcug]:
;	  0435	   adr = sd_group;
;	  0436	[$cdugp,$cddgp,$cdcug]: begin
;	  0437	   bind
;	  0438	      group = (.adr) : vector [30];
;	  0439	   register
;	  0440	      r1=1,r2=2,r3=3;
;	  0441	   r1 = bytptr (sarea);
;	  0442	   r3 = 10;
;	  0443	   incr i from 1 to .group[0]-1 by 1 do begin
;	  0444	      if .i gtr 1 then
;	  0445	         ch$wchar_a (%c',', r1);
;	  0446	      r2 = .group[.i];
;	  0447	      jsys (-1,nout,r1,r2,r3);
;	  0448	      end;
;	  0449	   ch$wchar (0, .r1);           ! end with null
;	  0450	   stv[stv_len] = ch$diff (.r1, bytptr(sarea));
;	  0451	   stv[stv_adr] = sarea;
;	  0452	   pcecst(.stv)
;	  0453	   end;
;	  0454	[$cddac]:       begin
;	  0455	                                ! return account string
;	  0456	   local
;	  0457	      len;
;	  0458	   len = 0;
;	  0459	   adr = ch$ptr (account);
;	  0460	   while ch$rchar_a (adr) neq 0 do len = .len + 1 ;
;	  0461	   stv[stv_len] = .len;
;	  0462	   stv[stv_adr] = account;
;	  0463	   pcecst(.stv)
;	  0464	   end;
;	  0465	[OTHERWISE]:
;	  0466	   (pcecst(0));
;	  0467	TES
;	  0468	
;	  0469	end;


P.AAH:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","d","i"		; o $di
	BYTE	(7)"r","e","c","t","o"		; recto
	BYTE	(7)"r","y","I","n","f"		; ryInf
	BYTE	(7)"o","_","i",000,000		; o_i


U.6:
DINDIS::PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,330				; SP,330
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,2				; CNT,2
	JRST	L.15				; L.15
	MOVEI	AC1,P.AAH			; AC1,P.AAH
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.15:	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVEM	AC1,0(SP)			; AC1,CODE
	MOVE	AC14,0(AC14)			; AC14,0(AP)
	MOVE	AC1,AC14			; AC1,AC14
	MOVEI	AC2,1				; AC2,1
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC10,AC1			; STR,AC1
	PUSHJ	SP,U.7				; SP,DINRCD
	MOVE	AC11,AC1			; DIRNUM,AC1
	CAIE	AC14,-100000			; AC14,-100000
	JRST	L.16				; L.16
	MOVE	AC1,AC10			; AC1,STR
	PUSHJ	SP,PCEFST			; SP,PCEFST
L.16:	MOVEI	AC2,-327(SP)			; AC2,DIRBLK
	MOVEI	AC3,-306(SP)			; AC3,U_GROUP
	MOVEI	AC4,-250(SP)			; AC4,D_GROUP
	MOVEI	AC1,-212(SP)			; AC1,SD_GROUP
	PUSH	SP,AC1				; SP,AC1
	MOVEI	AC1,-155(SP)			; AC1,ACCOUNT
	PUSH	SP,AC1				; SP,AC1
	MOVE	AC1,AC11			; AC1,DIRNUM
	PUSHJ	SP,U.8				; SP,DINGTD
	ADJSP	SP,-2				; SP,-2
	TRNE	AC1,1				; AC1,1
	JRST	L.17				; L.17
	SETZ	AC1,				; AC1,
	PUSHJ	SP,PCECST			; SP,PCECST
	JRST	L.31				; L.31
L.17:	MOVE	AC13,0(SP)			; AC13,CODE
	SETO	AC11,				; AC11,
	CAIE	AC13,13				; AC13,13
	JRST	L.18				; L.18
	SETZ	AC11,				; AC11,
	MOVEI	AC14,-306(SP)			; ADR,U_GROUP
	MOVE	AC12,AC14			; AC12,ADR
L.18:	CAIE	AC13,14				; AC13,14
	JRST	L.19				; L.19
	SETZ	AC11,				; AC11,
	MOVEI	AC14,-250(SP)			; ADR,D_GROUP
	MOVE	AC12,AC14			; AC12,ADR
L.19:	CAIE	AC13,16				; AC13,16
	JRST	L.20				; L.20
	SETZ	AC11,				; AC11,
	MOVEI	AC14,-212(SP)			; ADR,SD_GROUP
	MOVE	AC12,AC14			; AC12,ADR
L.20:	CAIGE	AC13,13				; AC13,13
	JRST	L.21				; L.21
	CAIG	AC13,14				; AC13,14
	JRST	L.22				; L.22
L.21:	CAIE	AC13,16				; AC13,16
	JRST	L.26				; L.26
L.22:	SETZ	AC11,				; AC11,
	MOVE	AC16,AC14			; AC16,ADR
	MOVEI	AC1,-144(SP)			; HLF,SAREA
	HRLI	AC1,-337100			; HLF,-337100
	MOVEI	AC3,12				; R3,12
	MOVE	AC10,0(AC16)			; AC10,0(AC16)
	SETZ	AC4,				; I,
	JRST	L.25				; L.25
L.23:	CAIG	AC4,1				; I,1
	JRST	L.24				; L.24
	MOVEI	AC5,54				; AC5,54
	IDPB	AC5,AC1				; AC5,R1
L.24:	MOVE	AC5,AC16			; AC5,AC16
	ADD	AC5,AC4				; AC5,I
	MOVE	AC2,0(AC5)			; R2,0(AC5)
	JSYS	224				; 224
	JUMP	16,L.25				; 16,L.25
L.25:	ADDI	AC4,1				; I,1
	CAMGE	AC4,AC10			; I,AC10
	JRST	L.23				; L.23
	SETZ	AC3,				; AC3,
	MOVE	AC2,AC1				; AC2,R1
	IDPB	AC3,AC2				; AC3,AC2
	PUSH	SP,AC1				; SP,R1
	MOVEI	AC1,-145(SP)			; HLF,SAREA
	HRLI	AC1,-337100			; HLF,-337100
	PUSH	SP,AC1				; SP,HLF
	PUSHJ	SP,CHDIF%			; SP,CHDIF%
	HRL	AC10,AC1			; STV,AC1
	MOVEI	AC1,-146(SP)			; AC1,SAREA
	HRR	AC10,AC1			; STV,AC1
	MOVE	AC1,AC10			; AC1,STV
	PUSHJ	SP,PCECST			; SP,PCECST
	ADJSP	SP,-2				; SP,-2
	MOVE	AC12,AC1			; AC12,AC1
L.26:	CAIE	AC13,17				; AC13,17
	JRST	L.29				; L.29
	SETZB	AC11,AC2			; AC11,LEN
	MOVEI	AC1,-155(SP)			; AC1,ACCOUNT-1
	HRLI	AC1,10700			; AC1,10700
	MOVE	AC14,AC1			; ADR,AC1
L.27:	ILDB	AC1,AC14			; AC1,ADR
	JUMPE	AC1,L.28			; AC1,L.28
	AOJA	AC2,L.27			; LEN,L.27
L.28:	HRL	AC10,AC2			; STV,LEN
	MOVEI	AC1,-154(SP)			; AC1,ACCOUNT
	HRR	AC10,AC1			; STV,AC1
	MOVE	AC1,AC10			; AC1,STV
	PUSHJ	SP,PCECST			; SP,PCECST
	MOVE	AC12,AC1			; AC12,AC1
L.29:	JUMPGE	AC11,L.30			; AC11,L.30
	SETZ	AC1,				; AC1,
	PUSHJ	SP,PCECST			; SP,PCECST
	MOVE	AC12,AC1			; AC12,AC1
L.30:	MOVE	AC1,AC12			; AC1,AC12
L.31:	ADJSP	SP,-330				; SP,-330
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,

; Routine Size:  126 words


;	  0470	
;	  0471	
;	  0472	ROUTINE DINRCD (STR)  =         ! Internal procedure doing Rcdir
;	  0473	
;	  0474	!++
;	  0475	! Functional description:
;	  0476	! Returns the directory number of directory with name in str.
;	  0477	! If no match, returns 0.
;	  0478	!
;	  0479	! Formal parameters:
;	  0480	! string value pointing to directory name.
;	  0481	!
;	  0482	! Implicit inputs:
;	  0483	! none
;	  0484	!
;	  0485	! Implicit outputs:
;	  0486	! none
;	  0487	!
;	  0488	! Routine Value:
;	  0489	! Directory number.
;	  0490	!
;	  0491	! Side effects:
;	  0492	! none
;	  0493	!
;	  0494	!--
;	  0495	
;	  0496	begin
;	  0497	
;	  0498	external register z=0;
;	  0499	register
;	  0500	    r1=1,r2=2,r3=3;
;	  0501	map
;	  0502	   str : str_val;               ! string value
;	  0503	
;	  0504	r1 = 0;
;	  0505	r2 = bytptr (.str[stv_adr]);
;	  0506	if (jsys(-1,rcdir,r1,r2,r3)) then
;	  0507	    .r3
;	  0508	else
;	  0509	    0
;	  0510	
;	  0511	end;


; DINRCD
U.7:	MOVE	AC2,AC1				; STR,AC1
	SETZ	AC1,				; R1,
	MOVEI	AC2,0(AC2)			; HLF,0(STR)
	HRLI	AC2,-337100			; HLF,-337100
	JSYS	553				; 553
	JUMP	16,L.32				; 16,L.32
	JRST	L.33				; L.33
L.32:	SETZ	AC3,				; AC3,
L.33:	MOVE	AC1,AC3				; AC1,AC3
	POPJ	SP,				; SP,

; Routine Size:  10 words


;	  0512	
;	  0513	
;	  0514	                                ! internal routine to do a gtdir
;	  0515	GLOBAL ROUTINE DINGTD 
;	  0516	(dirnum,p_dirblk,p_u_group,p_d_group,p_sd_group,p_account) =
;	  0517	
;	  0518	!++
;	  0519	! Functional description:
;	  0520	! dingtd(dirnum,p_dirblk,p_u_group,p_d_group,p_sd_group,p_account)
;	  0521	! returns in dirblk...
;	  0522	! the gtdir information for directory dirnum. Returns true for success,
;	  0523	! false for failure.
;	  0524	!
;	  0525	! Formal parameters:
;	  0526	! - directory number
;	  0527	! - address of crdir block
;	  0528	! - address of space for user-group list
;	  0529	! - address of space for directory group list
;	  0530	! - address of space for subdirectory group list
;	  0531	! - address of space for account default
;	  0532	!
;	  0533	! Implicit inputs:
;	  0534	! none
;	  0535	!
;	  0536	! Implicit outputs:
;	  0537	! none
;	  0538	!
;	  0539	! Routine Value:
;	  0540	! 1 for success, 0 for failure
;	  0541	!
;	  0542	! Side effects:
;	  0543	! none
;	  0544	!
;	  0545	!--
;	  0546	
;	  0547	begin
;	  0548	external register z =0;
;	  0549	
;	  0550	bind
;	  0551	   dirblk = (.p_dirblk) : vector[17],
;	  0552	   u_group = (.p_u_group) : vector[30],
;	  0553	   d_group = (.p_d_group) : vector[30],
;	  0554	   sd_group = (.p_sd_group) : vector[30],
;	  0555	   account = (.p_account) : vector[8];
;	  0556	
;	  0557	incr i from 0 to 17 by 1 do dirblk[.i] = 0;
;	  0558	dirblk[0] = 17;
;	  0559	dirblk[11] = u_group;
;	  0560	u_group[0] = 30;
;	  0561	dirblk[12] = d_group;
;	  0562	d_group[0] = 30;
;	  0563	dirblk[14] = sd_group;
;	  0564	sd_group[0] = 30;
;	  0565	dirblk[15] = bytptr(account);
;	  0566	                             ! do gtdir
;	  0567	begin
;	  0568	   register r1=1,r2=2,r3=3;
;	  0569	   r1 = .dirnum;
;	  0570	   r2 = dirblk;
;	  0571	   r3 = 0;
;	  0572	   jsys(-1,gtdir,r1,r2,r3)
;	  0573	   end
;	  0574	
;	  0575	end;


U.8:
DINGTD::PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,-3(SP)			; AC14,P_SD_GROUP
	SETZ	AC5,				; I,
L.34:	MOVE	AC16,AC2			; AC16,P_DIRBLK
	ADD	AC16,AC5			; AC16,I
	SETZM	0(AC16)				; 0(AC16)
	ADDI	AC5,1				; I,1
	CAIG	AC5,21				; I,21
	JRST	L.34				; L.34
	MOVEI	AC5,21				; AC5,21
	MOVEM	AC5,0(AC2)			; AC5,0(P_DIRBLK)
	MOVEM	AC3,13(AC2)			; P_U_GROUP,13(P_DIRBLK)
	MOVEI	AC5,36				; AC5,36
	MOVEM	AC5,0(AC3)			; AC5,0(P_U_GROUP)
	MOVEM	AC4,14(AC2)			; P_D_GROUP,14(P_DIRBLK)
	MOVEI	AC3,36				; AC3,36
	MOVEM	AC3,0(AC4)			; AC3,0(P_D_GROUP)
	MOVEM	AC14,16(AC2)			; AC14,16(P_DIRBLK)
	MOVEI	AC3,36				; AC3,36
	MOVEM	AC3,0(AC14)			; AC3,0(AC14)
	MOVE	AC3,-2(SP)			; HLF,P_ACCOUNT
	HRLI	AC3,-337100			; HLF,-337100
	MOVEM	AC3,17(AC2)			; HLF,17(P_DIRBLK)
	SETZB	AC3,AC4				; R3,AC4
	JSYS	241				; 241
	JUMP	16,L.35				; 16,L.35
	MOVEI	AC4,1				; AC4,1
L.35:	MOVE	AC1,AC4				; AC1,AC4
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  30 words


;	  0576	
;	  0577	
;	  0578	GLOBAL ROUTINE DINSFI (AP,CNT) : NOVALUE =        ! System procedure $FileSet
;	  0579	
;	  0580	!++
;	  0581	! Functional description:
;	  0582	!     call $fileset (fil, offset, mask, value) sets a value or a string in
;	  0583	! the Fdb of the file specified by channel (or $parse for current file).
;	  0584	!    Fil is either a channel number, or -1 for currently parsed file, or
;	  0585	! a string with the file name.
;	  0586	!
;	  0587	! Formal parameters:
;	  0588	! usual for PCL system procedure
;	  0589	!
;	  0590	! Implicit inputs:
;	  0591	! file 
;	  0592	!
;	  0593	! Implicit outputs:
;	  0594	! none
;	  0595	!
;	  0596	! Routine Value:
;	  0597	! none
;	  0598	!
;	  0599	! Side effects:
;	  0600	! none
;	  0601	!
;	  0602	!--
;	  0603	
;	  0604	begin
;	  0605	external register z=0;
;	  0606	local
;	  0607	   chn,                         ! Channel requested
;	  0608	                                ! [fun50]+ File name for $fileset
;	  0609	        chn_typ,                ! Channel argument type
;	  0610	        jfn_tmp,                ! 1 if temp jfn name
;	  0611	                                ! [fun50]-
;	  0612	   jfn,                         ! Jfn of file
;	  0613	   offset,                      ! Offest in fdb
;	  0614	   mask,                        ! Mask for fdb word
;	  0615	   value,                       ! [integer] value to set
;	  0616	   typ_value,                   ! type of value (int or str)
;	  0617	   stv : str_val,               ! String value if 4th arg is string
;	  0618	   stp,                         ! Byte pointer built from stv
;	  0619	   use;                         ! Which jsys do we need (0=none)
;	  0620	
;	  0621	literal
;	  0622	   _chfdb=1,                    ! Use Values
;	  0623	   _arcf=2,
;	  0624	   _sfust=3,
;	  0625	   _sactf=4,
;	  0626	   _sftad=5;
;	  0627	
;	  0628	if .cnt neq 4 then error ('Bad arguments to $FileSet');
;	  0629	                                ! get JFN and check it
;	  0630	                                ! [fun50]+
;	  0631	value = pcegop (.(.ap+3),ste_typ_any ; typ_value);
;	  0632	mask = pcegop(.(.ap+2),ste_typ_int);    ! mask for this word
;	  0633	offset = pcegop (.(.ap+1),ste_typ_int); ! offset in fdb
;	  0634	chn = pcegop(..ap, ste_typ_any;  chn_typ);
;	  0635	jfn = diujfn (.chn, .chn_typ ; jfn_tmp);
;	  0636	                                ! [fun50]-
;	  0637	
;	  0638	                                ! SELECT JSYS TO BE USED
;	  0639	                                ! The combination of the word offset in the fdb
;	  0640	                                ! and the mask to used defines which jsys will
;	  0641	                                ! be used.
;	  0642	
;	  0643	use = (SELECTONE .offset OF SET
;	  0644	[$FBCTL]: begin                 ! .fbctl word: chfdb or arcf
;	  0645	   if (.mask and 
;	  0646	       (not (fb_tmp or fb_prm or fb_del or fb_nod or fb_inv or fb_fcf
;	  0647	             or fb_ndl)) ) eql 0 then _chfdb
;	  0648	   else if (.mask and
;	  0649	       (not (fb_arc or fb_off)) ) eql 0 then _arcf
;	  0650	   else
;	  0651	       0
;	  0652	   end;
;	  0653	[$fbprt,$fbcre,$fbbyv,$fbsiz,$fbcrv,$fbwrt,$fbref,$fbcnt,$fbbk0,
;	  0654	 $fbusw]:
;	  0655	   (_chfdb);
;	  0656	[$fbtdt]:
;	  0657	   (_arcf);
;	  0658	[$fbaut,$fblwr]:
;	  0659	   (_sfust);
;	  0660	[$fbact]:
;	  0661	   (_sactf);
;	  0662	[$fbbbt]: begin
;	  0663	   if (.mask and 
;	  0664	       (not (ar_1st)) ) eql 0 then _chfdb
;	  0665	   else  if (.mask and
;	  0666	       (not (ar_rar or ar_riv or ar_ndl or ar_nar or ar_exm or
;	  0667	             ar_rfl or ar_wrn or ar_rsn or ar_psz)) ) eql 0 then _arcf
;	  0668	   else
;	  0669	      0
;	  0670	   end;
;	  0671	[$fbnet,$fbfet,$fbtp1,$fbss1,$fbtp2,$fbss2]:
;	  0672	   (_sftad);
;	  0673	[OTHERWISE]:
;	  0674	   (0);
;	  0675	   TES);
;	  0676	
;	  0677	if .use eql 0 then error ('Unchangeable FDB offset/mask combination')
;	  0678	else if .use eql _arcf or .use eql _sftad
;	  0679	   then error ('ARCF, SFTAD Interfaces not provided');
;	  0680	
;	  0681	                                ! GET VALUE OR STRING
;	  0682	SELECTONE .use of SET
;	  0683	[_chfdb]:
;	  0684	   if .typ_value neq ste_typ_any and
;	  0685	      .typ_value neq ste_typ_int then
;	  0686	      error ('Bad argument to $FileSet');
;	  0687	[_sfust,_sactf]: begin
;	  0688	   if .typ_value neq ste_typ_any and
;	  0689	      .typ_value neq ste_typ_str then
;	  0690	      error ('Bad argument to $FileSet');
;	  0691	   stv = .value;
;	  0692	   stp = bytptr (.stv[stv_adr]);
;	  0693	   end;
;	  0694	   TES;
;	  0695	
;	  0696	                                ! PERFORM JSYS REQUESTED
;	  0697	
;	  0698	
;	  0699	IF NOT (SELECTONE .use of SET
;	  0700	[_chfdb]: begin
;	  0701	   register r1=1,r2=2,r3=3;
;	  0702	                                ! Do not update directory right away
;	  0703	   r1 = fld(1,cf_nud) or fld(.offset,cf_dsp) or fld(.jfn,cf_jfn);
;	  0704	   r2 = .mask;
;	  0705	   r3 = .value;
;	  0706	   jsys (-1,chfdb,r1,r2,r3)
;	  0707	   end;
;	  0708	[_sfust]: begin
;	  0709	   register r1=1,r2=2;
;	  0710	   r1 = (if .offset eql $fbaut then $sfaut else
;	  0711	        if .offset eql $fblwr then $sflwr else 0) ^ 18 or .jfn; 
;	  0712	   r2 = .stp;
;	  0713	   jsys (-1,sfust,r1,r2)
;	  0714	   end;
;	  0715	[_sactf]: begin
;	  0716	   register r1=1, r2=2;
;	  0717	   r1 = .jfn;
;	  0718	   r2 = .stp;
;	  0719	   jsys (-1,sactf,r1,r2)
;	  0720	   end;
;	  0721	[OTHERWISE]:
;	  0722	   (0);
;	  0723	   TES)
;	  0724	THEN error ('Invalid $FileSet function');
;	  0725	
;	  0726	                                ! RELEASE STRING
;	  0727	if .(.ap+3) eql opn_tmp_str then pcefst(.stv);
;	  0728	                                ! [fun50]+
;	  0729	if .jfn_tmp then begin          ! Release jfn and string
;	  0730	   begin
;	  0731	      register r1=1;
;	  0732	      r1 = .jfn;
;	  0733	      jsys (-1, rljfn, r1);
;	  0734	      end;
;	  0735	   if .(.ap) eql opn_tmp_str then pcefst(.chn);
;	  0736	   end;
;	  0737	                                ! [fun50]-
;	  0738	end;


P.AAI:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","F","i"		; o $Fi
	BYTE	(7)"l","e","S","e","t"		; leSet
	BYTE	(7)000,000,000,000,000
P.AAJ:	BYTE	(7)"U","n","c","h","a"		; Uncha
	BYTE	(7)"n","g","e","a","b"		; ngeab
	BYTE	(7)"l","e"," ","F","D"		; le FD
	BYTE	(7)"B"," ","o","f","f"		; B off
	BYTE	(7)"s","e","t","/","m"		; set/m
	BYTE	(7)"a","s","k"," ","c"		; ask c
	BYTE	(7)"o","m","b","i","n"		; ombin
	BYTE	(7)"a","t","i","o","n"		; ation
	BYTE	(7)000,000,000,000,000
P.AAK:	BYTE	(7)"A","R","C","F",","		; ARCF,
	BYTE	(7)" ","S","F","T","A"		;  SFTA
	BYTE	(7)"D"," ","I","n","t"		; D Int
	BYTE	(7)"e","r","f","a","c"		; erfac
	BYTE	(7)"e","s"," ","n","o"		; es no
	BYTE	(7)"t"," ","p","r","o"		; t pro
	BYTE	(7)"v","i","d","e","d"		; vided
	BYTE	(7)000,000,000,000,000
P.AAL:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t"," ","t","o"		; nt to
	BYTE	(7)" ","$","F","i","l"		;  $Fil
	BYTE	(7)"e","S","e","t",000		; eSet
P.AAM:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t"," ","t","o"		; nt to
	BYTE	(7)" ","$","F","i","l"		;  $Fil
	BYTE	(7)"e","S","e","t",000		; eSet
P.AAN:	BYTE	(7)"I","n","v","a","l"		; Inval
	BYTE	(7)"i","d"," ","$","F"		; id $F
	BYTE	(7)"i","l","e","S","e"		; ileSe
	BYTE	(7)"t"," ","f","u","n"		; t fun
	BYTE	(7)"c","t","i","o","n"		; ction
	BYTE	(7)000,000,000,000,000


U.9:
DINSFI::PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,4				; SP,4
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,4				; CNT,4
	JRST	L.36				; L.36
	MOVEI	AC1,P.AAI			; AC1,P.AAI
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.36:	MOVE	AC1,3(AC14)			; AC1,3(AP)
	MOVEI	AC2,2				; AC2,2
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVEM	AC1,-1(SP)			; AC1,VALUE
	MOVE	AC11,AC2			; AC11,AC2
	MOVE	AC1,2(AC14)			; AC1,2(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC10,AC1			; MASK,AC1
	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC12,AC1			; OFFSET,AC1
	MOVE	AC1,0(AC14)			; AC1,0(AP)
	MOVEI	AC2,2				; AC2,2
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVEM	AC1,-3(SP)			; AC1,CHN
	PUSHJ	SP,DIUJFN			; SP,DIUJFN
	MOVEM	AC1,0(SP)			; AC1,JFN
	MOVEM	AC2,-2(SP)			; AC2,-2(SP)
	CAIE	AC12,1				; OFFSET,1
	JRST	L.37				; L.37
	TDNN	AC10,C.1			; MASK,[136720377777]
	JRST	L.43				; L.43
	TDNN	AC10,C.2			; MASK,[-120000001]
	JRST	L.45				; L.45
	JRST	L.48				; L.48
L.37:	CAIGE	AC12,4				; OFFSET,4
	JRST	L.38				; L.38
	CAIG	AC12,5				; OFFSET,5
	JRST	L.43				; L.43
L.38:	CAIGE	AC12,11				; OFFSET,11
	JRST	L.39				; L.39
	CAIG	AC12,17				; OFFSET,17
	JRST	L.43				; L.43
L.39:	CAIN	AC12,24				; OFFSET,24
	JRST	L.43				; L.43
	CAIN	AC12,31				; OFFSET,31
	JRST	L.45				; L.45
	CAIE	AC12,6				; OFFSET,6
	CAIN	AC12,30				; OFFSET,30
	JRST	L.40				; L.40
	JRST	L.41				; L.41
L.40:	MOVEI	AC13,3				; USE,3
	JRST	L.49				; L.49
L.41:	CAIE	AC12,10				; OFFSET,10
	JRST	L.42				; L.42
	MOVEI	AC13,4				; USE,4
	JRST	L.49				; L.49
L.42:	CAIE	AC12,22				; OFFSET,22
	JRST	L.46				; L.46
	TDNE	AC10,C.3			; MASK,[-4000000001]
	JRST	L.44				; L.44
L.43:	MOVEI	AC13,1				; USE,1
	JRST	L.49				; L.49
L.44:	TLNE	AC10,-373010			; MASK,-373010
	JRST	L.48				; L.48
L.45:	MOVEI	AC13,2				; USE,2
	JRST	L.49				; L.49
L.46:	CAIN	AC12,23				; OFFSET,23
	JRST	L.47				; L.47
	CAIL	AC12,32				; OFFSET,32
	CAILE	AC12,36				; OFFSET,36
	JRST	L.48				; L.48
L.47:	MOVEI	AC13,5				; USE,5
	JRST	L.49				; L.49
L.48:	SETZ	AC13,				; USE,
L.49:	JUMPN	AC13,L.50			; USE,L.50
	MOVEI	AC1,P.AAJ			; AC1,P.AAJ
	JRST	L.52				; L.52
L.50:	CAIN	AC13,2				; USE,2
	JRST	L.51				; L.51
	CAIE	AC13,5				; USE,5
	JRST	L.53				; L.53
L.51:	MOVEI	AC1,P.AAK			; AC1,P.AAK
L.52:	PUSHJ	SP,PCEERR			; SP,PCEERR
L.53:	CAIE	AC13,1				; USE,1
	JRST	L.54				; L.54
	CAIN	AC11,2				; TYP_VALUE,2
	JRST	L.56				; L.56
	JUMPE	AC11,L.56			; TYP_VALUE,L.56
	MOVEI	AC1,P.AAL			; AC1,P.AAL
	PUSHJ	SP,PCEERR			; SP,PCEERR
	JRST	L.56				; L.56
L.54:	CAIL	AC13,3				; USE,3
	CAILE	AC13,4				; USE,4
	JRST	L.56				; L.56
	CAIE	AC11,2				; TYP_VALUE,2
	CAIN	AC11,1				; TYP_VALUE,1
	JRST	L.55				; L.55
	MOVEI	AC1,P.AAM			; AC1,P.AAM
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.55:	MOVE	AC11,-1(SP)			; STV,VALUE
	MOVEI	AC1,0(AC11)			; HLF,0(STV)
	HRLI	AC1,-337100			; HLF,-337100
	MOVE	AC4,AC1				; STP,HLF
L.56:	CAIE	AC13,1				; USE,1
	JRST	L.57				; L.57
	MOVSI	AC1,0(AC12)			; AC1,0(OFFSET)
	IOR	AC1,0(SP)			; AC1,JFN
	TLO	AC1,400000			; AC1,400000
	MOVE	AC2,AC10			; R2,MASK
	MOVE	AC3,-1(SP)			; R3,VALUE
	JSYS	64				; 64
	JUMP	16,L.61				; 16,L.61
	JRST	L.62				; L.62
L.57:	CAIE	AC13,3				; USE,3
	JRST	L.60				; L.60
	CAIE	AC12,6				; OFFSET,6
	CAIE	AC12,30				; OFFSET,30
	JRST	L.58				; L.58
	MOVEI	AC1,1				; AC1,1
	JRST	L.59				; L.59
L.58:	SETZ	AC1,				; AC1,
L.59:	MOVSI	AC1,0(AC1)			; AC1,0(AC1)
	IOR	AC1,0(SP)			; AC1,JFN
	MOVE	AC2,AC4				; R2,STP
	JSYS	551				; 551
	JUMP	16,L.61				; 16,L.61
	JRST	L.62				; L.62
L.60:	CAIE	AC13,4				; USE,4
	JRST	L.61				; L.61
	MOVE	AC1,0(SP)			; R1,JFN
	MOVE	AC2,AC4				; R2,STP
	JSYS	62				; 62
	JUMP	16,L.61				; 16,L.61
	JRST	L.62				; L.62
L.61:	MOVEI	AC1,P.AAN			; AC1,P.AAN
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.62:	MOVEI	AC1,-100000			; AC1,-100000
	CAME	AC1,3(AC14)			; AC1,3(AP)
	JRST	L.63				; L.63
	MOVE	AC1,AC11			; AC1,STV
	PUSHJ	SP,PCEFST			; SP,PCEFST
L.63:	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,-2(SP)			; AC1,JFN_TMP
	JRST	L.65				; L.65
	MOVE	AC1,0(SP)			; R1,JFN
	JSYS	23				; 23
	JUMP	16,L.64				; 16,L.64
L.64:	MOVEI	AC1,-100000			; AC1,-100000
	CAME	AC1,0(AC14)			; AC1,0(AP)
	JRST	L.65				; L.65
	MOVE	AC1,-3(SP)			; AC1,CHN
	PUSHJ	SP,PCEFST			; SP,PCEFST
L.65:	ADJSP	SP,-4				; SP,-4
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,
C.1:	EXP	136720377777			; 136720377777
C.2:	EXP	-120000001			; -120000001
C.3:	EXP	-4000000001			; -4000000001

; Routine Size:  166 words


;	  0739	
;	  0740	
;	  0741	GLOBAL ROUTINE DINXAT =                ! system variable $xatom
;	  0742	
;	  0743	!++
;	  0744	! Functional description:
;	  0745	!	Return current contents of atom buffer as string variable.
;	  0746	!
;	  0747	! Formal parameters:
;	  0748	!	None
;	  0749	!
;	  0750	! Implicit inputs:
;	  0751	!	ATMBUF
;	  0752	!
;	  0753	! Implicit outputs:
;	  0754	!	none
;	  0755	!
;	  0756	! Routine value:
;	  0757	!	string value of current parse atom (atmbuf in exec)
;	  0758	!
;	  0759	! Side effects:
;	  0760	!	None
;	  0761	!
;	  0762	!--
;	  0763	
;	  0764	    begin
;	  0765	    external register z=0;
;	  0766	    local
;	  0767	        val : str_val,          ! string value generated
;	  0768		cnt,			! character count
;	  0769		ptr;			! string pointer
;	  0770	    cnt = 0;                    ! count length of atom
;	  0771	    ptr = bytptr(atmbuf);
;	  0772	    while ch$rchar_a(ptr) neq $chnul do cnt = .cnt + 1;
;	  0773	    val = pceast (.cnt);        ! allocate storage and copy
;	  0774	    ch$copy (.cnt, bytptr(atmbuf), $chnul, .cnt+1, bytptr(.val[stv_adr]));
;	  0775	    .val
;	  0776	    end;


U.10:
DINXAT::PUSH	SP,AC14				; SP,AC14
	SETZ	AC14,				; CNT,
	MOVEI	AC1,ATMBUF			; HLF,ATMBUF
	HRLI	AC1,-337100			; HLF,-337100
	MOVE	AC2,AC1				; PTR,HLF
L.66:	ILDB	AC1,AC2				; AC1,PTR
	JUMPE	AC1,L.67			; AC1,L.67
	AOJA	AC14,L.66			; CNT,L.66
L.67:	MOVE	AC1,AC14			; AC1,CNT
	PUSHJ	SP,PCEAST			; SP,PCEAST
	MOVE	AC16,AC1			; VAL,AC1
	MOVEI	AC2,ATMBUF			; HLF,ATMBUF
	HRLI	AC2,-337100			; HLF,-337100
	MOVE	AC3,AC14			; AC3,CNT
	ADDI	AC3,1				; AC3,1
	MOVEI	AC5,0(AC16)			; HLF,0(VAL)
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,AC14			; AC1,CNT
	MOVE	AC4,AC3				; AC4,AC3
	EXTEND	AC1,C.4				; AC1,C.4
	JFCL					; 
	MOVE	AC1,AC16			; AC1,VAL
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,
C.4:	MOVSLJ					; 
	EXP	0				; 0

; Routine Size:  26 words


;	  0777	
;	  0778	GLOBAL ROUTINE DINCMD =                ! system variable $command
;	  0779	
;	  0780	!++
;	  0781	! Functional description:
;	  0782	!	Return current contents of command buffer
;	  0783	!
;	  0784	! Formal parameters:
;	  0785	!	None
;	  0786	!
;	  0787	! Implicit inputs:
;	  0788	!	CBUF
;	  0789	!
;	  0790	! Implicit outputs:
;	  0791	!	none
;	  0792	!
;	  0793	! Routine value:
;	  0794	!	string value of command buffer
;	  0795	!
;	  0796	! Side effects:
;	  0797	!	None
;	  0798	!
;	  0799	!--
;	  0800	
;	  0801	    begin
;	  0802	    external register z=0;
;	  0803	    local
;	  0804	        val : str_val,          ! string value returned
;	  0805		cnt;			! character count
;	  0806	    cnt = ch$diff (.sblock[$cmptr], ch$ptr(cbuf));
;	  0807	    val = pceast(.cnt);         ! allocate storage
;	  0808	    ch$copy (.cnt, ch$ptr(cbuf), $chnul, .cnt+1, bytptr(.val[stv_adr]));
;	  0809	    .val
;	  0810	    end;


U.11:
DINCMD::PUSH	SP,AC14				; SP,AC14
	PUSH	SP,SBLOCK+4			; SP,SBLOCK+4
	PUSH	SP,C.5				; SP,[POINT 7,CBUF-1,34]  <1,7>
	PUSHJ	SP,CHDIF%			; SP,CHDIF%
	MOVE	AC14,AC1			; CNT,AC1
	PUSHJ	SP,PCEAST			; SP,PCEAST
	MOVE	AC16,AC1			; VAL,AC1
	MOVE	AC3,AC14			; AC3,CNT
	ADDI	AC3,1				; AC3,1
	MOVEI	AC5,0(AC16)			; HLF,0(VAL)
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,AC14			; AC1,CNT
	MOVE	AC2,C.5				; AC2,[POINT 7,CBUF-1,34]  <1,7>
	MOVE	AC4,AC3				; AC4,AC3
	EXTEND	AC1,C.4				; AC1,C.4
	JFCL					; 
	ADJSP	SP,-2				; SP,-2
	MOVE	AC1,AC16			; AC1,VAL
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,
C.5:	POINT	7,CBUF-1,34			; 7,CBUF-1,34

; Routine Size:  21 words


;	  0811	                                ! [fun36]- Parse: $Xatom, $Command
;	  0812	
;	  0813	                                ! [fun38]+ $termlength          
;	  0814	
;	  0815	GLOBAL ROUTINE DIVTLN =		! Internal variable $TERMLENGTH
;	  0816	
;	  0817	!++
;	  0818	! Functional description:
;	  0819	!	Return length of controlling terminal
;	  0820	!
;	  0821	! Formal parameters:
;	  0822	!	None
;	  0823	!
;	  0824	! Implicit inputs:
;	  0825	!	None
;	  0826	!
;	  0827	! Implicit outputs:
;	  0828	!	None
;	  0829	!
;	  0830	! Routine value:
;	  0831	!	Length
;	  0832	!
;	  0833	! Side effects:
;	  0834	!	None
;	  0835	!
;	  0836	!--
;	  0837	
;	  0838	    begin
;	  0839	    register r1=1,r2=2,r3=3;
;	  0840	    r1 = $cttrm;
;	  0841	    r2 = $morll;
;	  0842	    jsys(0,mtopr,r1,r2,r3);
;	  0843	    .r3
;	  0844	    end;


U.12:
DIVTLN::MOVEI	AC1,-1				; R1,-1
	MOVEI	AC2,32				; R2,32
	JSYS	77				; 77
	MOVE	AC1,AC3				; AC1,R3
	POPJ	SP,				; SP,

; Routine Size:  5 words


;	  0845	                                ! [fun38]- $termlength          
;	  0846	
;	  0847	                                ! [fun39]+ Jsys Interface
;	  0848	
;	  0849	GLOBAL ROUTINE DINGMM (AP,CNT) =        ! system procedure $get_mem
;	  0850	
;	  0851	!++
;	  0852	! Functional description:
;	  0853	!       int = $get_mem (12)
;	  0854	! acquires 12 words in dynamic string space and returns the address of
;	  0855	! the first location.
;	  0856	!
;	  0857	! Formal parameters:
;	  0858	! Usual for system procedure
;	  0859	!
;	  0860	! Implicit inputs:
;	  0861	! free string space (pcsfre)
;	  0862	!
;	  0863	! Implicit outputs:
;	  0864	! free string space (pcsfre)
;	  0865	!
;	  0866	! Routine Value:
;	  0867	! location of block of memory acquired
;	  0868	!
;	  0869	! Side effects:
;	  0870	! none
;	  0871	!
;	  0872	!--
;	  0873	
;	  0874	begin
;	  0875	external register z=0;
;	  0876	local
;	  0877	   len,                         ! length of block requested
;	  0878	   adr;                         ! address of block acquired
;	  0879	
;	  0880	if .cnt neq 1 then
;	  0881	   error ('Bad argument to $get_mem');
;	  0882	if .len lss 0 then
;	  0883	   error ('$get_mem requests negative # of words');
;	  0884	len = pcegop(.(.ap),ste_typ_int);
;	  0885	adr = pcmgmm(.len, pcsfre);
;	  0886	incra i from .adr to .adr+.len-1 do
;	  0887	   .i = 0;
;	  0888	.adr
;	  0889	end;


P.AAO:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t"," ","t","o"		; nt to
	BYTE	(7)" ","$","g","e","t"		;  $get
	BYTE	(7)"_","m","e","m",000		; _mem
P.AAP:	BYTE	(7)"$","g","e","t","_"		; $get_
	BYTE	(7)"m","e","m"," ","r"		; mem r
	BYTE	(7)"e","q","u","e","s"		; eques
	BYTE	(7)"t","s"," ","n","e"		; ts ne
	BYTE	(7)"g","a","t","i","v"		; gativ
	BYTE	(7)"e"," ","#"," ","o"		; e # o
	BYTE	(7)"f"," ","w","o","r"		; f wor
	BYTE	(7)"d","s",000,000,000		; ds


U.13:
DINGMM::PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,1				; CNT,1
	JRST	L.68				; L.68
	MOVEI	AC1,P.AAO			; AC1,P.AAO
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.68:	JUMPGE	AC13,L.69			; LEN,L.69
	MOVEI	AC1,P.AAP			; AC1,P.AAP
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.69:	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC13,AC1			; LEN,AC1
	MOVEI	AC2,PCSFRE			; AC2,PCSFRE
	PUSHJ	SP,PCMGMM			; SP,PCMGMM
	MOVE	AC2,AC1				; ADR,AC1
	ADD	AC1,AC13			; AC1,LEN
	MOVE	AC3,AC1				; AC3,AC1
	SUBI	AC3,1				; AC3,1
	MOVE	AC1,AC2				; I,ADR
	JRST	L.71				; L.71
L.70:	SETZM	0(AC1)				; 0(I)
	ADDI	AC1,1				; I,1
L.71:	CAMG	AC1,AC3				; I,AC3
	JRST	L.70				; L.70
	MOVE	AC1,AC2				; AC1,ADR
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  30 words


;	  0890	
;	  0891	
;	  0892	GLOBAL ROUTINE DINRMM (AP,CNT) : novalue =      ! procedure $ret_mem
;	  0893	
;	  0894	!++
;	  0895	! Functional description:
;	  0896	!       call $ret_mem (location,12)
;	  0897	! returns a block of 12 words starting at "location" (acquired by
;	  0898	! location = $get_mem (12)).
;	  0899	!
;	  0900	! Formal parameters:
;	  0901	! Usual for system procedure
;	  0902	!
;	  0903	! Implicit inputs:
;	  0904	! free string space (pcsfre)
;	  0905	!
;	  0906	! Implicit outputs:
;	  0907	! free string space (pcsfre)
;	  0908	!
;	  0909	! Routine Value:
;	  0910	! none
;	  0911	!
;	  0912	! Side effects:
;	  0913	! none
;	  0914	!
;	  0915	!--
;	  0916	
;	  0917	begin
;	  0918	external register z=0;
;	  0919	
;	  0920	if .cnt neq 2 then
;	  0921	   error ('Bad arguments to $ret_mem');
;	  0922	                                ! [fun62]+
;	  0923	retmem ( pcegop (.(.ap+1),ste_typ_int),
;	  0924	         pcegop(.(.ap),ste_typ_int),
;	  0925	         pcsfre);
;	  0926	                                ! [fun62]-
;	  0927	end;


P.AAQ:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","r","e"		; o $re
	BYTE	(7)"t","_","m","e","m"		; t_mem
	BYTE	(7)000,000,000,000,000


U.14:
DINRMM::PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,2				; CNT,2
	JRST	L.72				; L.72
	MOVEI	AC1,P.AAQ			; AC1,P.AAQ
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.72:	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC13,AC1			; AC13,AC1
	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC2,AC1				; AC2,AC1
	MOVE	AC1,AC13			; AC1,AC13
	MOVEI	AC3,PCSFRE			; AC3,PCSFRE
	PUSHJ	SP,RETMEM			; SP,RETMEM
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  21 words


;	  0928	
;	  0929	
;	  0930	GLOBAL ROUTINE DINIPM (AP,CNT) : NOVALUE =      ! system procedure $iput
;	  0931	
;	  0932	!++
;	  0933	! Functional description:
;	  0934	!       call $iput (value, location [,index [,count]])
;	  0935	! sets the addresses (location+index) thru (location+index+count-1) to
;	  0936	! the integer "value". This is used to set addresses acquired thru $get_mem
;	  0937	!   index defaults to 0
;	  0938	!   count defaults to 1
;	  0939	!
;	  0940	! Formal parameters:
;	  0941	! Usual for system procedure
;	  0942	!
;	  0943	! Implicit inputs:
;	  0944	! none
;	  0945	!
;	  0946	! Implicit outputs:
;	  0947	! none
;	  0948	!
;	  0949	! Routine Value:
;	  0950	! none
;	  0951	!
;	  0952	! Side effects:
;	  0953	! none
;	  0954	!
;	  0955	!--
;	  0956	
;	  0957	begin
;	  0958	external register z=0;
;	  0959	local
;	  0960	   index,                       ! integer offset from location
;	  0961	   top,                         ! offset of highest location to set
;	  0962	                                ! relative to base address + index
;	  0963	   value,                       ! value to set
;	  0964	   base;                        ! address (location+index)
;	  0965	if .cnt lss 2 or .cnt gtr 4 then error ('Bad arguments to $iput');
;	  0966	index = 0;
;	  0967	top = 0;
;	  0968	if .cnt eql 4 then begin
;	  0969	   top = pcegop (.(.ap+3),ste_typ_int) - 1;
;	  0970	   if .top lss 0 then top = 0;
;	  0971	   end;
;	  0972	if .cnt geq 3 then begin
;	  0973	   index = pcegop (.(.ap+2),ste_typ_int);
;	  0974	   if .index lss 0 then index = 0;
;	  0975	   end;
;	  0976	base = pcegop (.(.ap+1),ste_typ_int) + .index;
;	  0977	value = pcegop (.(.ap),ste_typ_int);
;	  0978	incra loc from .base to .base+.top do
;	  0979	   .loc = .value;
;	  0980	
;	  0981	end;


P.AAR:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","i","p"		; o $ip
	BYTE	(7)"u","t",000,000,000		; ut


U.15:
DINIPM::PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC13,AC2			; CNT,AC2
	MOVE	AC14,AC1			; AP,AC1
	CAIGE	AC13,2				; CNT,2
	JRST	L.73				; L.73
	CAIG	AC13,4				; CNT,4
	JRST	L.74				; L.74
L.73:	MOVEI	AC1,P.AAR			; AC1,P.AAR
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.74:	SETZB	AC11,AC12			; INDEX,TOP
	CAIE	AC13,4				; CNT,4
	JRST	L.75				; L.75
	MOVE	AC1,3(AC14)			; AC1,3(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC12,AC1			; TOP,AC1
	SOJGE	AC12,L.75			; TOP,L.75
	SETZ	AC12,				; TOP,
L.75:	CAIGE	AC13,3				; CNT,3
	JRST	L.76				; L.76
	MOVE	AC1,2(AC14)			; AC1,2(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	SKIPGE	AC11,AC1			; INDEX,AC1
	SETZ	AC11,				; INDEX,
L.76:	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC13,AC1			; BASE,AC1
	ADD	AC13,AC11			; BASE,INDEX
	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC3,AC13			; AC3,BASE
	ADD	AC3,AC12			; AC3,TOP
	MOVE	AC2,AC13			; LOC,BASE
	JRST	L.78				; L.78
L.77:	MOVEM	AC1,0(AC2)			; VALUE,0(LOC)
	ADDI	AC2,1				; LOC,1
L.78:	CAMG	AC2,AC3				; LOC,AC3
	JRST	L.77				; L.77
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,

; Routine Size:  49 words


;	  0982	
;	  0983	GLOBAL ROUTINE DINIGM (AP,CNT) =        ! integer procedure $iget
;	  0984	
;	  0985	!++
;	  0986	! Functional description:
;	  0987	!       int = $iget (location [,index])
;	  0988	! Returns the value stored at location(index). Index is expressed with
;	  0989	! zero base.
;	  0990	!    index defaults to 0
;	  0991	!
;	  0992	! Formal parameters:
;	  0993	! Usual for system procedure
;	  0994	!
;	  0995	! Implicit inputs:
;	  0996	! none
;	  0997	!
;	  0998	! Implicit outputs:
;	  0999	! none
;	  1000	!
;	  1001	! Routine Value:
;	  1002	! Integer value at location(index)
;	  1003	!
;	  1004	! Side effects:
;	  1005	! none
;	  1006	!
;	  1007	!--
;	  1008	
;	  1009	begin
;	  1010	external register z=0;
;	  1011	local
;	  1012	   index;                       ! offset from location
;	  1013	if .cnt eql 1 then
;	  1014	   index = 0
;	  1015	else if .cnt eql 2 then begin
;	  1016	   index = pcegop(.(.ap+1),ste_typ_int);
;	  1017	   if .index lss 0 then index = 0;
;	  1018	   end
;	  1019	else
;	  1020	   error ('Bad arguments to $iget');
;	  1021	.(pcegop(.(.ap),ste_typ_int) + .index)
;	  1022	
;	  1023	end;


P.AAS:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","i","g"		; o $ig
	BYTE	(7)"e","t",000,000,000		; et


U.16:
DINIGM::PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,1				; CNT,1
	JRST	L.79				; L.79
	CAIE	AC2,2				; CNT,2
	JRST	L.80				; L.80
	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC13,AC1			; INDEX,AC1
	JUMPGE	AC13,L.81			; INDEX,L.81
L.79:	SETZ	AC13,				; INDEX,
	JRST	L.81				; L.81
L.80:	MOVEI	AC1,P.AAS			; AC1,P.AAS
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.81:	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	ADD	AC1,AC13			; AC1,INDEX
	MOVE	AC1,0(AC1)			; AC1,0(AC1)
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  24 words


;	  1024	
;	  1025	GLOBAL ROUTINE DINSPM (AP,CNT) : NOVALUE =      ! procedure $sput
;	  1026	
;	  1027	!++
;	  1028	! Functional description:
;	  1029	!       call $sput (string, location [,index [,charpos]])
;	  1030	! Stores the asciz string "string" starting at the character in char
;	  1031	! position "charpos" (counted from 0) at loaction(index)
;	  1032	!
;	  1033	! Formal parameters:
;	  1034	! Usual for system procedure
;	  1035	!
;	  1036	! Implicit inputs:
;	  1037	! none
;	  1038	!
;	  1039	! Implicit outputs:
;	  1040	! none
;	  1041	!
;	  1042	! Routine Value:
;	  1043	! none
;	  1044	!
;	  1045	! Side effects:
;	  1046	! none
;	  1047	!
;	  1048	!--
;	  1049	
;	  1050	begin
;	  1051	external register z=0;
;	  1052	local
;	  1053	   str : str_val,               ! string vaslue of source
;	  1054	   ptr,                         ! char ptr to destination
;	  1055	   index,                       ! index relative to base location
;	  1056	   charpos;                     ! character position relative to
;	  1057	                                ! location(index)
;	  1058	
;	  1059	if .cnt lss 2 or .cnt gtr 4 then error ('Bad arguments to $sput');
;	  1060	index = 0;
;	  1061	charpos = 0;
;	  1062	if .cnt eql 4 then begin
;	  1063	   charpos = pcegop (.(.ap+3),ste_typ_int);
;	  1064	   if .charpos lss 0 then charpos = 0;
;	  1065	   end;
;	  1066	if .cnt geq 3 then begin
;	  1067	   index = pcegop (.(.ap+2),ste_typ_int);
;	  1068	   if .index lss 0 then index = 0;
;	  1069	   end;
;	  1070	ptr = ch$ptr (pcegop(.(.ap+1),ste_typ_int) + .index, .charpos);
;	  1071	str = pcegop (.(.ap),ste_typ_str);      ! Source ptr
;	  1072	ch$copy (.str[stv_len], ch$ptr(.str[stv_adr]), $chnul,
;	  1073	         .str[stv_len]+1, .ptr);
;	  1074	if .(.ap) eql opn_tmp_str then pcefst(.str);
;	  1075	
;	  1076	
;	  1077	end;


P.AAT:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","s","p"		; o $sp
	BYTE	(7)"u","t",000,000,000		; ut


U.17:
DINSPM::PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC13,AC2			; CNT,AC2
	MOVE	AC14,AC1			; AP,AC1
	CAIGE	AC13,2				; CNT,2
	JRST	L.82				; L.82
	CAIG	AC13,4				; CNT,4
	JRST	L.83				; L.83
L.82:	MOVEI	AC1,P.AAT			; AC1,P.AAT
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.83:	SETZB	AC12,AC11			; INDEX,CHARPOS
	CAIE	AC13,4				; CNT,4
	JRST	L.84				; L.84
	MOVE	AC1,3(AC14)			; AC1,3(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	SKIPGE	AC11,AC1			; CHARPOS,AC1
	SETZ	AC11,				; CHARPOS,
L.84:	CAIGE	AC13,3				; CNT,3
	JRST	L.85				; L.85
	MOVE	AC1,2(AC14)			; AC1,2(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	SKIPGE	AC12,AC1			; INDEX,AC1
	SETZ	AC12,				; INDEX,
L.85:	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	ADD	AC1,AC12			; AC1,INDEX
	MOVEI	AC2,0(AC1)			; AC2,0(AC1)
	HRLI	AC2,-337100			; AC2,-337100
	MOVE	AC5,AC11			; AC5,CHARPOS
	ADJBP	AC5,AC2				; AC5,AC2
	MOVE	AC13,AC5			; PTR,AC5
	MOVE	AC11,0(AC14)			; AC11,0(AP)
	MOVE	AC1,AC11			; AC1,AC11
	MOVEI	AC2,1				; AC2,1
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC3,AC1				; STR,AC1
	MOVEI	AC1,0(AC3)			; AC1,0(STR)
	MOVEI	AC2,-1(AC1)			; AC2,-1(AC1)
	HRLI	AC2,10700			; AC2,10700
	HLRZ	AC4,AC3				; AC4,STR
	ADDI	AC4,1				; AC4,1
	HLRZ	AC1,AC3				; AC1,STR
	MOVE	AC5,AC13			; AC5,PTR
	EXTEND	AC1,C.4				; AC1,C.4
	JFCL					; 
	CAIE	AC11,-100000			; AC11,-100000
	JRST	L.86				; L.86
	MOVE	AC1,AC3				; AC1,STR
	PUSHJ	SP,PCEFST			; SP,PCEFST
L.86:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,

; Routine Size:  59 words


;	  1078	
;	  1079	GLOBAL ROUTINE DINSGM (AP,CNT) =        ! string procedure $sget
;	  1080	
;	  1081	!++
;	  1082	! Functional description:
;	  1083	!       str = $sget (location [,index [,charpos]])
;	  1084	! returns the asciz string stored at location(index) + "charpos" characters
;	  1085	!
;	  1086	! Formal parameters:
;	  1087	! Usual for system procedure
;	  1088	!
;	  1089	! Implicit inputs:
;	  1090	! none
;	  1091	!
;	  1092	! Implicit outputs:
;	  1093	! none
;	  1094	!
;	  1095	! Routine Value:
;	  1096	! string value of newly consed asciz string
;	  1097	!
;	  1098	! Side effects:
;	  1099	! none
;	  1100	!
;	  1101	!--
;	  1102	
;	  1103	begin
;	  1104	external register z=0;
;	  1105	local
;	  1106	   len,                         ! length of string (excluding final
;	  1107	                                ! null)
;	  1108	   ptr,ptr1,                    ! char pointers
;	  1109	   index,charpos,               ! word and character offsets
;	  1110	   str: str_val;                ! string value for returned string
;	  1111	
;	  1112	if .cnt lss 1 or .cnt gtr 3 then error ('Bad arguments to $sget');
;	  1113	index = 0;
;	  1114	charpos = 0;
;	  1115	if .cnt eql 3 then begin
;	  1116	   charpos = pcegop (.(.ap+2),ste_typ_int);
;	  1117	   if .charpos lss 0 then charpos = 0;
;	  1118	   end;
;	  1119	if .cnt geq 2 then begin
;	  1120	   index = pcegop(.(.ap+1),ste_typ_int);
;	  1121	   if .index lss 0 then index = 0;
;	  1122	   end;
;	  1123	                                ! make ptr to location(index) + charpos chars
;	  1124	ptr1 = ptr = ch$ptr (pcegop(.(.ap),ste_typ_int) + .index, .charpos);
;	  1125	len = 0;                        ! len = length (excluding final null)
;	  1126	while ch$rchar_a(ptr1) neq $chnul do len = .len + 1;
;	  1127	str = pceast (.len);
;	  1128	ch$copy (.len, .ptr, $chnul, .len+1, ch$ptr(.str[stv_adr]));
;	  1129	.str
;	  1130	
;	  1131	end;


P.AAU:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","s","g"		; o $sg
	BYTE	(7)"e","t",000,000,000		; et


U.18:
DINSGM::PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC13,AC2			; CNT,AC2
	MOVE	AC14,AC1			; AP,AC1
	JUMPLE	AC13,L.87			; CNT,L.87
	CAIG	AC13,3				; CNT,3
	JRST	L.88				; L.88
L.87:	MOVEI	AC1,P.AAU			; AC1,P.AAU
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.88:	SETZB	AC12,AC11			; INDEX,CHARPOS
	CAIE	AC13,3				; CNT,3
	JRST	L.89				; L.89
	MOVE	AC1,2(AC14)			; AC1,2(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	SKIPGE	AC11,AC1			; CHARPOS,AC1
	SETZ	AC11,				; CHARPOS,
L.89:	CAIGE	AC13,2				; CNT,2
	JRST	L.90				; L.90
	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	SKIPGE	AC12,AC1			; INDEX,AC1
	SETZ	AC12,				; INDEX,
L.90:	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	ADD	AC1,AC12			; AC1,INDEX
	MOVEI	AC3,0(AC1)			; AC3,0(AC1)
	HRLI	AC3,-337100			; AC3,-337100
	MOVE	AC2,AC11			; AC2,CHARPOS
	ADJBP	AC2,AC3				; AC2,AC3
	MOVE	AC14,AC2			; PTR,AC2
	SETZ	AC13,				; LEN,
L.91:	ILDB	AC1,AC2				; AC1,PTR1
	JUMPE	AC1,L.92			; AC1,L.92
	AOJA	AC13,L.91			; LEN,L.91
L.92:	MOVE	AC1,AC13			; AC1,LEN
	PUSHJ	SP,PCEAST			; SP,PCEAST
	MOVE	AC11,AC1			; STR,AC1
	MOVE	AC3,AC13			; AC3,LEN
	ADDI	AC3,1				; AC3,1
	MOVEI	AC1,0(AC11)			; AC1,0(STR)
	MOVEI	AC5,-1(AC1)			; AC5,-1(AC1)
	HRLI	AC5,10700			; AC5,10700
	MOVE	AC1,AC13			; AC1,LEN
	MOVE	AC2,AC14			; AC2,PTR
	MOVE	AC4,AC3				; AC4,AC3
	EXTEND	AC1,C.4				; AC1,C.4
	JFCL					; 
	MOVE	AC1,AC11			; AC1,STR
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,

; Routine Size:  58 words


;	  1132	
;	  1133	GLOBAL ROUTINE DINJFC (AP,CNT) =        ! integer procedure $jfn
;	  1134	
;	  1135	!++
;	  1136	! Functional description:
;	  1137	!       int = $jfn (channel)
;	  1138	! If "channel" is a channel, return the jfn associated with it.
;	  1139	! If "channel" is < 0 return the Indexable File Handle associated with
;	  1140	! the parse: if the parse specified "wild" the flag bits are returned
;	  1141	! in the left half, and the jfn in the right half.
;	  1142	!
;	  1143	! Formal parameters:
;	  1144	! Usual for system procedure
;	  1145	!
;	  1146	! Implicit inputs:
;	  1147	! parse file list
;	  1148	!
;	  1149	! Implicit outputs:
;	  1150	! none
;	  1151	!
;	  1152	! Routine Value:
;	  1153	! jfn
;	  1154	!
;	  1155	! Side effects:
;	  1156	! none
;	  1157	!
;	  1158	!--
;	  1159	
;	  1160	begin
;	  1161	external register z=0;
;	  1162	local
;	  1163	   fil,                         ! channel number
;	  1164	   jfn;                         ! the jfn
;	  1165	
;	  1166	if .cnt neq 1 then error ('Bad argument to $jfn');
;	  1167	fil = pcegop(.(.ap),ste_typ_int);
;	  1168	jfn = 0;
;	  1169	if .fil lss 0
;	  1170	then
;	  1171	    begin
;	  1172	    local
;	  1173	        lst: ref jls_wrd,	! parsed jfn list
;	  1174	        hlf: hlf_wrd;
;	  1175	    lst = .pccurc[ecb_pfl];
;	  1176	    if .lst neq 0
;	  1177	    then
;	  1178	        if .lst[jls_wld]
;	  1179	        then
;	  1180	            jfn = .lst[jls_jfn]
;	  1181	        else
;	  1182	            begin
;	  1183	            hlf = .lst[jls_jfn];
;	  1184	            jfn = .hlf[hlf_rgt]
;	  1185	            end
;	  1186	    end
;	  1187	else
;	  1188	    begin
;	  1189	    local
;	  1190	        ent: ref rcl_wrd;
;	  1191	    ent = .pccurc[ecb_rcl];
;	  1192	    while .ent neq 0 do
;	  1193	        if .ent[rcl_chn] eql .fil then exitloop else ent = .ent[rcl_nxt];
;	  1194	    if .ent neq 0 then jfn = .ent[rcl_jfn]
;	  1195	    end;
;	  1196	if .jfn eql 0 then error('requested file channel not in use');
;	  1197	.jfn
;	  1198	
;	  1199	end;


P.AAV:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t"," ","t","o"		; nt to
	BYTE	(7)" ","$","j","f","n"		;  $jfn
	BYTE	(7)000,000,000,000,000
P.AAW:	BYTE	(7)"r","e","q","u","e"		; reque
	BYTE	(7)"s","t","e","d"," "		; sted
	BYTE	(7)"f","i","l","e"," "		; file
	BYTE	(7)"c","h","a","n","n"		; chann
	BYTE	(7)"e","l"," ","n","o"		; el no
	BYTE	(7)"t"," ","i","n"," "		; t in
	BYTE	(7)"u","s","e",000,000		; use


U.19:
DINJFC::PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,1				; CNT,1
	JRST	L.93				; L.93
	MOVEI	AC1,P.AAV			; AC1,P.AAV
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.93:	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	SETZ	AC14,				; JFN,
	MOVE	AC2,PCCURC			; AC2,PCCURC
	JUMPGE	AC1,L.95			; FIL,L.95
	HRRZ	AC2,10(AC2)			; LST,10(AC2)
	JUMPE	AC2,L.98			; LST,L.98
	MOVE	AC3,AC2				; AC3,LST
	ADDI	AC3,1				; AC3,1
	SKIPL	0(AC2)				; 0(LST)
	JRST	L.94				; L.94
	MOVE	AC14,0(AC3)			; JFN,0(AC3)
	JRST	L.98				; L.98
L.94:	MOVE	AC2,0(AC3)			; HLF,0(AC3)
	MOVEI	AC14,0(AC2)			; JFN,0(HLF)
	JRST	L.98				; L.98
L.95:	HLRZ	AC2,7(AC2)			; ENT,7(AC2)
L.96:	JUMPE	AC2,L.98			; ENT,L.98
	HRRZ	AC3,0(AC2)			; AC3,0(ENT)
	CAMN	AC3,AC1				; AC3,FIL
	JRST	L.97				; L.97
	HLRZ	AC2,0(AC2)			; ENT,0(ENT)
	JRST	L.96				; L.96
L.97:	JUMPE	AC2,L.98			; ENT,L.98
	HRRZ	AC14,1(AC2)			; JFN,1(ENT)
L.98:	JUMPN	AC14,L.99			; JFN,L.99
	MOVEI	AC1,P.AAW			; AC1,P.AAW
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.99:	MOVE	AC1,AC14			; AC1,JFN
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  38 words


;	  1200	
;	  1201	GLOBAL ROUTINE DINJS0 (AP,CNT) =        ! integer procedure $jsys
;	  1202	
;	  1203	!++
;	  1204	! Functional description:
;	  1205	!    int = $jsys(jsys [,ac1 [,ac2 [,ac3[,ac4]]]])
;	  1206	! returns 1 for success, and 0 for failure
;	  1207	!
;	  1208	! Formal parameters:
;	  1209	! Usual for system procedure
;	  1210	!
;	  1211	! Implicit inputs:
;	  1212	! none
;	  1213	!
;	  1214	! Implicit outputs:
;	  1215	! Variables $reg1 to $reg4 are set to contain the ac's after the jsys
;	  1216	! Variable $jsysok is set to 1 for success, 0 for failure
;	  1217	!
;	  1218	! Routine Value:
;	  1219	! success indicator (1=success, 0=failure)
;	  1220	!
;	  1221	! Side effects:
;	  1222	! none
;	  1223	!
;	  1224	!--
;	  1225	
;	  1226	begin
;	  1227	external register z=0;
;	  1228	dinjsx (.ap, .cnt)
;	  1229	end;


U.20:
DINJS0::JRST	U.22				; DINJSX

; Routine Size:  1 word


;	  1230	
;	  1231	GLOBAL ROUTINE DINJS1 (AP,CNT) : NOVALUE =      ! integer procedure $jsys
;	  1232	
;	  1233	!++
;	  1234	! Functional description:
;	  1235	!    call $jsys(jsys [,ac1 [,ac2 [,ac3[,ac4]]]])
;	  1236	!
;	  1237	! Formal parameters:
;	  1238	! Usual for system procedure
;	  1239	!
;	  1240	! Implicit inputs:
;	  1241	! none
;	  1242	!
;	  1243	! Implicit outputs:
;	  1244	! Variables $reg1 to $reg4 are set to contain the ac's after the jsys
;	  1245	! Variable $jsysok is set to 1 for success, 0 for failure
;	  1246	!
;	  1247	! Routine Value:
;	  1248	! none
;	  1249	!
;	  1250	! Side effects:
;	  1251	! none
;	  1252	!
;	  1253	!--
;	  1254	
;	  1255	begin
;	  1256	external register z=0;
;	  1257	dinjsx (.ap, .cnt);
;	  1258	end;


U.21:
DINJS1::JRST	U.22				; DINJSX

; Routine Size:  1 word


;	  1259	
;	  1260	GLOBAL ROUTINE DINJSX (AP,CNT) =        ! utility for jsys interface
;	  1261	
;	  1262	!++
;	  1263	! Functional description:
;	  1264	! Perform the jsys requested (see dinjs0, dinjs1). After execution,
;	  1265	! set up the variables $reg1 to $reg4 from the ac's. Store 1 for
;	  1266	! success and 0 for failure in $jsysok, and return same.
;	  1267	!
;	  1268	! Formal parameters:
;	  1269	! Usual for system procedure
;	  1270	!
;	  1271	! Implicit inputs:
;	  1272	! none
;	  1273	!
;	  1274	! Implicit outputs:
;	  1275	! Set variables $reg1 thru $reg4 from the ac's after execution.
;	  1276	! Set variable $jsysok (1=success, 0=failure)
;	  1277	! 
;	  1278	! Routine Value:
;	  1279	! success indicator (1=success, 0=failure)
;	  1280	!
;	  1281	! Side effects:
;	  1282	! none
;	  1283	!
;	  1284	!--
;	  1285	
;	  1286	begin
;	  1287	external register z=0;
;	  1288	local
;	  1289	   vr1,vr2,vr3,vr4,
;	  1290	   code;                        ! jsys number
;	  1291	
;	  1292	if .cnt lss 1 or .cnt gtr 5 then error ('Bad arguments to $jsys');
;	  1293	vr4 = vr3 = vr2 = vr1 =0;
;	  1294	if .cnt eql 5 then vr4 = pcegop (.(.ap+4),ste_typ_int);
;	  1295	if .cnt geq 4 then vr3 = pcegop (.(.ap+3),ste_typ_int);
;	  1296	if .cnt geq 3 then vr2 = pcegop (.(.ap+2),ste_typ_int);
;	  1297	if .cnt geq 2 then vr1 = pcegop (.(.ap+1),ste_typ_int);
;	  1298	code = pcegop(.(.ap),ste_typ_int);
;	  1299	begin
;	  1300	   register
;	  1301	      r1=1, r2=2, r3=3, r4=4;
;	  1302	   r1=.vr1; r2=.vr2; r3=.vr3; r4=.vr4;
;	  1303	   pcvjsk = jsys (-1,.code,r1,r2,r3,r4);
;	  1304	   pcvrg1 = .r1;
;	  1305	   pcvrg2 = .r2;
;	  1306	   pcvrg3 = .r3;
;	  1307	   pcvrg4 = .r4;
;	  1308	   end;
;	  1309	.pcvjsk
;	  1310	
;	  1311	end;


P.AAX:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t","s"," ","t"		; nts t
	BYTE	(7)"o"," ","$","j","s"		; o $js
	BYTE	(7)"y","s",000,000,000		; ys


U.22:
DINJSX::PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,1				; SP,1
	MOVE	AC13,AC2			; CNT,AC2
	MOVE	AC14,AC1			; AP,AC1
	JUMPLE	AC13,L.100			; CNT,L.100
	CAIG	AC13,5				; CNT,5
	JRST	L.101				; L.101
L.100:	MOVEI	AC1,P.AAX			; AC1,P.AAX
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.101:	SETZB	AC12,AC11			; VR1,VR2
	SETZB	AC10,0(SP)			; VR3,VR4
	CAIE	AC13,5				; CNT,5
	JRST	L.102				; L.102
	MOVE	AC1,4(AC14)			; AC1,4(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVEM	AC1,0(SP)			; AC1,VR4
L.102:	CAIGE	AC13,4				; CNT,4
	JRST	L.103				; L.103
	MOVE	AC1,3(AC14)			; AC1,3(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC10,AC1			; VR3,AC1
L.103:	CAIGE	AC13,3				; CNT,3
	JRST	L.104				; L.104
	MOVE	AC1,2(AC14)			; AC1,2(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC11,AC1			; VR2,AC1
L.104:	CAIGE	AC13,2				; CNT,2
	JRST	L.105				; L.105
	MOVE	AC1,1(AC14)			; AC1,1(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC12,AC1			; VR1,AC1
L.105:	MOVE	AC1,0(AC14)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC16,AC1			; CODE,AC1
	MOVE	AC1,AC12			; R1,VR1
	MOVE	AC2,AC11			; R2,VR2
	MOVE	AC3,AC10			; R3,VR3
	MOVE	AC4,0(SP)			; R4,VR4
	SETZ	AC5,				; AC5,
	JSYS	0(AC16)				; 0(CODE)
	JUMP	16,L.106			; 16,L.106
	MOVEI	AC5,1				; AC5,1
L.106:	MOVEM	AC5,PCVJSK			; AC5,PCVJSK
	MOVEM	AC1,PCVRG1			; R1,PCVRG1
	MOVEM	AC2,PCVRG2			; R2,PCVRG2
	MOVEM	AC3,PCVRG3			; R3,PCVRG3
	MOVEM	AC4,PCVRG4			; R4,PCVRG4
	MOVE	AC1,PCVJSK			; AC1,PCVJSK
	ADJSP	SP,-1				; SP,-1
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,

; Routine Size:  64 words


;	  1312	
;	  1313	GLOBAL ROUTINE DINSAD (AP,CNT) =        ! integer procedure $strloc
;	  1314	
;	  1315	!++
;	  1316	! Functional description:
;	  1317	!       int = $strloc (string)
;	  1318	! Returns the actual memory address of a string primary (constant or
;	  1319	! variable). 
;	  1320	! RESTRICTION: may not be used for string expressions or calls to
;	  1321	! string procedures: $strloc($connecteddirectory) or $strloc(str+".")
;	  1322	! return addresses on the stack of string, hence usually totally
;	  1323	! invalid.
;	  1324	!
;	  1325	! Formal parameters:
;	  1326	! Usual for system procedure
;	  1327	!
;	  1328	! Implicit inputs:
;	  1329	! none
;	  1330	!
;	  1331	! Implicit outputs:
;	  1332	! none
;	  1333	!
;	  1334	! Routine Value:
;	  1335	! none
;	  1336	!
;	  1337	! Side effects:
;	  1338	! none
;	  1339	!
;	  1340	!--
;	  1341	
;	  1342	begin
;	  1343	external register z=0;
;	  1344	local
;	  1345	   str : str_val;               ! string argument
;	  1346	
;	  1347	if .cnt neq 1 then error ('Bad argument to $strloc');
;	  1348	str = pcegop(.(.ap), ste_typ_str);
;	  1349	.str[stv_adr]
;	  1350	
;	  1351	end;


P.AAY:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t"," ","t","o"		; nt to
	BYTE	(7)" ","$","s","t","r"		;  $str
	BYTE	(7)"l","o","c",000,000		; loc


U.23:
DINSAD::PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,AC1			; AP,AC1
	CAIN	AC2,1				; CNT,1
	JRST	L.107				; L.107
	MOVEI	AC1,P.AAY			; AC1,P.AAY
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.107:	MOVE	AC1,0(AC14)			; AC1,0(AP)
	MOVEI	AC2,1				; AC2,1
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVEI	AC1,0(AC1)			; AC1,0(STR)
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  12 words


;	  1352	                                ! [fun39]-
;	  1353	
;	  1354	                                ! [fun48]+ $isfile(string) says if the file
;	  1355	                                ! does exist
;	  1356	
;	  1357	GLOBAL ROUTINE DINISF (AP,CNT) =
;	  1358	
;	  1359	!++
;	  1360	! Functional description:
;	  1361	!       int = $isfile ("filename"); yelds 1 if file exists, 0 otherwise
;	  1362	!
;	  1363	! Input Formals:
;	  1364	! Usual for system procedure
;	  1365	!
;	  1366	! Output Formals:
;	  1367	! none
;	  1368	!
;	  1369	! Implicit inputs:
;	  1370	! none
;	  1371	!
;	  1372	! Implicit outputs:
;	  1373	! none
;	  1374	!
;	  1375	! Routine Value:
;	  1376	! 1 if file does exist, 0 otherwise
;	  1377	!
;	  1378	! Side effects:
;	  1379	! none
;	  1380	!
;	  1381	!--
;	  1382	
;	  1383	begin
;	  1384	external register z=0;
;	  1385	local
;	  1386	   ok,                          ! Store success (1) or failure (0)
;	  1387	   str: str_val;                ! string argument value
;	  1388	
;	  1389	if .cnt neq 1 then error ('Bad argument to $isfile');
;	  1390	str = pcegop (.(.ap),ste_typ_str);
;	  1391	begin
;	  1392	   register
;	  1393	      r1=1, r2=2;
;	  1394	   r1 = gj_sht+gj_old;
;	  1395	   r2 = bytptr(.str[stv_adr]);
;	  1396	   ok = jsys (-1, gtjfn, r1,r2);
;	  1397	   if .ok then
;	  1398	      jsys (-1,rljfn,r1);
;	  1399	   end;
;	  1400	if .(.ap) eql opn_tmp_str then pcefst(.str);
;	  1401	
;	  1402	.ok                             ! Return result
;	  1403	
;	  1404	end;


P.AAZ:	BYTE	(7)"B","a","d"," ","a"		; Bad a
	BYTE	(7)"r","g","u","m","e"		; rgume
	BYTE	(7)"n","t"," ","t","o"		; nt to
	BYTE	(7)" ","$","i","s","f"		;  $isf
	BYTE	(7)"i","l","e",000,000		; ile


U.24:
DINISF::PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC13,AC1			; AP,AC1
	CAIN	AC2,1				; CNT,1
	JRST	L.108				; L.108
	MOVEI	AC1,P.AAZ			; AC1,P.AAZ
	PUSHJ	SP,PCEERR			; SP,PCEERR
L.108:	MOVE	AC1,0(AC13)			; AC1,0(AP)
	MOVEI	AC2,1				; AC2,1
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	MOVE	AC4,AC1				; STR,AC1
	MOVSI	AC1,100001			; R1,100001
	MOVEI	AC2,0(AC4)			; HLF,0(STR)
	HRLI	AC2,-337100			; HLF,-337100
	SETZ	AC3,				; AC3,
	JSYS	20				; 20
	JUMP	16,L.109			; 16,L.109
	MOVEI	AC3,1				; AC3,1
L.109:	MOVE	AC14,AC3			; OK,AC3
	TRNN	AC14,1				; OK,1
	JRST	L.110				; L.110
	JSYS	23				; 23
	JUMP	16,L.110			; 16,L.110
L.110:	MOVEI	AC1,-100000			; AC1,-100000
	CAME	AC1,0(AC13)			; AC1,0(AP)
	JRST	L.111				; L.111
	MOVE	AC1,AC4				; AC1,STR
	PUSHJ	SP,PCEFST			; SP,PCEFST
L.111:	MOVE	AC1,AC14			; AC1,OK
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  32 words


;	  1405	                                ! [fun49]
;	  1406	
;	  1407	                                ! [fun65]+ Add $strfix function
;	  1408	GLOBAL ROUTINE DINSFX (AP,CNT) =
;	  1409	
;	  1410	!++
;	  1411	! Functional description:
;	  1412	! 	mystr = $strfix (address)
;	  1413	! converts the asciz found at address into a PCL string.
;	  1414	!
;	  1415	! Input Formals:
;	  1416	! - Address of asciz string.
;	  1417	!
;	  1418	! Output Formals:
;	  1419	! none
;	  1420	!
;	  1421	! Implicit inputs:
;	  1422	! none
;	  1423	!
;	  1424	! Implicit outputs:
;	  1425	! none
;	  1426	!
;	  1427	! Routine Value:
;	  1428	! String value.
;	  1429	!
;	  1430	! Side effects:
;	  1431	! none
;	  1432	!
;	  1433	!--
;	  1434	
;	  1435	begin
;	  1436	external register
;	  1437	  z=0;
;	  1438	
;	  1439	local
;	  1440	   ptr,                         ! character pointer
;	  1441	   stv : str_val;               ! string value for result
;	  1442	
;	  1443	stv[stv_adr] = pcegop(.(.ap),ste_typ_int);      ! address
;	  1444	ptr = ch$ptr(.stv[stv_adr]);            ! pointer
;	  1445	stv[stv_len] = 0;
;	  1446	while ch$rchar_a(ptr) neq 0 do stv[stv_len] = .stv[stv_len] + 1;
;	  1447	pcecst(.stv)                    ! make PCL string and return it
;	  1448	
;	  1449	end;


U.25:
DINSFX::PUSH	SP,AC14				; SP,AC14
	MOVE	AC3,AC1				; AP,AC1
	MOVE	AC1,0(AC3)			; AC1,0(AP)
	SETZ	AC2,				; AC2,
	PUSHJ	SP,PCEGOP			; SP,PCEGOP
	HRR	AC14,AC1			; STV,AC1
	MOVEI	AC1,0(AC14)			; AC1,0(STV)
	MOVEI	AC1,-1(AC1)			; AC1,-1(AC1)
	HRLI	AC1,10700			; AC1,10700
	HRLI	AC14,0				; STV,0
L.112:	ILDB	AC2,AC1				; AC2,PTR
	JUMPE	AC2,L.113			; AC2,L.113
	ADD	AC14,C.6			; STV,[1000000]
	JRST	L.112				; L.112
L.113:	MOVE	AC1,AC14			; AC1,STV
	PUSHJ	SP,PCECST			; SP,PCECST
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,
C.6:	EXP	1000000				; 1000000

; Routine Size:  19 words


;	  1450	                                ! [fun65]- Add $strfix function
;	  1451	
;	  1452	end
;	  1453	eludom



	END

; Low  segment length:       0 words
; High segment length:    1140 words




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  PS:<PCL5.X-SOURCES>EXECPD.L36.1	       328        61        18         0
;  PS:<SUBSYS>TENDEF.L36.2		        56         5         8         0
;  PS:<SUBSYS>MONSYM.L36.5		      3861        69         1         0




; Information:	0
; Warnings:	3
; Errors:	0

; Compilation Complete

	END
 