! UPD ID= 74, PS:<5-0.PCL.LOCAL>EXECPU.B36.12,   6-Jan-83 13:10:25 by DEBAR
![fun54] Merge fundp edits to PCL with PCL5
!<5.1.EXEC>EXECPU.B36.3, 13-Nov-82 09:07:41, Edit by PA0B
!(Hopefully) make $DECnet_Node work on non-DECnet systems.
!Since I don't have any, this has never been tested...
!<5.1.EXEC>EXECPU.B36.2, 30-Oct-82 23:15:19, Edit by PA0B
!Allow optional second argument to $INTEGER.  This argument
!is the radix; if omitted, the default is 10.
!<4.EXEC>EXECPU.B36.19,  8-Mar-82 01:09:02, Edit by PA0B
!Add $DECnet_Node, which returns the local DECnet node name
!and $ARPAnet_Node, which returns the local ARPAnet node
!name (or a null string if the system is not an Arpanet
!host).  Add $Resume_Output, which resumes output to .PRIOU
!which was aborted by ^O (note: ^O aborts output to COJFN,
!so it is not clear whether this is the right thing to do).
! UPD ID= 65, PS:<5-0.PCL.LOCAL>EXECPU.B36.11,  24-Nov-82 23:24:08 by DEBAR
! [fun50] Allow $fileSet to accept string spec of file (see [fun49]
! UPD ID= 64, PS:<5-0.PCL.LOCAL>EXECPU.B36.10,  24-Nov-82 18:07:50 by DEBAR
! [fun49] Filenames in $fileinfo
! UPD ID= 54, PS:<5-0.PCL.LOCAL>EXECPU.B36.9,  12-Nov-82 23:55:44 by DEBAR
! [fun44] Allow pcegop to return ANY type of argument
! UPD ID= 44, PS:<5-0.PCL.LOCAL>EXECPU.B36.8,   3-Nov-82 17:13:38 by DEBAR
! [FUN24-1] Fix bug in $directorylist
! UPD ID= 37, PS:<5-0.PCL.LOCAL>EXECPU.B36.7,  27-Oct-82 22:22:57 by DEBAR
! [fun33] Problem with fileinfo_i when using wild-cards.
! UPD ID= 33, PS:<5-0.PCL.LOCAL>EXECPU.B36.6,  21-Oct-82 21:58:02 by DEBAR
! [fun30] Make $fileinfo_i,_s accept other argument forms
! UPD ID= 29, PS:<5-0.PCL.LOCAL>EXECPU.B36.5,  21-Oct-82 10:15:24 by DEBAR
! UPD ID= 23, PS:<5-0.PCL.LOCAL>EXECPU.B36.3,  19-Oct-82 21:08:17 by DEBAR
! [fun26]
! [fun26] radix in $integer
! UPD ID= 20, PS:<5-0.PCL.LOCAL>EXECPU.B36.2,  10-Oct-82 17:53:05 by DEBAR
! [fun24] add DirectoryList function to pcl
! UPD ID= 13, V4:<5-0.PCL.LOCAL>EXECPU.B36.1,  30-Sep-82 17:08:40 by DEBAR
!<4.EXEC>EXECPU.B36.18,  6-Apr-81 17:29:18, Edit by DK32
!Permit prompt-setting outside PCL
!<4.EXEC>EXECPU.B36.17, 24-Mar-81 20:16:36, Edit by DK32
!Have $PromptReg set CSB correctly
!<4.EXEC>EXECPU.B36.16,  9-Mar-81 17:31:27, Edit by DK32
!More prompts
!<4.EXEC>EXECPU.B36.15,  5-Mar-81 17:11:00, Edit by DK32
!Allow for longer filenames, Make prompt variables
!return original prompts also
!<4.EXEC>EXECPU.B36.14,  1-Mar-81 12:40:09, Edit by DK32
!Changes for Bliss 2.1
!<4.EXEC>EXECPU.B36.13, 23-Jan-81 13:35:43, Edit by DK32
!Allow longer filenames in $Filex
!<4.EXEC>EXECPU.B36.12,  7-Jan-81 18:09:06, Edit by DK32
!Append mode to $Open
!<4.EXEC>EXECPU.B36.11, 22-Dec-80 23:16:08, Edit by DK32
!Use Exec linkage, Release JFN in $NextFile,
!$Typeahead_Count
!<4.EXEC>EXECPU.B36.10, 10-Dec-80 21:25:14, Edit by DK32
!Fix some error messages, $Wait
!<4.EXEC>EXECPU.B36.9,  9-Dec-80 16:03:57, Edit by DK32
!Rework $LastError, $ConnectedDirectory, $Filexxx,
!$Account to dynamically allocate string space
!<4.EXEC>EXECPU.B36.8,  5-Dec-80 16:15:41, Edit by DK32
!$File_Dev ... $File_Typ
!<4.EXEC>EXECPU.B36.7, 26-Nov-80 13:57:16, Edit by DK32
!Set CMRTY when $PromptReg changed
!<4.EXEC>EXECPU.B36.6, 30-Oct-80 16:40:56, Edit by DK32
!$Account, Runtime channel list
!<4.EXEC>EXECPU.B36.5, 21-Oct-80 16:25:45, Edit by DK32
!$FileInfo
!<4.EXEC>EXECPU.B36.4, 18-Oct-80 15:53:15, Edit by DK32
!Parse List and NextFile, Fix count in $SearchRaised
!<4.EXEC>EXECPU.B36.3,  7-Oct-80 15:18:21, Edit by DK32
!New $FileV etc for parsed file list
!<4.EXEC>EXECPU.B36.2,  2-Oct-80 19:26:43, Edit by DK32
!Prompt strings
!<4.EXEC>EXECPU.B36.1, 26-Sep-80 14:03:47, Edit by DK32
!Create module, Add I/O services
MODULE EXECPU =
BEGIN

!++
!
!  This is the first attempt at the Programmable Command Language utilities
!
!  Dave King, Carnegie-Mellon University Computation Center
!
!  September, 1980
!
!  Copyright (C) 1980, Carnegie-Mellon University
!
!--

!++
!    This module contains the system service routines which are provided
!  as part of the standard Exec.
!--

!
! Standard definitions
!

LIBRARY 'EXECPD';		!Get common definitions
LIBRARY 'BLI:TENDEF';		!There are JSYS's in this module
LIBRARY 'BLI:MONSYM';
SWITCHES LINKAGE(EXEC);

BUILTIN JSYS;

!
! Table of contents:
!

FORWARD ROUTINE
    DINIDC,			! Integer procedure $MERGETAD
    DINCTI,			! Integer procedure $CVCTI
    DINSTI,			! Integer procedure $INTEGER
    DINSCH,			! Integer procedure $SEARCH
    DINSCR,			! Integer procedure $SEARCHRAISED
    DINSCC,			! Common search routine
    DINITD,			! Integer procedure $INPUTTAD
    DINITC,			! String procedure $CVITC
    DIVCTD,			! Variable $CURTAD
    DIVLEC,			! Variable $LASTERRCODE
    DIVTTN,			! Variable $TermNumber
    DIVTWD,			! Variable $TERMWIDTH
    DIVNUL,			! Variable $NUL
    DIVLER,			! Variable $LASTERROR
    DIVTAD,			! Variables $TIME and $DATE
    DIVTIM,			! Variable $TIME
    DIVDAT,			! Variable $DATE
    DIVCDR,			! Variable $ConnectedDirectory
    DIVPMR,			! Variable $PromptReg
    DIVPMS,			! Variable $PromptSub
    DIVPME,			! Variable $PromptEnb
    DIVPMU,			! Variable $PromptEnbSub
    DIVPMC,			! Common $Prompt routine
    DIVFNV,			! Variable $FileV
    DIVFNM,			! Variable $FileN
    DIVFNS,			! Variable $FileS
    DIVFNL,			! Variable $FileL
    DIVFNC,			! Common $File routine
    DINOPN,			! Integer procedure $Open
    DINCLS: NOVALUE,		! Procedure $Close
    DINRED,			! String procedure $Read
    DINEOF,			! Integer procedure $EOF
    DINWRT: NOVALUE,		! Procedure $Write
    DINNFL,			! Integer procedure $NextFile
    dinndl,                     ! [fun24] integer procedure $nextdirectory
    DINFII,			! Integer procedure $FileInfo_I
    DINFIS,			! String procedure $FileInfo_S
    DINFDV,			! String procedure $File_Dev
    DINFDR,			! String procedure $File_Dir
    DINFNM,			! String procedure $File_Nam
    DINFTY,			! String procedure $File_Typ
    dinfgn,                     ! [fun49] $file_gen
    DINJFN,			! Common JFNS routine
    DIUJFN : exec1,             ! [fun49] get jfn from channel, $parse, string
    dindir,                     ! [fun24] String procedure $directory
    DIVACC,			! Variable $Account
    DINWAI: NOVALUE,		! Procedure $Wait
    DIVTAH,			! Integer $Typeahead_Count
    DIVDND,			! Variable $DECnet_Node
    DIVAND,			! Variable $ARPAnet_Node
    DINROU: NOVALUE;		! Procedure $Resume_Output

!
! Macros:
!

MACRO ERROR(TXT) = PCEERR(UPLIT(%ASCIZ TXT)) %;

!
! External references:
!

EXTERNAL ROUTINE
    PCEERR,			! EXECPX Report execution error
    PCEAST,			! EXECPX Allocate string space
    PCECST,			! EXECPX Make copy of a string
    PCEGOP : exec1,             ! [fun44] EXECPX Get value of operand
    PCEFST: NOVALUE,		! EXECPX Free string storage
    PCMGMM,			! EXECPM General memory allocator
    PCMSTI,			! CVTDBO routine
    RETMEM,			! EXECSU General memory release
    SUBBP;			! EXECSU Subtract two byte pointers

EXTERNAL
    PCCURC: REF ECB_BLK,	! Current Execution Context Block
    PCLPMT: VECTOR,		! Prompt string table
    XDICT,			! Permanent storage pool
    REDPMT: VECTOR,		! Regular prompt table
    JOBNO,			! Job number of this job
    CUSRNO,			! User number
    CSBUFP: STR_VAL;		! Temporary string buffer pointer

GLOBAL ROUTINE DINIDC(AP,CNT) =	! Integer procedure $MERGETAD

!++
! Functional description:
!	Convert five integers (Year, Month, Day of month, Hour, Minute)
!	into an internal date and time.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	User's integers
!
! Implicit outputs:
!	None
!
! Routine value:
!	TAD
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	RR2: HLF_WRD,		! Temporaries
	RR3: HLF_WRD,
	RR4;
    IF .CNT NEQ 5 THEN ERROR('Bad arguments to $MERGETAD');
    RR4 = PCEGOP(.(.AP+4), STE_TYP_INT) * 60
	  + PCEGOP(.(.AP+3), STE_TYP_INT) * 3600;
    RR3[HLF_LFT] = PCEGOP(.(.AP+2), STE_TYP_INT);
    RR3[HLF_RGT] = 0;
    RR2[HLF_RGT] = PCEGOP(.(.AP+1), STE_TYP_INT);
    RR2[HLF_LFT] = PCEGOP(.(.AP), STE_TYP_INT);
	BEGIN
	BUILTIN JSYS;
	REGISTER R2=2,R3=3,R4=4;
	R2 = .RR2;
	R3 = .RR3;
	R4 = .RR4;
	IF NOT JSYS(1,IDCNV,R2,R3,R4) THEN R2 = 0;
	RR2 = .R2
	END;
    .RR2
    END;

GLOBAL ROUTINE DINCTI(AP,CNT) =	! Internal procedure CVCTI

!++
! Functional description:
!	Return to integer format of the character in String1.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	User's string
!
! Implicit outputs:
!	None
!
! Routine value:
!	Character input
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	STR: STR_VAL,		! String value
	CHR;			! Character
    IF .CNT NEQ 1 THEN ERROR('Bad arguments to $CVCTI');
    STR = PCEGOP(.(.AP),STE_TYP_STR);
    CHR = CH$RCHAR(BYTPTR(.STR[STV_ADR]));
    IF .(.AP) EQL OPN_TMP_STR THEN PCEFST(.STR);
    .CHR
    END;

GLOBAL ROUTINE DINSTI(AP,CNT) =	! Integer procedure $integer

!++
! Functional description:
!	Return the integer value of the number contained in String1,
!       according to the radix given by Integer2
!	Errors are ignored.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	User's string
!
! Implicit outputs:
!	None
!
! Routine value:
!	Number
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
                                ! [fun26]+ radix allowed for $integer
    LOCAL
	STR: STR_VAL,		! String
        RADIX,                  ! Radix
	NUM;			! Accumulated number
    if .cnt eql 1 then
       radix = 10
    else if .cnt eql 2 then begin
       radix = pcegop (.(.ap+1), ste_typ_int);  ! get radix
       if (.radix lss 1 or .radix gtr 10) then
          error ('Invalid radix in $Integer');
       end
    else
       error ('Bad arguments to $Integer');
    STR = PCEGOP(..AP,STE_TYP_STR);     ! get string
    IF .STR[STV_LEN] EQL 0 THEN RETURN 0;
	BEGIN                   ! convert to number
	REGISTER
	    R1=1,R2=2,R3=3;
	R1 = BYTPTR(.STR[STV_ADR]);
	R3 = .radix;
	IF NOT JSYS(1,NIN,R1,R2,R3) THEN R2=0;
	NUM = .R2
	END;
    IF ..AP EQL OPN_TMP_STR THEN PCEFST(.STR);
    .NUM
    END;

GLOBAL ROUTINE DINSCH(AP,CNT) =	! Internal procedure SEARCH

!++
! Functional description:
!	Search String1 for an instance of String2; return index of
!	first character of match, or 0 if not found.  If Integer3
!	provided, start search with Integer3'th character (first is 1)
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	User's strings
!
! Implicit outputs:
!	None
!
! Routine value:
!	Index or 0
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    IF .CNT LSS 2 OR .CNT GTR 3 THEN ERROR('Bad arguments to $SEARCH');
    DINSCC(.AP,.CNT,0)
    END;

GLOBAL ROUTINE DINSCR(AP,CNT) =	! Internal procedure SEARCHRAISED

!++
! Functional description:
!	Search String1 for an instance of String2; return index of
!	first character of match, or 0 if not found.  If Integer3
!	provided, start search with Integer3'th character (first
!	is 1).  Search is insensitive to alphabetic case.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	User's strings
!
! Implicit outputs:
!	None
!
! Routine value:
!	Index or 0
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    IF .CNT LSS 2 OR .CNT GTR 3 THEN ERROR('Bad arguments to $SEARCHRAISED');
    DINSCC(.AP,.CNT,1)
    END;

ROUTINE DINSCC(AP,CNT,FLG) =	! Common search routine

!++
! Functional description:
!	Search String1 for an instance of String2; return index
!	of first character of match, or 0 if not found.
!	If FLG nonzero, make search insensitive to alphabetic
!	case.  If Integer3 provided, start search with Integer3'th
!	character (first is 1).
!
! Formal parameters:
!	Usual for system procedure
!	Flag: 0=Case sensitive, nonzero=Case insensitive
!
! Implicit inputs:
!	User's strings
!
! Implicit outputs:
!	None
!
! Routine value:
!	Index or 0
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	MSTR: STR_VAL,		! Master string
	MPTR,			! Pointer
	TSTR: STR_VAL,		! Target string
	TPTR,			! Pointer
	TLEN,			! Length
	IDX,			! Current index
	VAL;			! Value to return
    IF .CNT EQL 3
    THEN
	BEGIN
	IDX = PCEGOP(.(.AP+2),STE_TYP_INT)-1;
	IF .IDX LSS 0 THEN IDX = 0
	END
    ELSE
	IDX = 0;
    TSTR = PCEGOP(.(.AP+1),STE_TYP_STR);
    MSTR = PCEGOP(..AP,STE_TYP_STR);
    TPTR = BYTPTR(.TSTR[STV_ADR]);
    MPTR = BYTPTR(.MSTR[STV_ADR]);
    IF .IDX NEQ 0 THEN MPTR = CH$PLUS(.MPTR,.IDX);
    TLEN = .TSTR[STV_LEN];
    VAL = (WHILE .MSTR[STV_LEN] GEQ .TLEN+.IDX DO
	IF (IF .FLG EQL 0
	    THEN
		CH$EQL(.TLEN, .MPTR, .TLEN, .TPTR)
	    ELSE
		BEGIN
		LOCAL
		    LPTR,
		    RPTR,
		    RCHR,
		    LCHR,
		    TCNT;
		LPTR = .MPTR;
		RPTR = .TPTR;
		TCNT = .TLEN;
		WHILE .TCNT GTR 0 DO
		    BEGIN
		    LCHR = CH$RCHAR_A(LPTR);
		    RCHR = CH$RCHAR_A(RPTR);
		    IF .LCHR GEQ %C'a' AND .LCHR LEQ %C'z'
		    THEN
			LCHR = .LCHR - %C'a' + %C'A';
		    IF .RCHR GEQ %C'a' AND .RCHR LEQ %C'z'
		    THEN
			RCHR = .RCHR - %C'a' + %C'A';
		    IF .LCHR NEQ .RCHR THEN EXITLOOP 0;
		    TCNT = .TCNT - 1
		    END
		END)
	THEN
	    EXITLOOP .IDX
	ELSE
	    BEGIN
	    IDX = .IDX + 1;
	    MPTR = CH$PLUS(.MPTR,1)
	    END);
    IF ..AP EQL OPN_TMP_STR THEN PCEFST(.MSTR);
    IF .(.AP+1) EQL OPN_TMP_STR THEN PCEFST(.TSTR);
    .VAL+1
    END;


GLOBAL ROUTINE DINITD(AP,CNT) =	! Internal integer procedure INPUTTAD

!++
! Functional description:
!	Convert date and time in String1 to TAD.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	User's string
!
! Implicit outputs:
!	None
!
! Routine value:
!	TAD
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	STR: STR_VAL;		! String
    IF .CNT NEQ 1 THEN ERROR('Bad arguments to $INPUTTAD');
    STR = PCEGOP(..AP,STE_TYP_STR);
	BEGIN
	REGISTER R1=1,R2=2;
	R1 = BYTPTR(.STR[STV_ADR]);
	R2 = 0;
	IF NOT JSYS(1,IDTIM,R1,R2) THEN R2 = 0;
	.R2
	END
    END;

GLOBAL ROUTINE DINITC(AP,CNT) =	! Internal procedure CVITC

!++
! Functional description:
!	Return the character equivalent of the number in Integer1.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	User's integer
!
! Implicit outputs:
!	None
!
! Routine value:
!	Character
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	CHR,			! Character
	STR,			! String
	STV: STR_VAL;		! Stringvalue
    IF .CNT NEQ 1 THEN ERROR('Bad arguments to $CVITC');
    CHR = PCEGOP(.(.AP),STE_TYP_INT);
    CH$WCHAR(.CHR, BYTPTR(STR));
    STV[STV_LEN] = 1;
    STV[STV_ADR] = STR;
    PCECST(.STV)
    END;

GLOBAL ROUTINE DIVCTD =		! Internal variable $CURTAD

!++
! Functional description:
!	Return current internal format date and time
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	TAD
!
! Side effects:
!	None
!
!--

    BEGIN
    REGISTER R1=1;
    JSYS(0,GTAD,R1);
    .R1
    END;

GLOBAL ROUTINE DIVLEC =		! Internal variable $LASTERRCODE

!++
! Functional description:
!	Return last JSYS error code
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Error code
!
! Side effects:
!	None
!
!--

    BEGIN
    LOCAL
	HLF: HLF_WRD;
    REGISTER
	R1=1,R2=2;
    R1 = $FHSLF;
    JSYS(0,GETER,R1,R2);
    HLF = .R2;
    .HLF[HLF_RGT]
    END;

GLOBAL ROUTINE DIVTTN =		! Internal variable $TermNumber

!++
! Functional description:
!	Return number of controlling terminal
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Number
!
! Side effects:
!	None
!
!--

    BEGIN
    REGISTER R1=1,R2=2,R3=3,R4=4;
    JSYS(0,GJINF,R1,R2,R3,R4);
    .R4
    END;

GLOBAL ROUTINE DIVTWD =		! Internal variable $TERMWIDTH

!++
! Functional description:
!	Return width of controlling terminal
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Width
!
! Side effects:
!	None
!
!--

    BEGIN
    REGISTER R1=1,R2=2,R3=3;
    R1 = $CTTRM;
    R2 = $MORLW;
    JSYS(0,MTOPR,R1,R2,R3);
    .R3
    END;

GLOBAL ROUTINE DIVNUL(STR,FLG) =	! Internal variable $NUL

!++
! Functional description:
!	If fetched, returns empty string; if set, discards string.
!
! Formal parameters:
!	Stringvalue to set to
!	Flag: -1 to set, 0 to fetch
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Empty stringvalue
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    IF .FLG NEQ 0 THEN PCEFST(.STR);
    0
    END;

GLOBAL ROUTINE DIVLER =		! Internal variable $LASTERROR

!++
! Functional description:
!	Return stringvalue of text of last JSYS error.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	Last error code
!
! Implicit outputs:
!	String space
!
! Routine value:
!	Stringvalue of text
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	STR: STR_VAL,		! Stringvalue being generated
	CCT,			! Character count
	BUFF: VECTOR[10];	! String buffer
    REGISTER
	R1=1,R2=2,R3=3;
    R1 = BYTPTR(BUFF);
    R2 = $FHSLF^18 + %O'777777';
    R3 = 0;
    JSYS(2,ERSTR,R1,R2,R3);
    CCT = SUBBP(.R1, BYTPTR(BUFF));
    STR = PCEAST(.CCT);
    CH$COPY(.CCT, BYTPTR(BUFF[0]), 0, .CCT+1, BYTPTR(.STR[STV_ADR]));
    .STR
    END;

ROUTINE DIVTAD(OPT) =		! Internal variables $TIME and $DATE

!++
! Functional description:
!	Return the current time or date, in the form HH:MM:SS or DD-MON-YY
!
! Formal parameters:
!	Option flags to give to ODTIM%
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	STR: STR_VAL,		! Stringvalue
	CCT,			! Character count
	BUFF: VECTOR[2];	! String buffer

	BEGIN
	REGISTER R1=1,R2=2,R3=3;
	R1 = BYTPTR(BUFF);
	R2 = -1;
	R3 = .OPT;
	JSYS(0,ODTIM,R1,R2,R3);
	CCT = .R1
	END;

    CCT = SUBBP(.CCT, BYTPTR(BUFF));
    STR = PCEAST(.CCT);
    CH$COPY(.CCT, BYTPTR(BUFF[0]), 0, .CCT+1, BYTPTR(.STR[STV_ADR]));
    .STR
    END;

GLOBAL ROUTINE DIVTIM =		! Internal variable $TIME

!++
! Functional description:
!	Return the current time, in the form HH:MM:SS.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    DIVTAD(OT_NDA)
    END;

GLOBAL ROUTINE DIVDAT =		! Internal variable $DATE

!++
! Functional description:
!	Return the current date, in the form DD-MON-YY.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    DIVTAD(OT_NTM)
    END;

GLOBAL ROUTINE DIVCDR =		! Internal variable $ConnectedDirectory

!++
! Functional description:
!	Return the name of the connected directory.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	STR: STR_VAL,		! Stringvalue to be returned
	LEN,			! Length
	BUFF: VECTOR[10];	! String buffer
    REGISTER
	R1=1,R2=2,R3=3,R4=4;
    JSYS(0,GJINF,R1,R2,R3,R4);
    R1 = BYTPTR(BUFF);
    JSYS(1,DIRST,R1,R2);
    LEN = SUBBP(.R1, BYTPTR(BUFF));
    STR = PCEAST(.LEN);
    CH$COPY(.LEN, BYTPTR(BUFF), 0, .LEN+1, BYTPTR(.STR[STV_ADR]));
    .STR
    END;

GLOBAL ROUTINE DIVPMR(STR,FLG) =	! Internal variable $PromptReg

!++
! Functional description:
!	Fetches or stores regular prompt string from table.
!
! Formal parameters:
!	Stringvalue to set to
!	nonzero to set, zero to fetch
!
! Implicit inputs:
!	Prompt string
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    DIVPMC(.STR, .FLG, 0)
    END;

GLOBAL ROUTINE DIVPMS(STR,FLG) =	! Internal variable $PromptSub
    BEGIN
    EXTERNAL REGISTER Z=0;
    DIVPMC(.STR, .FLG, 3)
    END;

GLOBAL ROUTINE DIVPME(STR,FLG) =	! Internal variable $PromptEnb
    BEGIN
    EXTERNAL REGISTER Z=0;
    DIVPMC(.STR, .FLG, 1)
    END;

GLOBAL ROUTINE DIVPMU(STR,FLG) =	! Internal variable $PromptEnbSub
    BEGIN
    EXTERNAL REGISTER Z=0;
    DIVPMC(.STR, .FLG, 4)
    END;

ROUTINE DIVPMC(STR,FLG,IDX) =	! Common $Prompt routine

!++
! Functional description:
!	Fetches or stores specified prompt string from table
!
! Formal parameters:
!	Stringvalue to set to
!	nonzero to set, zero to fetch
!	Index of prompt in question
!
! Implicit inputs:
!	Prompt string
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    IF .FLG NEQ 0
    THEN
	BEGIN
	MAP STR: STR_VAL;
	IF .PCLPMT[.IDX] NEQ 0
	THEN
	    BEGIN
	    LOCAL OLD: STR_VAL;
	    OLD = .PCLPMT[.IDX];
	    RETMEM((.OLD[STV_LEN]+5)/5, .OLD[STV_ADR], XDICT);
	    PCLPMT[.IDX] = 0
	    END;
	IF .STR NEQ 0
	THEN
	    BEGIN
	    LOCAL NEW: STR_VAL;
	    NEW[STV_LEN] = .STR[STV_LEN];
	    NEW[STV_ADR] = PCMGMM((.NEW[STV_LEN]+5)/5, XDICT);
	    CH$MOVE(.NEW[STV_LEN]+1, BYTPTR(.STR[STV_ADR]),
		    BYTPTR(.NEW[STV_ADR]));
	    PCLPMT[.IDX] = .NEW;
	    PCEFST(.STR);
	    IF .IDX EQL 0 AND .PCCURC NEQ 0 THEN PCCURC[ECB_OPM] = BYTPTR(.NEW)
	    END;
	0
	END
    ELSE
	IF .PCLPMT[.IDX] NEQ 0
	THEN
	    .PCLPMT[.IDX]
	ELSE
	    BEGIN
	    LOCAL PTR,CNT,CPY: STR_VAL;
	    PTR = CH$PTR(REDPMT[.IDX]);
	    CNT = 0;
	    DO CNT = .CNT + 1 WHILE CH$RCHAR_A(PTR) NEQ 0;
	    CPY = PCEAST(.CNT);
	    CH$MOVE(.CNT, CH$PTR(REDPMT[.IDX]), BYTPTR(.CPY[STV_ADR]));
	    .CPY
	    END
    END;

GLOBAL ROUTINE DIVFNV =		! Internal variable $FileV

!++
! Functional description:
!	Return version number of current parsed file.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	Parsed JFN list
!
! Implicit outputs:
!	None
!
! Routine value:
!	Version number of current parsed file
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	LST: REF JLS_WRD,	! JFN list entry
	JFN: HLF_WRD,		! JFN
	LEN,
	BUFF: VECTOR[3];
    REGISTER
	R1=1,R2=2,R3=3;
    LST = .PCCURC[ECB_PFL];
    IF .LST EQL 0 THEN RETURN 0;
    R1 = BYTPTR(BUFF);
    JFN = .LST[JLS_JFN];
    R2 = (IF .LST[JLS_WLD] THEN .JFN ELSE .JFN[HLF_RGT]);
    R3 = FLD(1,JS_GEN);
    JSYS(0,JFNS,R1,R2,R3);
    LEN = SUBBP(.R1, BYTPTR(BUFF));
    PCMSTI(.LEN, BYTPTR(BUFF))
    END;

GLOBAL ROUTINE DIVFNM =		! Internal variable $FileN

!++
! Functional description:
!	Return stringvalue of ordinary name of currently parsed file.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	Parsed JFN list
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of name
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    DIVFNC(0)
    END;

GLOBAL ROUTINE DIVFNS =		! Internal variable $FileS

!++
! Functional description:
!	Return stringvalue of short name of currently parsed file.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	Parsed JFN list
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of name
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    DIVFNC(FLD(2,JS_DEV)+FLD(2,JS_DIR)+FLD(1,JS_NAM)+FLD(1,JS_TYP)+JS_PAF)
    END;

GLOBAL ROUTINE DIVFNL =		! Internal variable $FileL

!++
! Functional description:
!	Return stringvalue of long name of currently parsed file.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	Parsed JFN list
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of name
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    DIVFNC(FLD(1,JS_DEV) + FLD(1,JS_DIR) + FLD(1,JS_NAM) +
	   FLD(1,JS_TYP) + FLD(1,JS_GEN) + JS_PAF)
    END;

ROUTINE DIVFNC(BITS) =	! Common $File routine

!++
! Functional description:
!	Return stringvalue of name of currently parsed file, according
!	to JFNS argument provided by caller.
!
! Formal parameters:
!	Argument to JFNS JSYS
!
! Implicit inputs:
!	Parsed JFN list
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of file name
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	STR: STR_VAL,		! Stringvalue being created
	BUFF: VECTOR[CH$ALLOCATION(120)],	! String buffer
	LEN,			! String length
	LST: REF JLS_WRD;	! Parsed JFN list
    REGISTER
	R1=1,R2=2,R3=3;
    LST = .PCCURC[ECB_PFL];
    IF .LST EQL 0 THEN RETURN 0;
    R1 = BYTPTR(BUFF);
    IF .LST[JLS_WLD] eql 0      ! [fun25] bliss 2.0 bug
    THEN
	R2 = .LST[JLS_JFN]
    ELSE
	BEGIN
	LOCAL
	    JFN: HLF_WRD;
	JFN = .LST[JLS_JFN];
	R2 = .JFN[HLF_RGT]
	END;
    R3 = .BITS;
    JSYS(0,JFNS,R1,R2,R3);
    LEN = SUBBP(.R1, BYTPTR(BUFF));
    STR = PCEAST(.LEN);
    CH$COPY(.LEN, BYTPTR(BUFF), $CHNUL, .LEN+1, BYTPTR(.STR[STV_ADR]));
    .STR
    END;

GLOBAL ROUTINE DINOPN(AP,CNT) =	! Internal integer procedure $Open

!++
! Functional description:
!	Open the file named in String1, according to the mode described
!	by Integer2 (0=input, 1=output, 2=append).  Return the channel number.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	ECB
!
! Routine value:
!	Channel number, or zero if unsuccessful
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	FNM: STR_VAL,		! Filename string
	MODE,			! Desired mode
	JFN,			! JFN
	ENT: REF RCL_WRD;	! Entry in channel list
    BIND
	GTJFN_MODE = UPLIT(GJ_SHT+GJ_OLD,GJ_SHT+GJ_FOU,GJ_SHT): VECTOR,
	OPEN_MODE = UPLIT(FLD(7,OF_BSZ)+OF_RD, FLD(7,OF_BSZ)+OF_WR,
			    FLD(7,OF_BSZ)+OF_APP): VECTOR;
    IF .CNT NEQ 2 THEN ERROR('Bad arguments to $Open');
    MODE = PCEGOP(.(.AP+1), STE_TYP_INT);
    IF .MODE LSS 0 OR .MODE GTR 2 THEN ERROR('Bad arguments to $Open');
    FNM = PCEGOP(.(.AP), STE_TYP_STR);
    IF .FNM[STV_LEN] EQL 0 THEN RETURN 0;
	BEGIN
	REGISTER
	    R1=1,R2=2;
	R1 = .GTJFN_MODE[.MODE];
	R2 = BYTPTR(.FNM[STV_ADR]);
	IF JSYS(1,GTJFN,R1,R2)
	THEN
	    BEGIN
	    JFN = .R1;
	    R2 = .OPEN_MODE[.MODE];
	    IF NOT JSYS(1,OPENF,R1,R2)
		THEN
		    BEGIN
		    R1 = .JFN;
		    JSYS(1,RLJFN,R1);
		    RETURN 0
		    END
	    END
	ELSE
	    RETURN 0
	END;
    ENT = PCMGMM(2, XDICT);
    ENT[RCL_NXT] = 0;
    ENT[RCL_JFN] = .JFN;
    ENT[RCL_OUT] = .MODE NEQ 0;
    IF .PCCURC[ECB_RCL] EQL 0
    THEN
	BEGIN
	ENT[RCL_CHN] = 1;
	PCCURC[ECB_RCL] = .ENT
	END
    ELSE
	BEGIN
	LOCAL
	    PTR: REF RCL_WRD,	! Channel list entry
	    CHN;		! Channel mask
	BUILTIN
	    FIRSTONE;
	CHN = -1;
	PTR = .PCCURC[ECB_RCL];
	WHILE .PTR NEQ 0 DO
	    BEGIN
	    CH$WCHAR(0, CH$PTR(CHN, .PTR[RCL_CHN], 1));
	    PTR = .PTR[RCL_NXT]
	    END;
	CH$WCHAR(0, CH$PTR(CHN, 0, 1));
	CHN = FIRSTONE(.CHN);
	IF .CHN LSS 0 THEN ERROR('Too many files open');
	ENT[RCL_CHN] = .CHN;
	ENT[RCL_NXT] = .PCCURC[ECB_RCL];
	PCCURC[ECB_RCL] = .ENT
	END;
    IF ..AP EQL OPN_TMP_STR THEN PCEFST(.FNM);
    .ENT[RCL_CHN]
    END;

GLOBAL ROUTINE DINCLS(AP,CNT): NOVALUE =	! Internal procedure $Close

!++
! Functional description:
!	Closes the channel given in Integer1, or all channels if -1
!	or if no argument given.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	ECB
!
! Implicit outputs:
!	None
!
! Routine value:
!	None
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	CHN,			! Channel number
	PRED: REF RCL_WRD,	! Channel list entry
	PTR: REF RCL_WRD;	! Channel list entry
    IF .CNT NEQ 1 AND .CNT NEQ 0 THEN ERROR('Bad argument to $Close');
    IF .CNT EQL 0 THEN CHN = -1 ELSE CHN = PCEGOP(..AP, STE_TYP_INT);
    IF .PCCURC[ECB_RCL] EQL 0 THEN RETURN;
    IF .CHN GTR 0
    THEN
	BEGIN
	LOCAL
	    PTR: REF RCL_WRD,
	    PRED: REF RCL_WRD;
	PRED = 0;
	PTR = .PCCURC[ECB_RCL];
	WHILE .PTR NEQ 0 DO
	    BEGIN
	    IF .PTR[RCL_CHN] EQL .CHN THEN EXITLOOP;
	    PRED = .PTR;
	    PTR = .PTR[RCL_NXT]
	    END;
	IF .PTR EQL 0 THEN RETURN;
	    BEGIN
	    REGISTER
		R1=1;
	    R1 = .PTR[RCL_JFN];
	    JSYS(-1,CLOSF,R1)
	    END;
	IF .PRED EQL 0
	THEN
	    PCCURC[ECB_RCL] = .PTR[RCL_NXT]
	ELSE
	    PRED[RCL_NXT] = .PTR[RCL_NXT];
	RETMEM(2, .PTR, XDICT)
	END
    ELSE
	BEGIN
	LOCAL
	    PTR: REF RCL_WRD,
	    NXT: REF RCL_WRD;
	PTR = .PCCURC[ECB_RCL];
	WHILE .PTR NEQ 0 DO
	    BEGIN
		BEGIN
		REGISTER
		    R1=1;
		R1 = .PTR[RCL_JFN];
		JSYS(-1,CLOSF,R1)
		END;
	    NXT = .PTR[RCL_NXT];
	    RETMEM(2, .PTR, XDICT);
	    PTR = .NXT
	    END;
	PCCURC[ECB_RCL] = 0
	END
    END;

GLOBAL ROUTINE DINRED(AP,CNT) =	! Internal string procedure Read

!++
! Functional description:
!	Read a record from the input file whose channel is Integer1,
!	return a string	containing that record.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	Input file
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of record
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	CHN,			! Channel
	ENT: REF RCL_WRD,	! Channel list entry
	JFN,			! JFN
	REC: STR_VAL,
	LEN;
    IF .CNT NEQ 1 THEN ERROR('Read requires a parameter');
    CHN = PCEGOP(..AP, STE_TYP_INT);
    ENT = .PCCURC[ECB_RCL];
    WHILE .ENT NEQ 0 DO
	IF .ENT[RCL_CHN] EQL .CHN THEN EXITLOOP ELSE ENT = .ENT[RCL_NXT];
    IF .ENT EQL 0 THEN ERROR('No file with that channel open');
    IF .ENT[RCL_OUT] THEN ERROR('File is open for output');
    JFN = .ENT[RCL_JFN];
	BEGIN
	REGISTER
	    R1=1,R2=2,R3=3,R4=4;
	R1 = .JFN;
	R2 = .CSBUFP;
	R3 = 5*512;
	R4 = $CHLFD;
	IF NOT JSYS(-1,SIN,R1,R2,R3,R4) THEN RETURN 0;
	LEN = 5*512 - .R3
	END;
    IF .LEN NEQ 0
    THEN
	BEGIN
	REC = PCEAST(.LEN-2);
	CH$COPY(.LEN-2, .CSBUFP, $CHNUL, .LEN-1, BYTPTR(.REC[STV_ADR]))
	END
    ELSE
	REC = 0;
    .REC
    END;

GLOBAL ROUTINE DINEOF(AP,CNT) =	! Internal integer procedure EOF

!++
! Functional description:
!	Examine file specified in by channel Integer1.  Return nonzero if
!	file has reached end of file, or if an output file, or if nonexistent.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	Input file
!
! Implicit outputs:
!	None
!
! Routine value:
!	Zero or -1
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	CHN,			! Channel number
	ENT: REF RCL_WRD;	! Channel list entry
    IF .CNT NEQ 1 THEN ERROR('EOF requires channel number');
    CHN = PCEGOP(..AP, STE_TYP_INT);
    ENT = .PCCURC[ECB_RCL];
    WHILE .ENT NEQ 0 DO
	IF .ENT[RCL_CHN] EQL .CHN THEN EXITLOOP ELSE ENT = .ENT[RCL_NXT];
    IF .ENT EQL 0 THEN ERROR('No file with that channel open');
    IF .ENT[RCL_OUT] THEN RETURN -1;
	BEGIN
	REGISTER
	    R1=1,R2=2;
	R1 = .ENT[RCL_JFN];
	JSYS(0,GTSTS,R1,R2);
	IF .POINTR(R2,GS_EOF) THEN -1 ELSE 0
	END
    END;

GLOBAL ROUTINE DINWRT (AP,CNT): NOVALUE =	! Internal procedure Write

!++
! Functional description:
!	Write the record in String2 to the output file in channel Integer1.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	Output file
!
! Routine value:
!	None
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	CHN,			! Channel
	ENT: REF RCL_WRD,	! Channel list entry
	REC: STR_VAL,
	JFN;
    IF .CNT NEQ 2 THEN ERROR('Bad arguments to $Write');
    REC = PCEGOP(.(.AP+1),STE_TYP_STR);
    CHN = PCEGOP(..AP, STE_TYP_INT);
    ENT = .PCCURC[ECB_RCL];
    WHILE .ENT NEQ 0 DO
	IF .ENT[RCL_CHN] EQL .CHN THEN EXITLOOP ELSE ENT = .ENT[RCL_NXT];
    IF .ENT EQL 0 THEN ERROR('Channel not in use');
    IF .ENT[RCL_OUT] EQL 0 THEN ERROR('File not open for output');
	BEGIN
	REGISTER
	    R1=1,R2=2,R3=3;
	R1 = .ENT[RCL_JFN];
	R2 = BYTPTR(.REC[STV_ADR]);
	R3 = -.REC[STV_LEN];
	JSYS(0,SOUT,R1,R2,R3);
	R2 = CH$PTR(UPLIT(%CHAR($CHCRT,$CHLFD)));
	R3 = -2;
	JSYS(0,SOUT,R1,R2,R3)
	END;
    IF .(.AP) EQL OPN_TMP_STR THEN PCEFST(.REC)
    END;

GLOBAL ROUTINE DINNFL =	! Internal integer procedure NextFile

!++
! Functional description:
!	Steps parsed JFN list to next file, either through GNJFN of the
!	current entry or by discarding it and moving to the next.
!	Returns zero if there is no next file, 1 if there is.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	Parsed JFN list
!
! Implicit outputs:
!	None
!
! Routine value:
!	Nonzero if done, zero if no more files
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	ENT: REF JLS_WRD,	! Parsed JFN list
	JFN;			! JFN
    ENT = .PCCURC[ECB_PFL];
    IF .ENT EQL 0 THEN RETURN 0;
    IF .ENT[JLS_WLD] eql 0      ! [fun24] Add directory list function to pcl
    THEN
	BEGIN
	REGISTER
	    R1=1;
	R1 = .ENT[JLS_JFN];
	JSYS(1,RLJFN,R1);
	JFN = 0
	END
    ELSE
	BEGIN
	REGISTER
	    R1=1;
	R1 = .ENT[JLS_JFN];
	IF NOT JSYS(1,GNJFN,R1) THEN JFN = 0 ELSE JFN = .ENT[JLS_JFN]
	END;
    IF .JFN EQL 0
    THEN
	BEGIN
	PCCURC[ECB_PFL] = .ENT[JLS_LNK];
	RETMEM(2, .ENT, XDICT)
	END;
    IF .PCCURC[ECB_PFL] EQL 0 THEN 0 ELSE 1
    END;

                                ! [fun24]+ add DirectoryList function to pcl
GLOBAL ROUTINE DINNDL =         ! Internal integer procedure NextDirectory

!++
! Functional description:
!	Steps parsed DIRECTORY list to next DIRECTORY, either through
!       RCDIR of the  
! 	current entry or by discarding it and moving to the next.
!	Returns zero if there is no next directory, 1 if there is.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	Parsed directory list
!
! Implicit outputs:
!	None
!
! Routine value:
!	Nonzero if done, zero if no more directories.
!
! Side effects:
!	None
!
!--

    begin
    external register z=0;
    local
	ent: ref dls_wrd,	! parsed directory list
        ptr,                    ! ptr to directory string
        dir;                    ! directory number
    ent = .pccurc[ecb_pdl];     ! get address of current ecb
    if .ent eql 0 then return 0;
    if .ent[dls_wld] eql 0      ! do we have wild carding ?
    then
	begin                   ! NO wildcarding, so can't do anything
        dir = 0;
	end
    else
	begin                   ! YES wildcarding, try to get next
	register
	    r1=1, r2=2, r3=3;
	r1 = rc_stp + rc_awl;   ! stepping, wildcarding
        r2 = bytptr (.ent[dls_str]);    ! pointer to directory string
        r3 = .ent[dls_dir];     ! directory number
        if not (if .ent[dls_usr] eql 0 
                   then jsys (-1,rcdir,r1,r2,r3)
                   else jsys (-1,rcusr,r1,r2,r3)) then
           dir = 0
        else                    ! Mind rcusr bug when stepping
                                ! (if no wild card was used, loops on the
                                ! same user instead of returning 0)
           dir = (if .ent[dls_dir] eql .r3 then 0 else .r3);
        if .dir neq 0 then begin
           ent[dls_dir] = .dir;! store new directory number
           end;
	end;
    if .dir eql 0
    then
	begin
	pccurc[ecb_pdl] = .ent[dls_lnk];        ! link to next chunk
                                                ! in list
        retmem (.ent[dls_len],.ent[dls_str], xdict);    ! release string
	retmem(dls_size, .ent, xdict); ! release chunk itself
	end;
    if .pccurc[ecb_pdl] eql 0 then 0 else 1
    end;
                                ! [fun24]- add DirectoryList function to pcl

GLOBAL ROUTINE DINFII(AP,CNT) =	! Internal integer procedure FileInfo_I

                                ! [fun49]+ Filenames in $fileinfo
!++
! Functional description:
!       int = $fileinfo_i (fil,cod)
!	Return the datum regarding fil which is indexed by
!	cod (fdb index).  Fil is the channel number, or -1 for the
!	currently parsed file, or a string with the filename.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	File
!
! Implicit outputs:
!	None
!
! Routine value:
!	Datum
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	COD,			! Datum index
	CHN,			! Channel
        chn_typ,                ! Channel argument type
        jfn_tmp,                ! 1 if temp jfn name
        info,                   ! info returned
	JFN;			! JFN
    IF .CNT NEQ 2 THEN ERROR('Bad arguments to $FileInfo_I');
    COD = PCEGOP(.(.AP+1), STE_TYP_INT);
    chn = pcegop(..ap, ste_typ_any;  chn_typ);
    jfn = diujfn (.chn, .chn_typ ; jfn_tmp);
    CASE .COD FROM $FBCTL TO $FBSS2 OF  ! [FUN30]
	SET
[$fbctl,$fbadr to $fbcre, $fbgen, $fbbyv to $fbbk0, $fbbbt to $fbusw,
 $fbtdt to $fbss2]:
	BEGIN
	! Get word from FDB
	LOCAL
	    DATUM;
	REGISTER
	    R1=1,R2=2,R3=3;
	R1 = .JFN;
	R2 = .COD + 1^18;
	R3 = DATUM;
	info = (IF NOT JSYS(-1,GTFDB,R1,R2,R3) THEN 0 ELSE .DATUM);
	END;
[INRANGE,OUTRANGE]:             ! [FUN30]
	ERROR('Invalid code in $FileInfo_I');
	TES;

    if .jfn_tmp then begin       ! Release jfn and string
       begin
          register r1=1;
          r1 = .jfn;
          jsys (-1, rljfn, r1);
          end;
       if .(.ap) eql opn_tmp_str then pcefst(.chn);
       end;
    .info
                                ! [fun49]-
    END;

GLOBAL ROUTINE DIUJFN (CHN,CHN_TYP ; JFN_TMP) : EXEC1  =

!++
! Functional description:
! Get a jfn from either a channel number, $parse (filelist) , or
! file name in a string.
!
! Input Formals:
! Channel number OR $parse or string value of file name
! Type of 1st arg: ste_typ_int or _str or _any
!
! Output Formals:
! true if gotten jfn from string argument, else false
!
! Implicit inputs:
! filelist
!
! Implicit outputs:
! none
!
! Routine Value:
! jfn
!
! Side effects:
! none
!
!--

begin
external register z=0;
local
   jfn;                         ! Jfn to return

jfn = 0;
if .chn_typ eql ste_typ_int then begin
    if .chn lss 0 then begin
	local
	    lst: ref jls_wrd,	! parsed jfn list
	    hlf: hlf_wrd;
	lst = .pccurc[ecb_pfl];
	if .lst neq 0 then begin
            hlf = .lst[jls_jfn];
            jfn = .hlf[hlf_rgt]
            end
	end
    else begin
	local
	    ent: ref rcl_wrd;
	ent = .pccurc[ecb_rcl];
	while .ent neq 0 do
	    if .ent[rcl_chn] eql .chn then exitloop else ent = .ent[rcl_nxt];
	if .ent neq 0 then jfn = .ent[rcl_jfn]
	end;
   if .jfn eql 0 then error('Requested file channel not in use');
   jfn_tmp = false;
   end
else begin                      ! NB ste_typ_any is treated as string
                                ! !!! This will be cured some day
   local
      ok,
      str: str_val;
   register r1=1, r2=2;
   str = .chn;
   r1 = gj_sht + gj_old;
   r2 = bytptr (.str[stv_adr]);
   ok = jsys (-1, gtjfn, r1,r2);
   jfn = .r1;
   if not .ok then 
      error ('Requested file does not exist');
   jfn_tmp = true;
   end;

.jfn

end;


                                ! [fun49] Improve $fileinfo_s
GLOBAL ROUTINE DINFIS(AP,CNT) =	! Internal string procedure $FileInfo_S

!++
! Functional description:
!       str = $fileinfo_s(fil,cod [,fmt])
! returns the file info selected by cod.
! Fil is either a channel number, -1 for currently parsed file,
! or a string with the file name.
! cod is either:
!   $fbaut -> author string  }
!   $fblwr -> last writer    } from fdb information
!   $fbact -> account string }
!   -1 says that third argument holds jfns format bits
!   Number>64 gives in second argument the format bits [!!!OBSOLETE]
!   1 for $fbaut, or 2 for $fblwr or 3 for $fbact [!!!OBSOLETE]
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	File
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of datum
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
                                ! [fun49]x fil not needed
        fmt,                    ! format bits
	COD;			! Datum index
    if .cnt eql 3 then begin
       fmt = pcegop (.(.ap+2), ste_typ_int);
       if pcegop(.(.ap+1),ste_typ_int) neq -1 then
          error ('Invalid code in $FileInfo_s');
       cod = 4;
       end
    else if .cnt eql 2 then begin
       fmt = 0;
       cod = pcegop(.(.ap+1), ste_typ_int);
       end
    else error ('Bad arguments to $fileinfo_s');
                             ! Deal with obsolete fmt+64 format
    if .cod gtr 64 then begin
       fmt = .cod - 64;
       cod = 4;
       end;
    selectone .cod of set
    [$fbaut]: cod = 1;          ! Symbolic form
    [$fblwr]: cod = 2;
    [$fbact]: cod = 3;
    [-1]: begin
       if .cnt neq 3 then error ('Format bits missing in $fileinfo_s');
       cod = 4;   
       end;
    [1 to 4]: ;                 ! "cod" itself [obsolete]
    [OTHERWISE]: error ('Invalid Code in $FileInfo_S');
       TES;

   dinjfn(.(.ap), .cod, .fmt)

                                ! [fun49]-
    END;

GLOBAL ROUTINE DINFDV(AP,CNT) =	! Internal string procedure $File_Dev

!++
! Functional description:
!       str = $file_dev(fil) returns the file device of fil.
! Fil is either a channel number, -1 for currently parsed file,
! or a string with the file name.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	File
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of datum
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
                                ! [fun49]x fil not needed
    IF .CNT NEQ 1 THEN ERROR('Bad argument to $File_Dev');
                                ! [fun49]: Filename in $fileinfo
    DINJFN(.(.ap), 4, FLD($JSAOF,JS_DEV) )
    END;

GLOBAL ROUTINE DINFDR(AP,CNT) =	! Internal string procedure $File_Dir

!++
! Functional description:
!       str = $file_dir(fil) returns the file directory of fil.
! Fil is either a channel number, -1 for currently parsed file,
! or a string with the file name.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	File
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of datum
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
                                ! [fun49]x fil not needed
    IF .CNT NEQ 1 THEN ERROR('Bad argument to $File_Dev');
                                ! [fun49]: Filename in $fileinfo
    DINJFN(.(.ap), 4, FLD($JSAOF,JS_DIR) )
    END;

                                ! [fun49]+ $file_gen
GLOBAL ROUTINE DINFGN(AP,CNT) =	! Internal string procedure $File_Gen

!++
! Functional description:
!       str = $file_gen(fil) returns the file generation of fil.
! Fil is either a channel number, -1 for currently parsed file,
! or a string with the file name.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	File
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of datum
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    IF .CNT NEQ 1 THEN ERROR('Bad argument to $File_Dev');
    DINJFN(.(.ap), 4, FLD($JSAOF,JS_GEN) )
    END;
                                ! [fun49]-
                                ! [fun24]+ add DirectoryList function to pcl

global routine dindir (ap,cnt) =        ! string procedure $directory

!++
! Functional description
!       Returns the directory string corresponding to the last
! directory parsed by either DIRECTORY of USER or DIRECTORYLIST.
!
! Formal parameters
!       Usual for system procedure
! Implicit inputs
!       Directory list
! Implicit outputs
!       none
! Routine value
!       string value of directory name
! Side effects
!       none
!--

   begin
   external register z=0;
   local
      lst : ref dls_wrd;        ! directory list pointer

   lst = .pccurc[ecb_pdl];      ! get pointer to list
   if .lst eql 0 then
      0                         ! NO LIST
   else begin
      register
         r1=1,r2=2;             ! [fun24-1] Bug in register allocation !!
      r1 = .csbufp;             ! point to exec provided string space
      r2 = .lst[dls_dir];       ! get directory/user number
      if not jsys(1,dirst,r1,r2) then
         0                      ! DIRST fails for one or the other reason
      else begin
         local
            ptr,len,
            val : str_val;      ! String value
         ptr = .r1;             ! return string to caller
         len = subbp (.ptr, .csbufp);
         val = pceast (.len);   ! cons a string space
         ch$copy (.len, .csbufp, $chnul, .len+1,
                  bytptr(.val[stv_adr]));
         .val
         end
      end
   end;
                                ! [fun24]- add DirectoryList function to pcl

GLOBAL ROUTINE DINFNM(AP,CNT) =	! Internal string procedure $File_Nam

!++
! Functional description:
!       str = $file_nam(fil) returns the file name of fil.
! Fil is either a channel number, -1 for currently parsed file,
! or a string with the file name.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	File
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of datum
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
                                ! [fun49]x fil not needed
    IF .CNT NEQ 1 THEN ERROR('Bad argument to $File_Dev');
                                ! [fun49]: Filename in $fileinfo
    DINJFN(.(.ap), 4, FLD($JSAOF,JS_NAM) )
    END;

GLOBAL ROUTINE DINFTY(AP,CNT) =	! Internal string procedure $File_Typ

!++
! Functional description:
!       str = $file_typ(fil) returns the file type of fil.
! Fil is either a channel number, -1 for currently parsed file,
! or a string with the file name.
!
!	Returns the file type of file Integer1.  The file index is
!	the channel number, or -1 for the currently parsed file.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	File
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of datum
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
                                ! [fun49]x fil not needed
    IF .CNT NEQ 1 THEN ERROR('Bad argument to $File_Dev');
                                ! [fun49]: Filename in $fileinfo
    DINJFN(.(.ap), 4, FLD($JSAOF,JS_TYP) )
    END;

routine dinjfn (aparg, cod, fmt) =	! Common JFNS routine
                                ! [fun49]+ Improve $fileinfo_s and related
!++
! Functional description:
!	Returns the requested datum regarding the given file.
!
! Formal parameters:
! System proc arg ptr to file index: Channel number, or -1 for the currently
!   parsed file, or string value to file name.
!   !!! Mind this requests that caller system procs ALWAYS have the
!   !!! file name as first argument, so that the pcegop for it is done
!   !!! last as required.
! Cod of info requested:
!   1 = author, 2 = lastwriter, 3 = account
!   4 = jfns, fmt bits in fmt
! Format bits for jfns
!
! Datum code
!
! Implicit inputs:
!	File
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of datum
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	JFN,			! JFN
        chn,                    ! channel requested
        chn_typ,                ! Channel argument type
        jfn_tmp,                ! 1 if temp jfn name
	VAL: STR_VAL,		! Stringvalue being generated
	LEN,
	PTR;			! String pointer
    chn = pcegop (.aparg, ste_typ_any ; chn_typ); ! get channel number
    jfn = diujfn (.chn, .chn_typ ; jfn_tmp);
                                ! [fun49]-
    PTR = .CSBUFP;
    CASE .COD FROM 1 TO 4 OF
	SET
[1 TO 2]:
	BEGIN
	LOCAL
	    HLF: HLF_WRD;
	REGISTER
	    R1=1,R2=2;
	HLF[HLF_LFT] = (IF .COD EQL 1 THEN $GFAUT ELSE $GFLWR);
	HLF[HLF_RGT] = .JFN;
	R1 = .HLF;
	R2 = .CSBUFP;
	IF NOT JSYS(-1,GFUST,R1,R2) THEN R2 = .CSBUFP;
	PTR = .R2;
	END;
[3]:	BEGIN
	REGISTER
	    R1=1,R2=2;
	R1 = .JFN;
	R2 = .CSBUFP;
	IF NOT JSYS(1,GACTF,R1,R2) THEN R2 = .CSBUFP;
	PTR = .R2
	END;
[4]:
	BEGIN
	! General access to JFNS
	REGISTER
	    R1=1,R2=2,R3=3,R4=4;
                                ! [fun49]x removed cod>64 support
	R1 = .CSBUFP;
	R2 = .JFN;
	R3 = .fmt;
	R4 = 0;
	IF NOT JSYS(-1,JFNS,R1,R2,R3,R4) THEN R1 = .CSBUFP;
	PTR = .R1
	END;
	TES;
                                ! [fun49]+ Filenames in $fileinfo
    if .jfn_tmp then begin       ! Release jfn and string
       begin
          register r1=1;
          r1 = .jfn;
          jsys (-1, rljfn, r1);
          end;
       if .aparg eql opn_tmp_str then pcefst(.chn);
       end;
                                ! [fun49]-
    IF .PTR NEQ .CSBUFP
    THEN
	BEGIN
	LEN = SUBBP(.PTR, .CSBUFP);
	VAL = PCEAST(.LEN);
	CH$COPY(.LEN, .CSBUFP, $CHNUL, .LEN+1, BYTPTR(.VAL[STV_ADR]));
	.VAL
	END
    ELSE
	0
    END;

GLOBAL ROUTINE DIVACC =		! Internal variable $Account

!++
! Functional description:
!	Return stringvalue of job's account number.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	Account number
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue of account number
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	STR: STR_VAL,		! Stringvalue being generated
	LEN,			! String length
	BUFF: VECTOR[10];	! String buffer
    REGISTER
	R1=1,R2=2;
    R1 = -1;
    R2 = BYTPTR(BUFF);
    JSYS(0,GACCT,R1,R2);
    R1 = .R2;
    LEN = SUBBP(.R1, BYTPTR(BUFF));
    STR = PCEAST(.LEN);
    CH$COPY(.LEN, BYTPTR(BUFF), $CHNUL, .LEN+1, BYTPTR(.STR[STV_ADR]));
    .STR
    END;

GLOBAL ROUTINE DINWAI (AP,CNT): NOVALUE =	! Procedure $Wait

!++
! Functional description:
!	Delay the number of milliseconds given in Integer1, or forever
!	of omitted or nonpositive.
!
! Formal parameters:
!	Usual for system procedure
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	None
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	TIME;
    TIME = 0;
    IF .CNT GEQ 1 THEN TIME = PCEGOP(..AP, STE_TYP_INT);
    IF .TIME LEQ 0
    THEN
	JSYS(0,WAIT)
    ELSE
	BEGIN
	REGISTER
	    R1=1;
	R1 = .TIME;
	JSYS(0,DISMS,R1)
	END
    END;

GLOBAL ROUTINE DIVTAH =		! Variable $Typeahead_Count

!++
! Functional description:
!	Return characters in typeahead buffer for controlling terminal.
!
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Number of characters
!
! Side effects:
!	None
!
!--

    BEGIN
    REGISTER
	R1=1,R2=2;
    R1 = $CTTRM;
    IF JSYS(1,SIBE,R1,R2) THEN R2 = 0;
    .R2
    END;


GLOBAL ROUTINE DIVDND =		! Variable $DECnet_Node

!++
! Functional description:
!	Return stringvalue containing the local node name.
!	
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue containing the local Decnet node name.  This is a null
!	string if the user's machine is not a DECnet host.
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	STR: STR_VAL,		! Stringvalue being generated
	LEN,			! String length
	NODBLK,			! NODE% argument block
	BUFF: VECTOR[10];	! String buffer
    REGISTER
	R1=1,R2=2;
    NODBLK = BYTPTR(BUFF);
    R1 = $NDGLN;
    R2 = NODBLK;
    IF JSYS(-1,NODE,R1,R2)
        THEN LEN = SUBBP(.NODBLK, BYTPTR(BUFF))
	ELSE LEN = 0;
    STR = PCEAST(.LEN);
    CH$COPY(.LEN, BYTPTR(BUFF), $CHNUL, .LEN+1, BYTPTR(.STR[STV_ADR]));
    .STR
    END;

GLOBAL ROUTINE DIVAND =		! Variable $ARPAnet_Node

!++
! Functional description:
!	Return stringvalue containing the local node name.
!	
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	Stringvalue containing the local Arpanet node name.  This is a null
!	string if the user's machine is not an Arpanet host.
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    LOCAL
	STR: STR_VAL,		! Stringvalue being generated
	LEN,			! String length
	BUFF: VECTOR[10];	! String buffer
    REGISTER
	R1=1,R2=2;
    R1 = BYTPTR(BUFF);
    R2 = -1;
    IF JSYS(-1,CVHST,R1,R2)
        THEN LEN = SUBBP(.R1, BYTPTR(BUFF))
	ELSE LEN = 0;
    STR = PCEAST(.LEN);
    CH$COPY(.LEN, BYTPTR(BUFF), $CHNUL, .LEN+1, BYTPTR(.STR[STV_ADR]));
    .STR
    END;

GLOBAL ROUTINE DINROU: NOVALUE = ! Procedure $Resume_Output

!++
! Functional description:
!	Resumes output by turning off TT%OSP (the bit in the JFN mode
!	word which is turned on by the ^O routine) in the JFN mode word
!	for .PRIOU.  This routine is a noop if TT%OSP is already off.
!	
! Formal parameters:
!	None
!
! Implicit inputs:
!	None
!
! Implicit outputs:
!	None
!
! Routine value:
!	None
!
! Side effects:
!	None
!
!--

    BEGIN
    EXTERNAL REGISTER Z=0;
    REGISTER
	R1=1,R2=2;
    R1 = $PRIOU;
    JSYS(0,RFMOD,R1,R2);
    R2 = .R2 OR TT_OSP;
    JSYS(0,SFMOD,R1,R2);
    END;
END

ELUDOM

  