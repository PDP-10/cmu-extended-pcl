; UPD ID= 87, PS:<5-0.PCL.LOCAL>EXECPS.MAC.23,  10-Feb-83 13:27:39 by DEBAR
; [fun66] Add $version procedure
; UPD ID= 85, PS:<5-0.PCL.LOCAL>EXECPS.MAC.22,  10-Feb-83 12:49:36 by DEBAR
; [fun65] Add $strfix function
; UPD ID= 84, PS:<5-0.PCL.LOCAL>EXECPS.MAC.21,  10-Feb-83 11:48:49 by DEBAR
; [fun64] Add $tab function
; UPD ID= 81, PS:<5-0.PCL.LOCAL>EXECPS.MAC.20,  17-Jan-83 20:36:53 by DEBAR
; [fun61] Have DIVUNM ($username) call pcecst before returning
; UPD ID= 70, PS:<5-0.PCL.LOCAL>EXECPS.MAC.19,   6-Jan-83 13:09:25 by DEBAR
;[fun54] Merge fundp edits ro PCL with PCL5
;<5.1.EXEC>EXECPS.MAC.4, 30-Oct-82 13:17:35, Edit by PA0B
;Add $BATCH_JOB
;<5.1.EXEC>EXECPS.MAC.3,  4-Jun-82 15:52:47, Edit by DK32
;Update $EmacsTerminal
;<5.1.EXEC>EXECPS.MAC.2, 31-May-82 23:40:16, Edit by PA0B
;Remove $Resume_Output until I decide what it should do to
;really work "right"
;<4.EXEC>EXECPS.MAC.26, 27-Feb-82 20:25:45, Edit by PA0B
;Add $DECnet_Node, $Arpanet_Node, $Resume_Output, and $LF
;<4.EXEC>EXECPS.MAC.25, 18-Aug-81 17:47:55, Edit by DK32
;Update $EMACSTerminal
;<4.EXEC>EXECPS.MAC.24, 23-Jun-81 14:03:54, Edit by DK32
;Reorder the list, New names for FDB words
;<4.EXEC>EXECPS.MAC.23, 26-May-81 10:39:24, Edit by DK32
;Update $EmacsTerminal
; UPD ID= 2028, SNARK:<6.EXEC>EXECPS.MAC.3,  19-May-81 10:27:00 by PURRETTA
; UPD ID= 2002, SNARK:<6.EXEC>EXECPS.MAC.2,  14-May-81 15:25:13 by MURPHY
;FIX AC DEFS
; UPD ID= 1945, SNARK:<5.EXEC>EXECPS.MAC.2,   6-May-81 13:32:30 by MURPHY
; UPD ID= 67, PS:<5-0.PCL.LOCAL>EXECPS.MAC.18,  24-Nov-82 23:52:23 by DEBAR
; [fun51] $string: if radix other than 10, output magnitude
; UPD ID= 63, PS:<5-0.PCL.LOCAL>EXECPS.MAC.15,  24-Nov-82 18:07:32 by DEBAR
; [fun49] $file_gen, improve $fileinfo_s, etc
; UPD ID= 61, PS:<5-0.PCL.LOCAL>EXECPS.MAC.14,  24-Nov-82 13:19:27 by DEBAR
; [fun48] $isfile(string) says if the file does exit
; UPD ID= 48, PS:<5-0.PCL.LOCAL>EXECPS.MAC.13,  10-Nov-82 17:19:59 by DEBAR
; [fun39] JSYS INTERFACE
; UPD ID= 45, PS:<5-0.PCL.LOCAL>EXECPS.MAC.12,   5-Nov-82 16:30:08 by DEBAR
; [fun38] $termlength
; UPD ID= 43, PS:<5-0.PCL.LOCAL>EXECPS.MAC.11,   3-Nov-82 16:35:01 by DEBAR
; [fun36] Parse: $Xatom, $Command
; UPD ID= 39, PS:<5-0.PCL.LOCAL>EXECPS.MAC.10,  28-Oct-82 17:27:03 by DEBAR
; [fun34] Define constants for CRDIR.., Add $USER and $NEXTUSER
; UPD ID= 31, PS:<5-0.PCL.LOCAL>EXECPS.MAC.9,  21-Oct-82 21:57:34 by DEBAR
; [fun29] $FileSet
; UPD ID= 27, PS:<5-0.PCL.LOCAL>EXECPS.MAC.8,  21-Oct-82 10:14:35 by DEBAR
; [fun28] $directoryinfo_i, $directoryinfo_s
; UPD ID= 24, PS:<5-0.PCL.LOCAL>EXECPS.MAC.7,  20-Oct-82 10:08:35 by DEBAR
; [fun27] $getfield, $setfield, $and, $or
; UPD ID= 16, PS:<5-0.PCL.LOCAL>EXECPS.MAC.6,  10-Oct-82 17:52:11 by DEBAR
;[fun24] add DirectoryList function to pcl
; UPD ID= 11, V4:<5-0.PCL.LOCAL>EXECPS.MAC.5,  30-Sep-82 14:10:54 by DEBAR
;<4.EXEC>EXECPS.MAC.22,  9-Mar-81 17:30:17, Edit by DK32
;More prompts
;<4.EXEC>EXECPS.MAC.21, 12-Jan-81 21:50:29, Edit by DK32
;Give optional timeout to $ReadBinary
;<4.EXEC>EXECPS.MAC.20,  7-Jan-81 18:09:23, Edit by DK32
;$Append
;<4.EXEC>EXECPS.MAC.19, 23-Dec-80 02:29:52, Edit by DK32
;$Typeahead_Count
;<4.EXEC>EXECPS.MAC.18, 10-Dec-80 21:35:24, Edit by DK32
;$Input, $Output, $Wait
;<4.EXEC>EXECPS.MAC.17,  4-Dec-80 15:28:44, Edit by DK32
;$File_Dev ... $File_Typ
;<4.EXEC>EXECPS.MAC.16, 30-Nov-80 00:44:03, Edit by DK32
;Rearrange
;<4.EXEC>EXECPS.MAC.15, 29-Oct-80 16:11:35, Edit by DK32
;Names for $FileInfo, $Account, Runtime channel list
;<4.EXEC>EXECPS.MAC.14, 21-Oct-80 16:07:56, Edit by DK32
;$FileInfo, Rearrange
;<4.EXEC>EXECPS.MAC.13, 15-Oct-80 21:30:10, Edit by DK32
;$NextFile
;<4.EXEC>EXECPS.MAC.12,  7-Oct-80 15:17:16, Edit by DK32
;Adjust $Filex variables for parsed file list
;<4.EXEC>EXECPS.MAC.11,  2-Oct-80 19:23:37, Edit by DK32
;Prompt strings
;<4.EXEC>EXECPS.MAC.10, 25-Sep-80 18:18:41, Edit by DK32
;I/O
;<4.EXEC>EXECPS.MAC.9,  6-Sep-80 22:29:39, Edit by DK32
;Add $SearchRaised
;<4.EXEC>EXECPS.MAC.8, 20-Aug-80 17:01:59, Edit by DK32
;Add $TermNumber, $EmacsTerminal
;<DK32.CG>EXECPS.MAC.7, 10-Jul-80 10:40:12, Edit by DK32
;Add $ConnectedDirectory and $Quote
;<DK32.CG>EXECPS.MAC.6,  3-Jul-80 12:53:05, Edit by DK32
;Make MERGETAD and OUTPUTTAD functions, Add INPUTTAD
;<DK32.CG>EXECPS.MAC.5, 27-Jun-80 09:29:14, Edit by DK32
;Change IDCNV, ODCNV, ODTIM to MERGETAD, EXPANDTAD, OUTPUTTAD, Fix Readbinary
;<DK32.CG>EXECPS.MAC.4, 20-Jun-80 03:30:54, Edit by DK32
;Add $READBINARY
;<DK32.CG>EXECPS.MAC.3, 20-Jun-80 00:21:09, Edit by DK32
;Fix $USERNAME
;<DK32.CG>EXECPS.MAC.1, 11-Jun-80 22:43:51, Edit by DK32

	TITLE EXECPS
	SEARCH MONSYM, MACSYM

; The Programmable Command Language System Variables and Procedures
;
; Copyright (C) 1980, Carnegie-Mellon University
;
; This module defines all the system variables and procedures for PCL.
; The actual routines implementing many of the standard features are in
; module EXECPX; this module contains the fundamental definitions.

T1=:1
T2=:2
T3=:3
T4=:4
P1=:10
P2=:11
P3=:12
P4=:13
P=:17

; System name table
;
; This table contains the name of each procedure and variable,
; along with specific information on the procedure or variable
; location, status, etc.  The ordering of the table is critical.
; Internally, a procedure or variable is referenced only by its
; index in this table; these indices are in the program texts of
; compiled PCL routines, so if you change this list indiscriminately
; existing environments may not work.  Since it should not be
; necessary to delete any of the entries in the table as it is
; distributed, you should be simply be able to append entries to
; the end, accordingly giving your installation's routines all
; new indices.
;
; Each entry in the table takes two words; one word contains status
; information, and the other contains two addresses in the right
; and left halves.
;

; Word 1, Bit 0 - Routine	;If the entry defines a Variable, a one
;				;in this bit indicates that the variable
;				;is implemented by a routine which is called
;				;and which returns a value; if this bit is
;				;off, the Variable is simply a word in memory.
;
; Word 1, Bit 1 - Writeable	;If the entry defines a Variable, a one
;				;in this bit indicates that a write into
;				;the Variable is legal.
;
; Word 1, bits 12-14 - Data type if variable or typed procedure

	TYPINT==0		;Integer
	TYPSTR==1		;String

; Word 1, bits 15-17 - Class

	CLSPRC==0		;Untyped Procedure
	CLSFCN==1		;Typed procedure
	CLSVAR==2		;Variable

; Word 1, right half - Name length
; Word 2, left half - Address of ASCII string containing the name
; Word 2, right half - Address of routine, or of data word if ordinary Variable

DEFINE SYNDEF (NAME,LEN,CLASS,ADDR,TYPE,RTN,WRT) <
	..STAT==0
	IFNB <RTN>,<
	..STAT==400000>
	IFNB <WRT>,<
	..STAT==..STAT+200000>
	..STAT==..STAT+CLS'CLASS
	IFNB <TYPE>,<
	..STAT==..STAT+<TYP'TYPE>B32>
	..STAT,,LEN
	[ASCII/NAME/] ,, ADDR>

PSDEFN::

;Constants
	SYNDEF (CRLF,4,VAR,CRLFST,STR)
	SYNDEF (CR,2,VAR,CRTSTR,STR)
	SYNDEF (NUL,3,VAR,DIVNUL##,STR,RTN,WRT)
	SYNDEF (QUOTE,5,VAR,QUOTST,STR)
	SYNDEF (PARSE,5,VAR,[-1],INT)
	SYNDEF (FBCTL,5,VAR,[.FBCTL],INT)
	SYNDEF (FBADR,5,VAR,[.FBADR],INT)
	SYNDEF (FBPRT,5,VAR,[.FBPRT],INT)
	SYNDEF (FBCRE,5,VAR,[.FBCRE],INT)
	SYNDEF (FBGEN,5,VAR,[.FBGEN],INT)
	SYNDEF (FBBYV,5,VAR,[.FBBYV],INT)
	SYNDEF (FBSIZ,5,VAR,[.FBSIZ],INT)
	SYNDEF (FBCRV,5,VAR,[.FBCRV],INT)
	SYNDEF (FBWRT,5,VAR,[.FBWRT],INT)
	SYNDEF (FBREF,5,VAR,[.FBREF],INT)
	SYNDEF (FBCNT,5,VAR,[.FBCNT],INT)
	SYNDEF (FBBK0,5,VAR,[.FBBK0],INT)
	SYNDEF (FBBBT,5,VAR,[.FBBBT],INT)
	SYNDEF (FBNET,5,VAR,[.FBNET],INT)
	SYNDEF (FBUSW,5,VAR,[.FBUSW],INT)
	SYNDEF (FBTDT,5,VAR,[.FBTDT],INT)
	SYNDEF (FBFET,5,VAR,[.FBFET],INT)
	SYNDEF (FILECONTROL,^D11,VAR,[.FBCTL],INT)
	SYNDEF (FILEADDRESS,^D11,VAR,[.FBADR],INT)
	SYNDEF (FILEPROTECTION,^D14,VAR,[.FBPRT],INT)
	SYNDEF (FILECREATION,^D12,VAR,[.FBCRE],INT)
	SYNDEF (FILESIZE,8,VAR,[.FBSIZ],INT)
	SYNDEF (FILEWRITE,9,VAR,[.FBWRT],INT)
	SYNDEF (FILEREAD,8,VAR,[.FBREF],INT)
	SYNDEF (AUTHOR,6,VAR,[1],INT)
	SYNDEF (WRITER,6,VAR,[2],INT)
	SYNDEF (FILEACCOUNT,^D11,VAR,[3],INT)
	SYNDEF (INPUT,5,VAR,[0],INT)
	SYNDEF (OUTPUT,6,VAR,[1],INT)
	SYNDEF (APPEND,6,VAR,[2],INT)

;System information
	SYNDEF (JOBNO,5,VAR,JOBNO##,INT)
	SYNDEF (TERMNUMBER,^D10,VAR,DIVTTN##,INT,RTN)
	SYNDEF (TTYPE,5,VAR,DIVTTP,INT,RTN)
	SYNDEF (CURTAD,6,VAR,DIVCTD##,INT,RTN)
	SYNDEF (LASTERRCODE,^D11,VAR,DIVLEC##,INT,RTN)
	SYNDEF (TERMWIDTH,9,VAR,DIVTWD##,INT,RTN)
	SYNDEF (USERNAME,8,VAR,DIVUNM,STR,RTN)
	SYNDEF (ACCOUNT,7,VAR,DIVACC##,STR,RTN)
	SYNDEF (LASTERROR,9,VAR,DIVLER##,STR,RTN)
	SYNDEF (TIME,4,VAR,DIVTIM##,STR,RTN)
	SYNDEF (DATE,4,VAR,DIVDAT##,STR,RTN)
	SYNDEF (CONNECTEDDIRECTORY,^D18,VAR,DIVCDR##,STR,RTN)
	SYNDEF (PROMPTREG,^D9,VAR,DIVPMR##,STR,RTN,WRT)
	SYNDEF (PROMPTSUB,^D9,VAR,DIVPMS##,STR,RTN,WRT)
	SYNDEF (PROMPTENB,^D9,VAR,DIVPME##,STR,RTN,WRT)
	SYNDEF (PROMPTENBSUB,^D12,VAR,DIVPMU##,STR,RTN,WRT)
	SYNDEF (TYPEAHEAD_COUNT,^D15,VAR,DIVTAH##,INT,RTN)

;Other System calls
	SYNDEF (WAIT,4,PRC,DINWAI##)

;Simple manipulations
	SYNDEF (LENGTH,6,FCN,DINLNS,INT)
	SYNDEF (CVCTI,5,FCN,DINCTI##,INT)
	SYNDEF (INTEGER,7,FCN,DINSTI##,INT)
	SYNDEF (STRING,6,FCN,DINITS,STR)
	SYNDEF (CVITC,5,FCN,DINITC##,STR)

;Parse results
	SYNDEF (VALUE,5,VAR,PCVVAL##,INT)
	SYNDEF (FILEV,5,VAR,DIVFNV##,INT,RTN)
    	SYNDEF (ATOM,4,VAR,PCVATM##,STR)
	SYNDEF (FILEN,5,VAR,DIVFNM##,STR,RTN)
	SYNDEF (FILES,5,VAR,DIVFNS##,STR,RTN)
	SYNDEF (FILEL,5,VAR,DIVFNL##,STR,RTN)
	SYNDEF (NEXTFILE,^D8,FCN,DINNFL##,INT)

;Time/Date converters
	SYNDEF (EXPANDTAD,9,PRC,DINODC)	
	SYNDEF (MERGETAD,8,FCN,DINIDC##,INT)
	SYNDEF (INPUTTAD,8,FCN,DINITD##,INT)
	SYNDEF (OUTPUTTAD,9,FCN,DINODT,STR)

;Search
	SYNDEF (SEARCH,6,FCN,DINSCH##,INT)
	SYNDEF (SEARCHRAISED,^D12,FCN,DINSCR##,INT)

;Input/output
	SYNDEF (READBINARY,^D10,FCN,DINRBN,STR)
	SYNDEF (OPEN,4,FCN,DINOPN##,INT)
	SYNDEF (CLOSE,5,PRC,DINCLS##)
	SYNDEF (READ,4,FCN,DINRED##,STR)
	SYNDEF (EOF,3,FCN,DINEOF##,INT)
	SYNDEF (WRITE,5,PRC,DINWRT##)
	SYNDEF (FILEINFO_I,^D10,FCN,DINFII##,INT)
	SYNDEF (FILEINFO_S,^D10,FCN,DINFIS##,STR)
	SYNDEF (FILE_DEV,8,FCN,DINFDV##,STR)
	SYNDEF (FILE_DIR,8,FCN,DINFDR##,STR)
	SYNDEF (FILE_NAM,8,FCN,DINFNM##,STR)
	SYNDEF (FILE_TYP,8,FCN,DINFTY##,STR)

;This definition is only for CMU; we don't expect anyone else
;to be able to use it unmodified since it depends on the terminal
;indices used at CMU

	SYNDEF (EMACSTERMINAL,^D13,VAR,DIVETM,INT,RTN)

;Recent inserts

	SYNDEF (DECNET_NODE,^D11,VAR,DIVDND##,STR,RTN)
	SYNDEF (ARPANET_NODE,^D12,VAR,DIVAND##,STR,RTN)
	SYNDEF (LF,2,VAR,LFTSTR,STR)
	SYNDEF (BATCH_JOB,^D9,VAR,BATCHF##,INT)

				;[fun24]+ add DirectoryList function to pcl
	SYNDEF (NEXTDIRECTORY,^D13,FCN,DINNDL##,INT)
	SYNDEF (DIRECTORY,^D9,FCN,DINDIR##,STR)
				;[fun24]- add DirectoryList function to pcl

				; [fun27]+ $getfield, $setfield, $and, $or
	syndef (GETFIELD,^d8,fcn,dingfl##,int)
	syndef (SETFIELD,^d8,fcn,dinsfl##,int)
	syndef (AND,^d3,fcn,dinand##,int)
	syndef (OR,^d2,fcn,dinor##,int)
				; [fun27]- $getfield, $setfield, $and, $or

				; [fun28]+ $directoryinfo_i,$directoryinfo_s
	syndef (DIRECTORYINFO_I,^D15,FCN,DINDII##,INT)
	syndef (DIRECTORYINFO_S,^D15,FCN,DINDIS##,STR)
				; [fun28]+ $directoryinfo_i,$directoryinfo_s

				; [fun29]: $FileSet
	syndef (FILESET,^D7,PRC,DINSFI##)	;$fileset system
						;procedure

				; [fun34]+ Define constants for
				;CRDIR.., Add $USER and $NEXTUSER
	SYNDEF (NEXTUSER,^D8,FCN,DINNDL##,INT)
	SYNDEF (USER,^D4,FCN,DINDIR##,STR)
	syndef (FBAUT,5,VAR,[.FBAUT],INT)
	syndef (FBACT,5,VAR,[.FBACT],INT)
	syndef (FBLWR,5,VAR,[.FBLWR],INT)
	SYNDEF (CDLEN,5,VAR,[.CDLEN],INT)
	SYNDEF (CDPSW,5,VAR,[.CDPSW],INT)
	SYNDEF (CDLIQ,5,VAR,[.CDLIQ],INT)
	SYNDEF (CDPRV,5,VAR,[.CDPRV],INT)
	SYNDEF (CDMOD,5,VAR,[.CDMOD],INT)
	SYNDEF (CDLOQ,5,VAR,[.CDLOQ],INT)
	SYNDEF (CDNUM,5,VAR,[.CDNUM],INT)
	SYNDEF (CDFPT,5,VAR,[.CDFPT],INT)
	SYNDEF (CDDPT,5,VAR,[.CDDPT],INT)
	SYNDEF (CDRET,5,VAR,[.CDRET],INT)
	SYNDEF (CDLLD,5,VAR,[.CDLLD],INT)
	SYNDEF (CDUGP,5,VAR,[.CDUGP],INT)
	SYNDEF (CDDGP,5,VAR,[.CDDGP],INT)
	SYNDEF (CDSDQ,5,VAR,[.CDSDQ],INT)
	SYNDEF (CDCUG,5,VAR,[.CDCUG],INT)
	SYNDEF (CDDAC,5,VAR,[.CDDAC],INT)
	SYNDEF (CDDNE,5,VAR,[.CDDNE],INT)
	SYNDEF (CDDFE,5,VAR,[.CDDFE],INT)
	SYNDEF (CDWDQ,5,VAR,[.CDDFE+1],INT)
	SYNDEF (CDPDQ,5,VAR,[.CDDFE+2],INT)
	SYNDEF (CDUSD,5,VAR,[.CDDFE+3],INT)
				; [FUN34]-
				; [fun36]+ Parse: $Xatom, $Command
	SYNDEF (XATOM,5,VAR,DINXAT##,STR,RTN)
	SYNDEF (COMMAND,^D7,VAR,DINCMD##,STR,RTN)
				; [FUN36]-
				; [fun38]: $termlength
	SYNDEF (TERMLENGTH,^d10,VAR,DIVTLN##,INT,RTN)	;$termlength
				; [fun39]+ JSYS INTERFACE
	SYNDEF (AC1,3,VAR,PCVRG1##,INT)
	SYNDEF (AC2,3,VAR,PCVRG2##,INT)
	SYNDEF (AC3,3,VAR,PCVRG3##,INT)
	SYNDEF (AC4,3,VAR,PCVRG4##,INT)
	SYNDEF (JSYSOK,^D6,VAR,PCVJSK##,INT)
	SYNDEF (GET_MEM,^D7,FCN,DINGMM##,INT)
	SYNDEF (RET_MEM,^D7,PRC,DINRMM##)
	SYNDEF (IPUT,^D4,PRC,DINIPM##)
	SYNDEF (IGET,^D4,FCN,DINIGM##,INT)
	SYNDEF (SPUT,^D4,PRC,DINSPM##)
	SYNDEF (SGET,^D4,FCN,DINSGM##,STR)
	SYNDEF (JFN,^D3,FCN,DINJFC##,INT)
	SYNDEF (JSYS,^D4,FCN,DINJS0##,INT)
	SYNDEF (JSYS1,^D5,PRC,DINJS1##)
	SYNDEF (STRLOC,^D6,FCN,DINSAD##,INT)
				; [fun39]- JSYS INTERFACE
				; [fun48]: $isfile(string) says if the file
				;does exist
        SYNDEF (ISFILE,^D6,FCN,DINISF##,INT)
				; [fun49]+ $file_gen, improve $fileinfo_s, etc
	SYNDEF (FILE_GEN,^D8,FCN,DINFGN##,STR)
	SYNDEF (FBFMT,^D5,VAR,[-1],INT)
				; [fun49]-
				; [fun64]: Add $tab functioN
	SYNDEF (TAB,3,VAR,TABST,STR)
				;[fun65]: Add $strfix function
	SYNDEF (STRFIX,^D6,FCN,DINSFX##,STR)
				;[fun66]: Add $version procedure
	SYNDEF (VERSION,^D7,VAR,VERSION,STR)

PSDEFL==:<.-PSDEFN>/2		;Length of definition table

; Some simple definitions

; Everywhere in PCL a string is referenced in terms of a "stringvalue"
; which can not simply be an address of an ASCIZ string.  Instead,
; a stringvalue has the length of the string in the right half and
; the address of the ASCIZ string in the right half.  This string
; length does NOT include the final null.

; Here are the definitions of two rather simple system string variables;
; since they are strings, their values are stringvalues.

CRLFST:	2,,[BYTE(7) .CHCRT,.CHLFD,.CHNUL]	; $CRLF
CRTSTR:	1,,[BYTE(7) .CHCRT,.CHNUL]		; $CR
LFTSTR:	1,,[BYTE(7) .CHLFD,.CHNUL]		; $LF
QUOTST:	1,,[BYTE(7) ^D34,.CHNUL] ; $QUOTE
				;[fun64]: Add $tab function
TABST:  1,,[BYTE(7) 11,.CHNUL]	;$TAB
				;[fun66]: Add $MYVER procedure
VERSION: ^D37,,[ASCIZ\PCL - 10FEB83 - CMU 5(100)/FNDP 5(66)\]

; Some symbols used here and there

EXTERN CSBUFP			;Common string buffer pointer
EXTERN SUBBP			;Subtract two byte pointers


; System Procedure definitions

; All system procedures are called from module EXECPX during execution
; of a PCL "CAL" pseudo-instruction.  The address of the user's actual
; argument list is passed in AC1, and its length in AC2.  The procedure
; fetches the parameters as it wishes, performs its calculations, and
; stores its results back in the user's parameters.  System procedures
; should follow the standard register conventions: AC1 through AC4 are
; free for use by the called routine, along with AC16; all other AC's
; must be saved and restored if they are modified.

; A user's actual parameter list contains one word for each parameter;
; actually only the right half contains information.  The parameter is
; represented by a general operand descriptor, which contains several
; codes in the high order three bits and an index in the low order 15
; bits.  This index is NOT an address and is actually useless to you
; in this module.  The way a procedure fetches and stores parameters is
; by calling two utility routines defined in EXECPX, and described below.
; Since the number and types of the parameters are not known until the
; procedure is called, the procedure must specify the required type
; of each parameter at the time it calls these utilities to fetch and
; store them.  An integer operand is specified by the symbol TYPINT,
; and a string by TYPSTR. (Defined above)

; Routine PCEGOP takes an actual parameter descriptor in AC1 and a type
; code in AC2 and returns the value in AC1; if the parameter is a string
; then the value will be a "stringvalue" as described above.

EXTERN PCEGOP			;Get operand

; Routine PCESOP takes an actual parameter descriptor in AC1, a value in
; AC2 (an integer number or a stringvalue), and a type code in AC3,
; and stores the value in the parameter.  If the actual parameter is not
; suitable for a store (for instance, if it was a procedure value or
; a computed number) an error will result.

EXTERN PCESOP			;Set operand

; When strings are involved a complication arises.  Strings are allocated
; from a common string space pool, and every string is pointed to by
; one and only one user variable.  Thus, if you want to store a string in
; a user parameter, almost certainly you want to really want to store
; a unique COPY of that string.  To make a unique copy in a newly-allocated
; string block, you call routine PCECST with a stringvalue in AC1; it will
; return in AC1 a stringvalue to the new string, all ready to be stored
; by PCESOP.  Or, if you know the length and want to do the copy yourself,
; a call to PCEAST with a length in AC1 will allocate a string block suitable
; for storing that many characters (plus one for the null) and return the
; stringvalue in AC1.

EXTERN PCECST			;Copy string
EXTERN PCEAST

; A further complication arises because of the possibility that some
; actual parameters may have been dynamically generated, and thus may
; reside on the stack.  During normal execution, such temporary variables
; are popped from the stack the instant they are fetched (e.g., by an ADD
; pseudo-instruction).  A system Procedure must take care to fetch its
; actual parameters in the proper order in order to pop the right parameter
; at the right time.  That is, if your system Procedure is called by
;
;	CALL $CONCATENATE( "first "+"string", "second "+"string")
;
; then "first string" will be pushed on the stack before "second string"
; and you had best be sure to fetch them in the opposite order.

; Because of these temporary variables, a system Procedure has one more
; responsibility: It must free the string block contained in such a
; temporary.  So, whenever you use PCEGOP to obtain a string parameter,
; whenever you are done with its contents you must check the actual
; parameter descriptor to see if it is the code for a temporary string
; (symbol CLSTMS below); if it is, then you should call routine PCEFST
; with the stringvalue of the string in AC1 to release the string.

EXTERN PCEFST			;Free string
CLSTMS==700000			;Temporary string

; You may wish to issue an error, for instance because of bad parameters.
; Remember that all PCL execution errors are fatal.  All you do is jump
; to routine PCEERR with the address of an ASCIZ error message in AC1.

EXTERN PCEERR			;Execution error

; Procedure $EXPANDTAD - Convert TAD to several integers

;   CALL $EXPANDTAD(TAD, Year, Month, DayMonth, DayWeek, Hour, Minute: Integer)

DINODC:	CAIE T2,7		;Correct number of parameters?
	JRST [	MOVEI T1,[ASCIZ/Bad arguments to EXPANDTAD/]
		JRST PCEERR]	;No
	SAVEAC <P1,P2,P3,P4>
	MOVE P1,T1		;Save parameter list pointer
	MOVE T1,(T1)		;Get first parameter descriptor
	MOVEI T2,TYPINT		;Must be an integer
	CALL PCEGOP		;Get TAD
	MOVE T2,T1		;Get TAD to proper AC
	SETZ T4,		;Default options
	ODCNV			;Break it up
	DMOVE P2,T2		;Save the results
	MOVE P4,T4
	MOVE T1,1(P1)		;Store year
	HLRZ T2,P2
	MOVEI T3,TYPINT
	CALL PCESOP
	MOVE T1,2(P1)		;Store month
	HRRZ T2,P2
	MOVEI T3,TYPINT
	CALL PCESOP
	MOVE T1,3(P1)		;Store day of month
	HLRZ T2,P3
	MOVEI T3,TYPINT
	CALL PCESOP
	MOVE T1,4(P1)		;Store day of week
	HRRZ T2,P3
	MOVEI T3,TYPINT
	CALL PCESOP
	MOVE T1,5(P1)		;Store hour
	HRRZ T2,P4		;Get seconds
	IDIVI T2,^D60		;Make minutes
	IDIVI T2,^D60		;Now make hours
	MOVE P4,T3		;Save remaining minutes
	MOVEI T3,TYPINT
	CALL PCESOP
	MOVE T1,6(P1)		;Store minute
	MOVE T2,P4
	MOVEI T3,TYPINT
	CALLRET PCESOP

; String Procedure $OUTPUTTAD - Convert TAD to a string

;  LET STR = $OUTPUTTAD (TAD: Integer)

DINODT:	CAIE T2,1		;Right parameter count?
	JRST [	MOVEI T1,[ASCIZ/Bad arguments to OUTPUTTAD/]
		JRST PCEERR]	;No
	MOVE T1,(T1)		;Get TAD
	MOVEI T2,TYPINT
	CALL PCEGOP
	MOVE T2,T1
	MOVE T1,CSBUFP		;Ordinary buffer area
	SETZ T3,		;Standard format
	ODTIM
	MOVE T2,CSBUFP		;See how long it is
	CALL SUBBP
	CALL PCEAST		;Allocate string
	MOVE T4,T1		;Save stringvalue
	MOVE T2,CSBUFP		;Copy the string
	HRLI T1,(<POINT 7,0>)
	ILDB T3,T2
	IDPB T3,T1
	JUMPN T3,.-2
	MOVE T1,T4		;Return the stringvalue
	RET

; Integer Procedure $LENGTH - Return length of string

;    LET integer = $LENGTH(string)

DINLNS:	CAIE T2,1		;One parameter?
	JRST [	MOVEI T1,[ASCIZ/Bad argument to $Length/]
		JRST PCEERR]	;No
	SAVEAC <P1,P2>
	MOVE P1,T1		;Save pointer
	MOVE T1,(T1)		;Get descriptor
	MOVEI T2,TYPSTR
	CALL PCEGOP		;Get string
	HLRZ P2,T1		;Get length
	MOVE T2,(P1)		;Get designator again
	CAIN T2,CLSTMS		;Temporary?
	CALL PCEFST		;Free it
	MOVE T1,P2		;Return length
	RET

; String Procedure $STRING - Convert integer to string

;  LET string = $STRING(Number:Integer)   or
;  LET string = $STRING(Number, radix: Integer)
;  if radix neq 10, output magnitude [fun51]

DINITS:	CAIL T2,1		;Too few arguments?
	CAILE T2,2		;Too many?
	JRST [	MOVEI T1,[ASCIZ/Bad arguments to $STRING/]
		JRST PCEERR]	;Yes
	SAVEAC <P1,P2>
	MOVEI P2,^D10		;Default radix
	MOVE P1,T1
	CAIE T2,2		;Radix provided?
	JRST ITS1		;No
	MOVE T1,1(T1)		;Get it
	MOVEI T2,TYPINT
	CALL PCEGOP
	MOVE P2,T1		;Save it
ITS1:	MOVE T1,(P1)		;Get number
	MOVEI T2,TYPINT
	CALL PCEGOP
	MOVE T2,T1		;Save it
	MOVE T1,CSBUFP		;Use common buffer
				;[fun51]+
INT2:	MOVE T3,P2		;Default format with requested radix
        caie t3,^d10
	 ior t3,[no%mag]
				;[fun51]-
	NOUT			;Convert it
	 NOP
	MOVE T2,CSBUFP		;See how long it is
	CALL SUBBP
	CALL PCEAST		;Allocate string
	MOVE T2,T1		;Copy strings
	HRLI T2,(<POINT 7,0>)
	MOVE T3,CSBUFP
	ILDB T4,T3
	IDPB T4,T2
	JUMPN T4,.-2
	RET			;Return stringvalue

; String Procedure $READBINARY - Read from terminal

;   LET string = $READBINARY(NumberofBytes:Integer, BreakCharacter:String,
;			TimeOut:Integer)

DINRBN:	CAILE T2,1		;Two or three arguments?
	CAILE T2,3
	JRST [	MOVEI T1,[ASCIZ/Bad arguments to $ReadBinary/]
		JRST PCEERR]	;No
	SAVEAC <P1,P2,P3>
	MOVE P1,T1		;Save pointer to arguments
	MOVEI P3,^D1000		;Default timeout
	CAIE T2,3		;Is timeout specified?
	JRST DINRB1		;No
	MOVE T1,2(P1)		;Get timeout
	MOVEI T2,TYPINT
	CALL PCEGOP
	MOVE P3,T1		;Save timeout
DINRB1:	MOVE T1,1(P1)		;Get break string
	MOVEI T2,TYPSTR
	CALL PCEGOP
	HLRZ T2,T1		;Check the length
	CAIE T2,1		;Exactly one character?
	JRST [	MOVEI T1,[ASCIZ/Break string may have only one character/]
		JRST PCEERR]	;No
	LDB P2,[POINT 7,0(T1),6] ;Get the character
	MOVE T2,1(P1)		;Get the designator again
	CAIN T2,CLSTMS		;Temporary?
	CALL PCEFST		;Yes, free it
	MOVE T1,(P1)		;Get descriptor of count
	MOVEI T2,TYPINT
	CALL PCEGOP		;Get character count
	MOVE P1,T1		;Save it
	JUMPLE P3,DINRB3	;Need I wait?
DINRB2:	MOVX T1,.CTTRM		;Check terminal
	SIBE			;Is there something ready?
	JRST DINRB3		;Yes, read it
	MOVEI T1,^D100		;Pause 100 msec
	DISMS
	SUBI P3,^D100
	JUMPG P3,DINRB2		;Check again
	SETZ T1,		;Return empty string
	RET

DINRB3:	MOVX T1,.CTTRM		;Get controlling terminal
	RFMOD			;Get current modes
	MOVE T4,T2		;Save them
	SETZRO TT%DAM,T2	;Set to binary mode
	SFMOD
	MOVE T2,CSBUFP		;Read into a common buffer
	MOVE T3,P1		;Up to this many characters
	EXCH T4,P2		;Or until this character is read
	SIN
	MOVE T2,P2		;Get back former modes
	SFMOD
	MOVE T1,P1		;Get space for this many characters
	SUB T1,T3		;Although this many weren't read
	CALL PCEAST
	MOVE T4,T1		;Copy the string
	HRLI T4,(POINT 7,0)
	MOVE T2,CSBUFP
	ILDB T3,T2
	IDPB T3,T4
	SOJG P1,.-2
	RET			;Return the stringvalue in T1

; Integer variable $TTYPE - Terminal type index

DIVTTP:	MOVEI T1,.PRIIN		;Current terminal
	GTTYP
	MOVE T1,T2		;Return index
	RET

; String variable $USERNAME - Logged-in user name

DIVUNM:	GJINF			;See who I am
	MOVE T2,T1		;Copy it
	HRRZ T1,CSBUFP		;Point to a buffer
	HRLI T1,010700		;Use the next word since it must on a word
	PUSH P,T1		;Save it
	DIRST			;Convert it
	 NOP
	MOVE T2,(P)		;See how long it is
	CALL SUBBP
	POP P,T2		;Get back address
	HRL T1,T1		;Make a stringvalue
	HRRI T1,1(T2)
	call pcecst		; [fun61] Allocate string, and copy it
	RET

;CMU local variable

; Integer variable $EmacsTerminal - nonzero if current terminal
;				    can be used effectively by Emacs

DIVETM:	MOVEI T1,.PRIIN		;Current terminal
	GTTYP
	ADJBP T2,[POINT 1,EMCTRM,0] ;Point to corresponding bit
	LDB T1,T2		;Get yes or no
	RET

EMCTRM:	000006,,317276		;This is a bitvector based on the CMU
	175777,,0		;terminal types.

	END
    