;	  0001	! UPD ID= 83, PS:<5-0.PCL.LOCAL>EXECPC.B36.11,  19-Jan-83 17:16:16 by DEBAR
;	  0002	! [fun63] Change code computing based numbers
;	  0003	! UPD ID= 80, PS:<5-0.PCL.LOCAL>EXECPC.B36.10,  16-Jan-83 21:01:26 by DEBAR
;	  0004	! [fun55] Correct [fun34] dealing with string space exhausted.
;	  0005	! UPD ID= 76, PS:<5-0.PCL.LOCAL>EXECPC.B36.8,  16-Jan-83 18:32:20 by DEBAR
;	  0006	! UPD ID= 72, PS:<5-0.PCL.LOCAL>EXECPC.B36.7,   6-Jan-83 13:09:44 by DEBAR
;	  0007	![fun54] Merge fundp edits to PCL with PCL5
;	  0008	! meant also:
;	  0009	! - modify CPCASE and CPSELE for new syntax (brackets hack)
;	  0010	! - check lone OTHERWISE/ALWAYS in CPSELE
;	  0011	!<5.1.EXEC>EXECPC.B36.5, 15-Nov-82 02:32:37, Edit by PA0B
;	  0012	!Allow DISPLAY integer-expression, Add OUTRANGE to CASE,
;	  0013	!Make the square brackets around CASE and SELECT labels
;	  0014	!optional (the "approved" syntax is to omit them, but the
;	  0015	!compiler allows them), Make complex PARSE really look like
;	  0016	!CASE or SELECT by making the "approved" syntax be
;	  0017	!	    PARSE BEGIN parse-items END ;
;	  0018	!instead of
;	  0019	!	    PARSE ( parse-items ) ;
;	  0020	!except that I didn't hack in the optional square bracket
;	  0021	!stuff...
;	  0022	!<5.1.EXEC>EXECPC.B36.4, 13-Nov-82 14:04:06, Edit by PA0B
;	  0023	!Make WILD behave more as documented if paired with PARSEONLY
;	  0024	!(if PARSEONLY is specified, WILD doesn't cause GJ%IFG to
;	  0025	!be set), Allow DISPLAY'ing of integers
;	  0026	!<5.1.EXEC>EXECPC.B36.3,  2-Nov-82 07:47:22, Edit by PA0B
;	  0027	!Allow DCM ... TO system-variable, disallow DCM ... TO foo + bar
;	  0028	!Make sure values from WORDS are halfword values so they can
;	  0029	!go in the right half of TBLUK% entries
;	  0030	!<5.1.EXEC>EXECPC.B36.2, 30-Oct-82 15:58:43, Edit by PA0B
;	  0031	!Don't get confused in CERROR if line contained "%"'s
;	  0032	! UPD ID= 60, PS:<5-0.PCL.LOCAL>EXECPC.B36.6,  24-Nov-82 11:17:09 by DEBAR
;	  0033	! [fun47] Allow quoted string in parse... words("xxx":1)
;	  0034	! UPD ID= 56, PS:<5-0.PCL.LOCAL>EXECPC.B36.5,  22-Nov-82 00:27:02 by DEBAR
;	  0035	! [fun45] Multiple tags in case/select/selectall
;	  0036	! UPD ID= 51, PS:<5-0.PCL.LOCAL>EXECPC.B36.4,  12-Nov-82 15:52:23 by DEBAR
;	  0037	! [fun42] Inline comments !{...}!, and {...} as begin...end
;	  0038	! UPD ID= 47, PS:<5-0.PCL.LOCAL>EXECPC.B36.3,   9-Nov-82 09:00:59 by DEBAR
;	  0039	! [fun40] Allow digits in system names $...
;	  0040	! UPD ID= 35, PS:<5-0.PCL.LOCAL>EXECPC.B36.2,  26-Oct-82 21:05:27 by DEBAR
;	  0041	! [fun31] Fix string system variables garbage collection problem
;	  0042	! UPD ID= 22, PS:<5-0.PCL.LOCAL>EXECPC.B36.3,  19-Oct-82 21:08:03 by DEBAR
;	  0043	! [fun25] 
;	  0044	! fun25: add based numbers to pcl
;	  0045	! UPD ID= 17, PS:<5-0.PCL.LOCAL>EXECPC.B36.2,  10-Oct-82 17:52:27 by DEBAR
;	  0046	! [fun24] add DirectoryList function to pcl
;	  0047	! UPD ID= 12, V4:<5-0.PCL.LOCAL>EXECPC.B36.1,  30-Sep-82 15:07:35 by DEBAR
;	  0048	!<4.EXEC>EXECPC.B36.123, 23-Jun-81 12:46:36, Edit by DK32
;	  0049	!Handle stray semicolon after Otherwise field, Make DCm
;	  0050	!and PasO synonyms for DoCommand and PassOutput
;	  0051	!<4.EXEC>EXECPC.B36.122, 21-May-81 10:36:49, Edit by DK32
;	  0052	!Prohibit two Files in one Parse
;	  0053	!<4.EXEC>EXECPC.B36.121, 17-Apr-81 22:49:01, Edit by DK32
;	  0054	!Allow longer erroneous lines
;	  0055	!<4.EXEC>EXECPC.B36.120,  8-Apr-81 15:03:18, Edit by DK32
;	  0056	!Protect against impossibly long source lines, Allow
;	  0057	!negative keyword values, Fix parenthesized expressions
;	  0058	!<4.EXEC>EXECPC.B36.119, 24-Mar-81 20:41:41, Edit by DK32
;	  0059	!<4.EXEC>EXECPC.B36.118, 11-Mar-81 15:49:52, Edit by DK32
;	  0060	!Allow Parses with command arguments
;	  0061	!<4.EXEC>EXECPC.B36.117, 25-Feb-81 21:52:16, Edit by DK32
;	  0062	!Prompt, Convert underscores in synonym names, Some
;	  0063	!changes for Bliss 2.1, Redo global symbol replacement,
;	  0064	!PassOutput
;	  0065	!<4.EXEC>EXECPC.B36.116, 22-Jan-81 19:36:11, Edit by DK32
;	  0066	!Recognize EOF better
;	  0067	!<4.EXEC>EXECPC.B36.115, 12-Jan-81 21:40:30, Edit by DK32
;	  0068	!Allow 512-character quoted strings
;	  0069	!<4.EXEC>EXECPC.B36.114, 23-Dec-80 18:45:31, Edit by DK32
;	  0070	!Use Exec linkage, Clean out CM_SHR, Parse Invisible and
;	  0071	!Deleted, Fix Parse Wild+Parseonly
;	  0072	!<4.EXEC>EXECPC.B36.113, 15-Dec-80 22:37:56, Edit by DK32
;	  0073	!Larger constant work area
;	  0074	!<4.EXEC>EXECPC.B36.112,  9-Dec-80 00:20:28, Edit by DK32
;	  0075	!Allow overwrite of routines of different classes, Exit
;	  0076	!Save and ToProgram
;	  0077	!<4.EXEC>EXECPC.B36.111, 26-Nov-80 20:12:08, Edit by DK32
;	  0078	!Change an error message, Don't OR together generation
;	  0079	!numbers, Change some indenting, Allow for preserved
;	  0080	!commands
;	  0081	!<4.EXEC>EXECPC.B36.110, 25-Oct-80 23:00:53, Edit by DK32
;	  0082	!Handle bad identifier in declaration better, Handle File
;	  0083	!with Wild and Parseonly
;	  0084	!<4.EXEC>EXECPC.B36.109, 21-Oct-80 18:01:34, Edit by DK32
;	  0085	!Allow underscore in system names
;	  0086	!<4.EXEC>EXECPC.B36.108, 18-Oct-80 15:52:36, Edit by DK32
;	  0087	!Parse FileList, Default_Gen, Wild
;	  0088	!<4.EXEC>EXECPC.B36.107,  9-Oct-80 20:36:22, Edit by DK32
;	  0089	!Synonym and NoOriginal
;	  0090	!<4.EXEC>EXECPC.B36.106,  2-Oct-80 20:09:43, Edit by DK32
;	  0091	!Allow terminal semicolon in multiple-field Parse, Allow
;	  0092	!Else after short-form Parse, Add Parse NoIndirect and NoHelp,
;	  0093	!Fix writeable system variable
;	  0094	!<4.EXEC>EXECPC.B36.105, 25-Sep-80 15:07:58, Edit by DK32
;	  0095	!Allow commands to replace synonyms, Reset transparency
;	  0096	!before first scan, Correct diagnostic for type mismatch
;	  0097	!<4.EXEC>EXECPC.B36.104, 15-Sep-80 14:23:04, Edit by DK32
;	  0098	!Fix routine replacement, Fudge line number in CALL,
;	  0099	!Implement all two-character relationals
;	  0100	!<4.EXEC>EXECPC.B36.103, 10-Sep-80 16:04:00, Edit by DK32
;	  0101	!Add symbol definitions in source files, Long labels,
;	  0102	!Made Let optional, Add parenthesized expressions
;	  0103	!<4.EXEC>EXECPC.B36.102,  7-Sep-80 20:40:30, Edit by DK32
;	  0104	!Fix Parseonly of File fields, Allow numeric Words, Fix
;	  0105	!integer arithmetic, Forbid Parse chaining from Noise fields,
;	  0106	!More detail on missing labels, Prohibit declarations after
;	  0107	!first statement
;	  0108	!<4.EXEC>EXECPC.B36.101, 20-Aug-80 17:23:17, Edit by DK32
;	  0109	!Larger constant pool, Better scan status save, Allow for
;	  0110	!256-character strings
;	  0111	!<DK32.CG>EXECPC.B36.100,  8-Aug-80 17:41:05, Edit by DK32
;	  0112	!Don't say "Name not found" for a type mismatch, Point
;	  0113	!to correct atom for unrecognized keyword, Allow 100 keywords
;	  0114	!<DK32.CG>EXECPC.B36.99, 31-Jul-80 18:52:48, Edit by DK32
;	  0115	!Change GETTYPOUT and CLEARTYPOUT to GETTYPEOUT and CLEARTYPEOUT,
;	  0116	!Parse command names transparently
;	  0117	!<DK32.CG>EXECPC.B36.98, 18-Jul-80 13:40:11, Edit by DK32
;	  0118	!Fix quoted strings to not include following character, Change TAD to Daytime
;	  0119	!<DK32.CG>EXECPC.B36.97, 17-Jul-80 14:29:40, Edit by DK32
;	  0120	!Two doublequotes in a quoted string just generate a doublequote
;	  0121	!<DK32.CG>EXECPC.B36.96,  2-Jul-80 14:51:39, Edit by DK32
;	  0122	!A form feed is as good as a line feed, Tell CERROR about tabs,
;	  0123	!Add Substring[Start:*]
;	  0124	MODULE EXECPC =
;	  0125	BEGIN
;	  0126	
;	  0127	!++
;	  0128	!
;	  0129	!  This is the first attempt at the Programmable Command Language compiler
;	  0130	!
;	  0131	!  Dave King, Carnegie-Mellon University Computation Cenetr
;	  0132	!
;	  0133	!  January, 1980
;	  0134	!
;	  0135	!  Copyright (C) 1980, Carnegie-Mellon University
;	  0136	!
;	  0137	!--
;	  0138	
;	  0139	!
;	  0140	! Standard definitions
;	  0141	!
;	  0142	
;	  0143	LIBRARY 'EXECPD';
;	  0144	LIBRARY 'BLI:TENDEF';
;	  0145	LIBRARY 'BLI:MONSYM';
; WARN#050	........1  L1:0145
; Name already declared in this block:  $CHLFD
; WARN#050	........1  L1:0145
; Name already declared in this block:  $CHCRT
; WARN#050	........1  L1:0145
; Name already declared in this block:  $CHFFD
;	  0146	SWITCHES LINKAGE(EXEC);
;	  0147	
;	  0148	!
;	  0149	! Table of contents:
;	  0150	!
;	  0151	
;	  0152	                                ! [fun63]+
;	  0153	builtin
;	  0154	   machop;
;	  0155	                                ! [fun63]-
;	  0156	
;	  0157	FORWARD ROUTINE
;	  0158	    CERROR,			! Report compilation error
;	  0159	    SCACHR,			! Return next character from input stream
;	  0160	    SCAN,			! Get next atom
;	  0161	    ADDSMB,			! Add current atom to symbol table
;	  0162	    FNDSMB,			! Find current atom in symbol table
;	  0163	    DEFLBL: NOVALUE,		! Define label
;	  0164	    GENINS,			! Generate an instruction
;	  0165	    GETCNS,			! Find or create constant
;	  0166	    ASMPRC: NOVALUE,		! Assemble components of procedure
;	  0167	    DEFPRC: NOVALUE,		! Define procedure in global symbol table
;	  0168	    PCCCPL: NOVALUE,		! Main entry point to compiler
;	  0169	    CPVARD: NOVALUE,		! Define a variable
;	  0170	    CPSYND: NOVALUE,		! Define a synonym
;	  0171	    CPCMPL: NOVALUE,		! Compile a routine
;	  0172	    CPRTNC: NOVALUE,		! <Procedure-declaration>
;	  0173	    CPFRML: NOVALUE,		! <Formal-parameter-list>
;	  0174	    CPCARG: NOVALUE,		! Command arguments
;	  0175	    CPBODY: NOVALUE,		! <Procedure-body>
;	  0176	    CPDECL,			! <Declaration>
;	  0177	    CPSTMT,			! <Statement>
;	  0178	    CPASGN: NOVALUE,		! <Assignment-statement>
;	  0179	    CPCNDI: NOVALUE,		! <Conditional-statement>
;	  0180	    CPIFST,			! <If-statement>
;	  0181	    CPGOTO: NOVALUE,		! <Goto-statement>
;	  0182	    CPCASE: NOVALUE,		! <Case-statement>
;	  0183	    CPLOOP: NOVALUE,		! <Do-statement>
;	  0184	    CPSELE: NOVALUE,		! <Select-statement>
;	  0185	    CPCOMS: NOVALUE,		! Common string statement
;	  0186	    CPPFRM: NOVALUE,		! <DoCommand-statement>
;	  0187	    CPGUID: NOVALUE,		! <Guide-statement
;	  0188	    CPPMPT: NOVALUE,		! <Prompt-statement>
;	  0189	    CPINVK: NOVALUE,		! <Invoke-statement>
;	  0190	    CPPRSE: NOVALUE,		! <Parse-statement>
;	  0191	    CPPRSI,			! <Parse-item>
;	  0192	    CPPRSO: NOVALUE,		! <Parse-options>
;	  0193	    CPPRSW,			! <Parse-option> Words
;	  0194	    CPPRSF: NOVALUE,		! File parse options
;	  0195	    CPTYIN: NOVALUE,		! Typein statement
;	  0196	    CPDPLY: NOVALUE,		! Display statement
;	  0197	    CPEXIT: NOVALUE,		! Exit statement
;	  0198	    CPCALL: NOVALUE,		! <Call-statement>
;	  0199	    CPACTL: NOVALUE,		! <Actual-parameter-list>
;	  0200	    CPRETN: NOVALUE,		! <Return-statement>
;	  0201	    CPIEXP,			! <Integer-expression>
;	  0202	    CPSEXP,			! <String-expression>
;	  0203	    CPLEXP,			! <Logical-expression>
;	  0204	    CPITRM,			! <Integer-term>
;	  0205	    CPIPRM,			! <Integer-primary>
;	  0206	    CPSPRM,			! <String-primary>
;	  0207	    CPCLSE;			! Classify expression
;	  0208	
;	  0209	!
;	  0210	! Macros:
;	  0211	!
;	  0212	
;	  0213	MACRO ERROR(TXT) = CERROR(UPLIT(%ASCIZ TXT)) %;
;	  0214	
;	  0215	!
;	  0216	! External references:
;	  0217	!
;	  0218	
;	  0219	EXTERNAL ROUTINE
;	  0220	    PCMCER,			! Report compilation error
;	  0221	    PCMITS,			! CVTBDO routine
;	  0222	    PCMGMM,			! General memory allocator
;	  0223	    PCIFGS,			! Find global symbol entry
;	  0224	    PCICGS,			! Create global symbol entry
;	  0225	    PCIDFV: NOVALUE,		! Define global variable
;	  0226	    PCIDFS: NOVALUE,		! Define synonym
;	  0227	    PCIUDF: NOVALUE,		! Undefine global object
;	  0228	    GTBUFX;			! EXECSU Memory allocate
;	  0229	
;	  0230	EXTERNAL
;	  0231	    BUF0,			! Temporary work areas
;	  0232	    PCTEXT: VECTOR,		! Pure text region
;	  0233	    PCTXFR,			! Pure text free list
;	  0234	    PCGBST: GST_TBL,		! Global symbol table
;	  0235	    PSDEFN: SYN_TBL,		! System name table
;	  0236	    DICT;			! Short term free space pool
;	  0237	
;	  0238	EXTERNAL LITERAL
;	  0239	    PSDEFL: UNSIGNED(6);	! Length of system name table
;	  0240	
;	  0241	!
;	  0242	! Equated symbols:
;	  0243	!
;	  0244	
;	  0245	LITERAL
;	  0246	    CODWKL = 1024,		! Size of code work area
;	  0247	    SYMWKL = 512,		! Size of symbol table work area
;	  0248	    CNSWKL = 3072,		! Size of constant pool work area
;	  0249	    CURSML = SYMWKL/STE_LEN;	! Maximum index into symbol table work area
;	  0250	
;	  0251	BIND
;	  0252	    CERM1 = UPLIT(%ASCIZ 'Constants work area full'),
;	  0253	    CERM2 = UPLIT(%ASCIZ 'Field type missing in Parse, perhaps missing ")"'),
;	  0254	    CERM3 = UPLIT(%ASCIZ 'Name invalid or missing'),
;	  0255	    CERM4 = UPLIT(%ASCIZ 'Name not unique'),
;	  0256	    CERM5 = UPLIT(%ASCIZ 'Unrecognized statement keyword'),
;	  0257	    CERM6 = UPLIT(%ASCIZ 'Semicolon missing'),
;	  0258	    CERM7 = UPLIT(%ASCIZ 'END not found where required'),
;	  0259	    CERM8 = UPLIT(%ASCIZ 'Destination name missing'),
;	  0260	    CERM9 = UPLIT(%ASCIZ 'Unable to recognize statement'),
;	  0261	    CERM10 = UPLIT(%ASCIZ 'Too many labels'),
;	  0262	    CERM11 = UPLIT(%ASCIZ 'Colon missing'),
;	  0263	    CERM12 = UPLIT(%ASCIZ 'Statement missing'),
;	  0264	    CERM13 = UPLIT(%ASCIZ 'Integer not found where required'),
;	  0265	    CERM14 = UPLIT(%ASCIZ 'Right parenthesis missing'),
;	  0266	    CERM15 = UPLIT(%ASCIZ 'Too many variables'),
;	  0267	    CERM16 = UPLIT(%ASCIZ 'Left parenthesis missing'),
;	  0268	    CERM17 = UPLIT(%ASCIZ 'Unexpected end of input'),
;	  0269	    CERM18 = UPLIT(%ASCIZ 'Unable to recognize expression'),
;	  0270	    CERM19 = UPLIT(%ASCIZ 'String missing'),
;	  0271	    CERM20 = UPLIT(%ASCIZ 'OF missing'),
;	  0272	    CERM21 = UPLIT(%ASCIZ 'BEGIN missing'),
;	  0273	    CERM22 = UPLIT(%ASCIZ 'Superfluous right bracket'),
;	  0274	    CERM23 = UPLIT(%ASCIZ 'Right bracket missing'),
;	  0275	    CERM24 = UPLIT(%ASCIZ 'String not found where required'),
;	  0276	
;	  0277	    CERM101 = UPLIT(%ASCIZ 'OTHERWISE/ALWAYS Must be Sole Tag'),
;	  0278	
;	  0279	    CODWRK = BUF0: COD_BLK,	! Code work area
;	  0280	    SYMWRK = CODWRK+CODWKL: SYMENT,	! Symbol table work area
;	  0281	    CNSWRK = SYMWRK+SYMWKL: VECTOR,	! Constant pool work area
;	  0282	    CURRTN = CNSWRK+CNSWKL: VECTOR,	! Name of routine being compiled
;	  0283	    CURNML = CURRTN+8,		! Length of the above
;	  0284	    CURCLS = CURNML+1,		! Class of routine being compiled
;	  0285	    CURTYP = CURCLS+1,		! Type of function
;	  0286	    CURTXT = CURTYP+1,		! Text address of routine
;	  0287	    PRCARG = CURTXT+1: VECTOR,	! Formal arguments to procedure
;	  0288	    CMDARG = PRCARG+MAXPRM,	! Constant index of command argument list
;	  0289					!   -2 if Parse instead, -1 if neither
;	  0290	    NEXTIN = CMDARG+1,		! Relative address of next instruction
;	  0291	    SCAPTR = NEXTIN+1,		! Source pointer
;	  0292	    SCALIN = SCAPTR+1,		! Source line counter
;	  0293	    LLNPTR = SCALIN+1,		! Pointer to first character of last line
;	  0294	    SCATRP = LLNPTR+1,		! Nonzero to scan transparently
;	  0295	    SCABUF = SCATRP+1: VECTOR,	! Line buffer
;	  0296	    SCATOM = SCABUF+25: VECTOR,	! Atom buffer
;	  0297	    SCALEN = SCATOM+103,	! Length of atom
;	  0298	    SCANUM = SCALEN+1,		! Numeric atom
;	  0299	    SCACOD = SCANUM+1,		! Scan code of current atom
;	  0300	    NUMVRS = SCACOD+1,		! Number of variables declared in routine
;	  0301	    CONSTP = NUMVRS+1,		! Next available constant pool entry
;	  0302	    SYMTBP = CONSTP+1,		! Next available symbol table index
;	  0303	    LBLNAM = SYMTBP+1: VECTOR,	! Pointers to label names
;	  0304	    LBLADR = LBLNAM+MAXLBL: VECTOR,	! Label locations
;	  0305	    LBLCNT = LBLADR+MAXLBL;	! Number defined
;	  0306	
;	  0307	GLOBAL
;	  0308	    PCCWKE: INITIAL (LBLCNT);	! Last location used by compiler
;	  0309	
;	  0310	!
;	  0311	! Reserved name table
;	  0312	!
;	  0313	
;	  0314	FIELD RSNFLD =
;	  0315	    SET
;	  0316		RSNSTR = [0,0,18,0],	! Address of string
;	  0317		RSNLEN = [0,18,9,0],	! Length of string
;	  0318		RSNSCN = [0,27,9,0]	! Corresponding scanner code
;	  0319	    TES;
;	  0320	
;	M 0321	MACRO RESNAM(NAM) =
;	  0322	    %NAME('SCN_',NAM)^27 + %CHARCOUNT(%STRING(NAM))^18 + UPLIT(%STRING(NAM)) %;
;	  0323	
;	  0324	BIND
;	  0325	    RSNTBL = PLIT
;	  0326		(
;	  0327		RESNAM(LSS),
;	  0328		RESNAM(LEQ),
;	  0329		RESNAM(NEQ),
;	  0330		RESNAM(EQL),
;	  0331		RESNAM(GTR),
;	  0332		RESNAM(GEQ),
;	  0333		RESNAM(PROCEDURE),
;	  0334		RESNAM(COMMAND),
;	  0335		RESNAM(SYNONYM),
;	  0336		RESNAM(NOORIGINAL),
;	  0337		RESNAM(BEGIN),
;	  0338		RESNAM(END),
;	  0339		RESNAM(EXTERNAL),
;	  0340		RESNAM(INTEGER),
;	  0341		RESNAM(STRING),
;	  0342		RESNAM(LET),
;	  0343		RESNAM(IF),
;	  0344		RESNAM(THEN),
;	  0345		RESNAM(ELSE),
;	  0346		RESNAM(GOTO),
;	  0347		RESNAM(RETURN),
;	  0348		RESNAM(CASE),
;	  0349		RESNAM(FROM),
;	  0350		RESNAM(TO),
;	  0351		RESNAM(OF),
;	  0352		RESNAM(INRANGE),
;	  0353		RESNAM(OUTRANGE),
;	  0354		RESNAM(DO),
;	  0355		RESNAM(WHILE),
;	  0356		RESNAM(UNTIL),
;	  0357		RESNAM(SELECT),
;	  0358	        RESNAM(SELECTALL),! [fun45] Multiple tags in case/select/selectall
;	  0359		RESNAM(DOCOMMAND),
;	  0360		RESNAM(ORIGINAL),
;	  0361		RESNAM(GUIDE),
;	  0362		RESNAM(PARSE),
;	  0363		RESNAM(OTHERWISE),
;	  0364	        RESNAM(ALWAYS),! [fun45] Multiple tags in CASE/select/selectall
;	  0365		RESNAM(NOINDIRECT),
;	  0366		RESNAM(DEFAULT),
;	  0367		RESNAM(HELP),
;	  0368		RESNAM(NOHELP),
;	  0369		RESNAM(WORDS),
;	  0370		RESNAM(RADIX),
;	  0371		RESNAM(PARSEONLY),
;	  0372		RESNAM(STDHELP),
;	  0373		RESNAM(TIME),
;	  0374		RESNAM(DATE),
;	  0375		RESNAM(DEFAULT_DEV),
;	  0376		RESNAM(DEFAULT_DIR),
;	  0377		RESNAM(DEFAULT_NAM),
;	  0378		RESNAM(DEFAULT_EXT),
;	  0379		RESNAM(DEFAULT_GEN),
;	  0380		RESNAM(INPUT),
;	  0381		RESNAM(OUTPUT),
;	  0382		RESNAM(WILD),
;	  0383		RESNAM(INVISIBLE),
;	  0384		RESNAM(DELETED),
;	  0385		SCN_ERROR^27 + 5^18 + UPLIT('ERROR'),
;	  0386		RESNAM(PROMPT),
;	  0387		RESNAM(NOECHO),
;	  0388		RESNAM(INVOKE),
;	  0389		RESNAM(PASSOUTPUT),
;	  0390		RESNAM(TYPEIN),
;	  0391		RESNAM(NORETURN),
;	  0392		RESNAM(GETTYPEOUT),
;	  0393		RESNAM(CLEARTYPEOUT),
;	  0394		RESNAM(KILLPROGRAM),
;	  0395		RESNAM(DISPLAY),
;	  0396		RESNAM(BINARY),
;	  0397		RESNAM(EXIT),
;	  0398		RESNAM(SAVE),
;	  0399		RESNAM(TOPROGRAM),
;	  0400		RESNAM(ABORT),
;	  0401		RESNAM(NOP),
;	  0402		RESNAM(CALL),
;	  0403		SCN_DOCOMMAND^27 + 3^18 + UPLIT('DCM'),
;	  0404		SCN_PASSOUTPUT^27 + 4^18 + UPLIT('PASO')
;	  0405		): BLOCKVECTOR[1,1] FIELD(RSNFLD);
;	  0406	
;	  0407	LITERAL
;	  0408	    RSNCNT=77;
;	  0409	
;	  0410	!
;	  0411	! Special characters
;	  0412	!
;	  0413	
;	  0414	BIND RESCHR=UPLIT (
;	  0415	    %C'+',SCN_PLUS, %C'-',SCN_MINUS,	%C'*',SCN_TIMES,	%C'/',SCN_DIV,
;	  0416	    %C'=',SCN_EQL,  %C'(',SCN_LPAREN,	%C')',SCN_RPAREN,	%C';',SCN_SEMI,
;	  0417	    %C':',SCN_COLON,%C',',SCN_COMMA,	%C'<',SCN_LSS,		%C'>',SCN_GTR,
;	  0418	    %C'[',SCN_LBRKT,%C']',SCN_RBRKT,	%C'"',0,
;	  0419	    %C'{',SCN_BEGIN, %C'}',SCN_END):VECTOR;     ! [fun42] {...} as begin...end
;	  0420	
;	  0421	LITERAL
;	  0422	    RSCCNT=17;                  ! [fun42] {...} as begin...end
;	  0423	
;	  0424	!
;	  0425	! Field type names for Parse
;	  0426	!
;	  0427	
;	M 0428	MACRO FNMDEF(NAM,VAL) =
;	  0429	    %NAME('$CM',VAL)^27 + %CHARCOUNT(%STRING(NAM))^18 + UPLIT(%STRING(NAM)) %;
;	  0430	
;	  0431	BIND
;	  0432	    FNMTBL = PLIT
;	  0433		(
;	  0434		FNMDEF(KEYWORD,KEY),
;	  0435		FNMDEF(NUMBER,NUM),
;	  0436		FNMDEF(NOISE,NOI),
;	  0437		FNMDEF(SWITCH,SWI),
;	  0438		FNMDEF(INPUTFILE,IFI),
;	  0439		FNMDEF(OUTPUTFILE,OFI),
;	  0440		FNMDEF(FILE,FIL),
;	  0441		$CMFLD^27 + 5^18 + UPLIT('FIELD'),
;	  0442	!	FNMDEF(FIELD,FLD),  doesn't work
;	  0443		FNMDEF(EOL,CFM),
;	  0444		FNMDEF(DIRECTORY,DIR),
;	  0445		FNMDEF(USERNAME,USR),
;	  0446		FNMDEF(COMMA,CMA),
;	  0447		FNMDEF(DEVICE,DEV),
;	  0448		FNMDEF(TEXT,TXT),
;	  0449		FNMDEF(DAYTIME,TAD),
;	  0450		FNMDEF(QUOTEDSTRING,QST),
;	  0451		FNMDEF(TOKEN,TOK),
;	  0452		FNMDEF(NODE,NOD),
;	  0453		FNMDEF(FILELIST,FLS),   ! [fun24]
;	  0454	        fnmdef(DIRECTORYLIST,DLS),      ! [FUN24]
;	  0455	        fnmdef(USERLIST,ULS)    ! [fun24]
;	  0456	    ): BLOCKVECTOR[1,1] FIELD(RSNFLD);
;	  0457	
;	  0458	LITERAL
;	  0459	    FNMCNT=21;                          ! [fun24]
;	  0460	
;	  0461	ROUTINE CERROR(MSG,PAR1) =	! Report compilation error
;	  0462	
;	  0463	!++
;	  0464	! Functional description:
;	  0465	!	Issue error message, type out offending source line, and stop.
;	  0466	!	The error message is provided as an ASCIZ string; anywhere a
;	  0467	!	#n appears the n'th message parameter is inserted.
;	  0468	!
;	  0469	! Formal parameters:
;	  0470	!	Address of error message string
;	  0471	!	Address of parameter string #1
;	  0472	!
;	  0473	! Implicit inputs:
;	  0474	!	LLNPTR, SCALIN
;	  0475	!
;	  0476	! Implicit outputs:
;	  0477	!	SCATOM
;	  0478	!
;	  0479	! Routine value:
;	  0480	!	Really, none; does not return.  I wish I could convince BLISS of that.
;	  0481	!
;	  0482	! Side effects:
;	  0483	!	None
;	  0484	!
;	  0485	!--
;	  0486	
;	  0487	%( Presently only works with one insert )%
;	  0488	
;	  0489	    BEGIN
;	  0490	    EXTERNAL REGISTER Z=0;
;	  0491	    LOCAL
;	  0492		IPT,			! String pointers
;	  0493		OPT,
;	  0494		POS,			! Horizontal position on line
;	  0495		INSRT,			! Insertion pointer
;	  0496		CT,			! Character count
;	  0497		CHR;
;	  0498	    IPT = CH$PTR(UPLIT (%ASCIZ 'Line '));
;	  0499	    OPT = CH$PTR(SCATOM);
;	  0500	    WHILE (CHR = CH$RCHAR_A(IPT)) NEQ 0 DO CH$WCHAR_A(.CHR,OPT);
;	  0501	    OPT = PCMITS(.SCALIN,.OPT);
;	  0502	    CH$WCHAR_A(%C':', OPT);
;	  0503	    CH$WCHAR_A(%C' ', OPT);
;	  0504	    IPT = BYTPTR(.MSG);
;	  0505	    WHILE
;	  0506		(CHR = CH$RCHAR_A(IPT)) NEQ 0
;	  0507	    DO
;	  0508		IF .CHR EQL %C'#'
;	  0509		THEN
;	  0510		    BEGIN
;	  0511		    CH$RCHAR_A(IPT);	! Skip the 1 which must follow
;	  0512		    INSRT = BYTPTR(.PAR1);
;	  0513		    WHILE (CHR = CH$RCHAR_A(INSRT)) NEQ 0 DO CH$WCHAR_A(.CHR,OPT)
;	  0514		    END
;	  0515		ELSE
;	  0516		    CH$WCHAR_A(.CHR,OPT);
;	  0517	    IPT = .LLNPTR;
;	  0518	    IF .IPT NEQ 0
;	  0519	    THEN
;	  0520		BEGIN
;	  0521		CH$WCHAR_A(%C'%',OPT);
;	  0522		CH$WCHAR_A(%C'_',OPT);
;	  0523		CH$WCHAR_A(%C'%',OPT);
;	  0524		CT = 256;
;	  0525		WHILE (CHR = CH$RCHAR_A(IPT)) NEQ $CHCRT AND .CT GTR 5
;	  0526	!	    DO (CH$WCHAR_A(.CHR,OPT); CT=.CT-1);
;	  0527		    DO
;	  0528			IF (.CHR EQL %C'%') AND  (.CT GTR 7)
;	  0529			THEN
;	  0530			    BEGIN
;	  0531			    CH$WCHAR_A(%C'%',OPT);
;	  0532			    CH$WCHAR_A(%C'%',OPT);
;	  0533			    CH$WCHAR_A(%C'%',OPT);
;	  0534			    CT = .CT-3
;	  0535			    END
;	  0536			ELSE IF (.CHR NEQ %C'%')
;	  0537			THEN
;	  0538			    BEGIN
;	  0539			    CH$WCHAR_A(.CHR,OPT);
;	  0540			    CT=.CT-1
;	  0541			    END
;	  0542			ELSE
;	  0543			    EXITLOOP;
;	  0544		CH$WCHAR_A(%C'%',OPT);
;	  0545		CH$WCHAR_A(%C'_',OPT);
;	  0546		CT = .CT - 2;
;	  0547		IPT = .LLNPTR;
;	  0548		POS = 0;
;	  0549		WHILE
;	  0550		    (CHR = CH$RCHAR_A(IPT)) NEQ $CHCRT
;	  0551		DO
;	  0552		    IF .IPT EQL .SCAPTR
;	  0553		    THEN
;	  0554			EXITLOOP
;	  0555		    ELSE
;	  0556			IF .CHR EQL $CHTAB
;	  0557			THEN
;	  0558			    DO
;	  0559				(IF (CT=.CT-1) GTR 3 THEN CH$WCHAR_A(%C'.',OPT);
;	  0560				 POS=.POS+1)
;	  0561			    UNTIL
;	  0562				.POS MOD 8 EQL 0
;	  0563			ELSE
;	  0564			    BEGIN
;	  0565			    IF (CT=.CT-1) GTR 3 THEN CH$WCHAR_A(%C'.',OPT);
;	  0566			    POS = .POS + 1
;	  0567			    END;
;	  0568		IF (CT=.CT-1) GTR 1 THEN CH$WCHAR_A(%C'^',OPT)
;	  0569		END;
;	  0570	    CH$WCHAR_A($CHNUL,OPT);
;	  0571	    PCMCER(SCATOM)
;	  0572	    END;


	TITLE	EXECPC
	TWOSEG


	.REQUEST  SYS:B362LB.REL


	RELOC	400000
P.AAA:	BYTE	(7)"C","o","n","s","t"		; Const
	BYTE	(7)"a","n","t","s"," "		; ants
	BYTE	(7)"w","o","r","k"," "		; work
	BYTE	(7)"a","r","e","a"," "		; area
	BYTE	(7)"f","u","l","l",000		; full
P.AAB:	BYTE	(7)"F","i","e","l","d"		; Field
	BYTE	(7)" ","t","y","p","e"		;  type
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g"," ","i"		; ing i
	BYTE	(7)"n"," ","P","a","r"		; n Par
	BYTE	(7)"s","e",","," ","p"		; se, p
	BYTE	(7)"e","r","h","a","p"		; erhap
	BYTE	(7)"s"," ","m","i","s"		; s mis
	BYTE	(7)"s","i","n","g"," "		; sing
	BYTE	(7)042,")",042,000,000		; ")"
P.AAC:	BYTE	(7)"N","a","m","e"," "		; Name
	BYTE	(7)"i","n","v","a","l"		; inval
	BYTE	(7)"i","d"," ","o","r"		; id or
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g",000,000		; ing
P.AAD:	BYTE	(7)"N","a","m","e"," "		; Name
	BYTE	(7)"n","o","t"," ","u"		; not u
	BYTE	(7)"n","i","q","u","e"		; nique
	BYTE	(7)000,000,000,000,000
P.AAE:	BYTE	(7)"U","n","r","e","c"		; Unrec
	BYTE	(7)"o","g","n","i","z"		; ogniz
	BYTE	(7)"e","d"," ","s","t"		; ed st
	BYTE	(7)"a","t","e","m","e"		; ateme
	BYTE	(7)"n","t"," ","k","e"		; nt ke
	BYTE	(7)"y","w","o","r","d"		; yword
	BYTE	(7)000,000,000,000,000
P.AAF:	BYTE	(7)"S","e","m","i","c"		; Semic
	BYTE	(7)"o","l","o","n"," "		; olon
	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g",000,000,000		; ng
P.AAG:	BYTE	(7)"E","N","D"," ","n"		; END n
	BYTE	(7)"o","t"," ","f","o"		; ot fo
	BYTE	(7)"u","n","d"," ","w"		; und w
	BYTE	(7)"h","e","r","e"," "		; here
	BYTE	(7)"r","e","q","u","i"		; requi
	BYTE	(7)"r","e","d",000,000		; red
P.AAH:	BYTE	(7)"D","e","s","t","i"		; Desti
	BYTE	(7)"n","a","t","i","o"		; natio
	BYTE	(7)"n"," ","n","a","m"		; n nam
	BYTE	(7)"e"," ","m","i","s"		; e mis
	BYTE	(7)"s","i","n","g",000		; sing
P.AAI:	BYTE	(7)"U","n","a","b","l"		; Unabl
	BYTE	(7)"e"," ","t","o"," "		; e to
	BYTE	(7)"r","e","c","o","g"		; recog
	BYTE	(7)"n","i","z","e"," "		; nize
	BYTE	(7)"s","t","a","t","e"		; state
	BYTE	(7)"m","e","n","t",000		; ment
P.AAJ:	BYTE	(7)"T","o","o"," ","m"		; Too m
	BYTE	(7)"a","n","y"," ","l"		; any l
	BYTE	(7)"a","b","e","l","s"		; abels
	BYTE	(7)000,000,000,000,000
P.AAK:	BYTE	(7)"C","o","l","o","n"		; Colon
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g",000,000		; ing
P.AAL:	BYTE	(7)"S","t","a","t","e"		; State
	BYTE	(7)"m","e","n","t"," "		; ment
	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g",000,000,000		; ng
P.AAM:	BYTE	(7)"I","n","t","e","g"		; Integ
	BYTE	(7)"e","r"," ","n","o"		; er no
	BYTE	(7)"t"," ","f","o","u"		; t fou
	BYTE	(7)"n","d"," ","w","h"		; nd wh
	BYTE	(7)"e","r","e"," ","r"		; ere r
	BYTE	(7)"e","q","u","i","r"		; equir
	BYTE	(7)"e","d",000,000,000		; ed
P.AAN:	BYTE	(7)"R","i","g","h","t"		; Right
	BYTE	(7)" ","p","a","r","e"		;  pare
	BYTE	(7)"n","t","h","e","s"		; nthes
	BYTE	(7)"i","s"," ","m","i"		; is mi
	BYTE	(7)"s","s","i","n","g"		; ssing
	BYTE	(7)000,000,000,000,000
P.AAO:	BYTE	(7)"T","o","o"," ","m"		; Too m
	BYTE	(7)"a","n","y"," ","v"		; any v
	BYTE	(7)"a","r","i","a","b"		; ariab
	BYTE	(7)"l","e","s",000,000		; les
P.AAP:	BYTE	(7)"L","e","f","t"," "		; Left
	BYTE	(7)"p","a","r","e","n"		; paren
	BYTE	(7)"t","h","e","s","i"		; thesi
	BYTE	(7)"s"," ","m","i","s"		; s mis
	BYTE	(7)"s","i","n","g",000		; sing
P.AAQ:	BYTE	(7)"U","n","e","x","p"		; Unexp
	BYTE	(7)"e","c","t","e","d"		; ected
	BYTE	(7)" ","e","n","d"," "		;  end
	BYTE	(7)"o","f"," ","i","n"		; of in
	BYTE	(7)"p","u","t",000,000		; put
P.AAR:	BYTE	(7)"U","n","a","b","l"		; Unabl
	BYTE	(7)"e"," ","t","o"," "		; e to
	BYTE	(7)"r","e","c","o","g"		; recog
	BYTE	(7)"n","i","z","e"," "		; nize
	BYTE	(7)"e","x","p","r","e"		; expre
	BYTE	(7)"s","s","i","o","n"		; ssion
	BYTE	(7)000,000,000,000,000
P.AAS:	BYTE	(7)"S","t","r","i","n"		; Strin
	BYTE	(7)"g"," ","m","i","s"		; g mis
	BYTE	(7)"s","i","n","g",000		; sing
P.AAT:	BYTE	(7)"O","F"," ","m","i"		; OF mi
	BYTE	(7)"s","s","i","n","g"		; ssing
	BYTE	(7)000,000,000,000,000
P.AAU:	BYTE	(7)"B","E","G","I","N"		; BEGIN
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g",000,000		; ing
P.AAV:	BYTE	(7)"S","u","p","e","r"		; Super
	BYTE	(7)"f","l","u","o","u"		; fluou
	BYTE	(7)"s"," ","r","i","g"		; s rig
	BYTE	(7)"h","t"," ","b","r"		; ht br
	BYTE	(7)"a","c","k","e","t"		; acket
	BYTE	(7)000,000,000,000,000
P.AAW:	BYTE	(7)"R","i","g","h","t"		; Right
	BYTE	(7)" ","b","r","a","c"		;  brac
	BYTE	(7)"k","e","t"," ","m"		; ket m
	BYTE	(7)"i","s","s","i","n"		; issin
	BYTE	(7)"g",000,000,000,000		; g
P.AAX:	BYTE	(7)"S","t","r","i","n"		; Strin
	BYTE	(7)"g"," ","n","o","t"		; g not
	BYTE	(7)" ","f","o","u","n"		;  foun
	BYTE	(7)"d"," ","w","h","e"		; d whe
	BYTE	(7)"r","e"," ","r","e"		; re re
	BYTE	(7)"q","u","i","r","e"		; quire
	BYTE	(7)"d",000,000,000,000		; d
P.AAY:	BYTE	(7)"O","T","H","E","R"		; OTHER
	BYTE	(7)"W","I","S","E","/"		; WISE/
	BYTE	(7)"A","L","W","A","Y"		; ALWAY
	BYTE	(7)"S"," ","M","u","s"		; S Mus
	BYTE	(7)"t"," ","b","e"," "		; t be
	BYTE	(7)"S","o","l","e"," "		; Sole
	BYTE	(7)"T","a","g",000,000		; Tag
P.ABA:	BYTE	(7)"L","S","S",000,000		; LSS
P.ABB:	BYTE	(7)"L","E","Q",000,000		; LEQ
P.ABC:	BYTE	(7)"N","E","Q",000,000		; NEQ
P.ABD:	BYTE	(7)"E","Q","L",000,000		; EQL
P.ABE:	BYTE	(7)"G","T","R",000,000		; GTR
P.ABF:	BYTE	(7)"G","E","Q",000,000		; GEQ
P.ABG:	BYTE	(7)"P","R","O","C","E"		; PROCE
	BYTE	(7)"D","U","R","E",000		; DURE
P.ABH:	BYTE	(7)"C","O","M","M","A"		; COMMA
	BYTE	(7)"N","D",000,000,000		; ND
P.ABI:	BYTE	(7)"S","Y","N","O","N"		; SYNON
	BYTE	(7)"Y","M",000,000,000		; YM
P.ABJ:	BYTE	(7)"N","O","O","R","I"		; NOORI
	BYTE	(7)"G","I","N","A","L"		; GINAL
P.ABK:	BYTE	(7)"B","E","G","I","N"		; BEGIN
P.ABL:	BYTE	(7)"E","N","D",000,000		; END
P.ABM:	BYTE	(7)"E","X","T","E","R"		; EXTER
	BYTE	(7)"N","A","L",000,000		; NAL
P.ABN:	BYTE	(7)"I","N","T","E","G"		; INTEG
	BYTE	(7)"E","R",000,000,000		; ER
P.ABO:	BYTE	(7)"S","T","R","I","N"		; STRIN
	BYTE	(7)"G",000,000,000,000		; G
P.ABP:	BYTE	(7)"L","E","T",000,000		; LET
P.ABQ:	BYTE	(7)"I","F",000,000,000		; IF
P.ABR:	BYTE	(7)"T","H","E","N",000		; THEN
P.ABS:	BYTE	(7)"E","L","S","E",000		; ELSE
P.ABT:	BYTE	(7)"G","O","T","O",000		; GOTO
P.ABU:	BYTE	(7)"R","E","T","U","R"		; RETUR
	BYTE	(7)"N",000,000,000,000		; N
P.ABV:	BYTE	(7)"C","A","S","E",000		; CASE
P.ABW:	BYTE	(7)"F","R","O","M",000		; FROM
P.ABX:	BYTE	(7)"T","O",000,000,000		; TO
P.ABY:	BYTE	(7)"O","F",000,000,000		; OF
P.ABZ:	BYTE	(7)"I","N","R","A","N"		; INRAN
	BYTE	(7)"G","E",000,000,000		; GE
P.ACA:	BYTE	(7)"O","U","T","R","A"		; OUTRA
	BYTE	(7)"N","G","E",000,000		; NGE
P.ACB:	BYTE	(7)"D","O",000,000,000		; DO
P.ACC:	BYTE	(7)"W","H","I","L","E"		; WHILE
P.ACD:	BYTE	(7)"U","N","T","I","L"		; UNTIL
P.ACE:	BYTE	(7)"S","E","L","E","C"		; SELEC
	BYTE	(7)"T",000,000,000,000		; T
P.ACF:	BYTE	(7)"S","E","L","E","C"		; SELEC
	BYTE	(7)"T","A","L","L",000		; TALL
P.ACG:	BYTE	(7)"D","O","C","O","M"		; DOCOM
	BYTE	(7)"M","A","N","D",000		; MAND
P.ACH:	BYTE	(7)"O","R","I","G","I"		; ORIGI
	BYTE	(7)"N","A","L",000,000		; NAL
P.ACI:	BYTE	(7)"G","U","I","D","E"		; GUIDE
P.ACJ:	BYTE	(7)"P","A","R","S","E"		; PARSE
P.ACK:	BYTE	(7)"O","T","H","E","R"		; OTHER
	BYTE	(7)"W","I","S","E",000		; WISE
P.ACL:	BYTE	(7)"A","L","W","A","Y"		; ALWAY
	BYTE	(7)"S",000,000,000,000		; S
P.ACM:	BYTE	(7)"N","O","I","N","D"		; NOIND
	BYTE	(7)"I","R","E","C","T"		; IRECT
P.ACN:	BYTE	(7)"D","E","F","A","U"		; DEFAU
	BYTE	(7)"L","T",000,000,000		; LT
P.ACO:	BYTE	(7)"H","E","L","P",000		; HELP
P.ACP:	BYTE	(7)"N","O","H","E","L"		; NOHEL
	BYTE	(7)"P",000,000,000,000		; P
P.ACQ:	BYTE	(7)"W","O","R","D","S"		; WORDS
P.ACR:	BYTE	(7)"R","A","D","I","X"		; RADIX
P.ACS:	BYTE	(7)"P","A","R","S","E"		; PARSE
	BYTE	(7)"O","N","L","Y",000		; ONLY
P.ACT:	BYTE	(7)"S","T","D","H","E"		; STDHE
	BYTE	(7)"L","P",000,000,000		; LP
P.ACU:	BYTE	(7)"T","I","M","E",000		; TIME
P.ACV:	BYTE	(7)"D","A","T","E",000		; DATE
P.ACW:	BYTE	(7)"D","E","F","A","U"		; DEFAU
	BYTE	(7)"L","T","_","D","E"		; LT_DE
	BYTE	(7)"V",000,000,000,000		; V
P.ACX:	BYTE	(7)"D","E","F","A","U"		; DEFAU
	BYTE	(7)"L","T","_","D","I"		; LT_DI
	BYTE	(7)"R",000,000,000,000		; R
P.ACY:	BYTE	(7)"D","E","F","A","U"		; DEFAU
	BYTE	(7)"L","T","_","N","A"		; LT_NA
	BYTE	(7)"M",000,000,000,000		; M
P.ACZ:	BYTE	(7)"D","E","F","A","U"		; DEFAU
	BYTE	(7)"L","T","_","E","X"		; LT_EX
	BYTE	(7)"T",000,000,000,000		; T
P.ADA:	BYTE	(7)"D","E","F","A","U"		; DEFAU
	BYTE	(7)"L","T","_","G","E"		; LT_GE
	BYTE	(7)"N",000,000,000,000		; N
P.ADB:	BYTE	(7)"I","N","P","U","T"		; INPUT
P.ADC:	BYTE	(7)"O","U","T","P","U"		; OUTPU
	BYTE	(7)"T",000,000,000,000		; T
P.ADD:	BYTE	(7)"W","I","L","D",000		; WILD
P.ADE:	BYTE	(7)"I","N","V","I","S"		; INVIS
	BYTE	(7)"I","B","L","E",000		; IBLE
P.ADF:	BYTE	(7)"D","E","L","E","T"		; DELET
	BYTE	(7)"E","D",000,000,000		; ED
P.ADG:	BYTE	(7)"E","R","R","O","R"		; ERROR
P.ADH:	BYTE	(7)"P","R","O","M","P"		; PROMP
	BYTE	(7)"T",000,000,000,000		; T
P.ADI:	BYTE	(7)"N","O","E","C","H"		; NOECH
	BYTE	(7)"O",000,000,000,000		; O
P.ADJ:	BYTE	(7)"I","N","V","O","K"		; INVOK
	BYTE	(7)"E",000,000,000,000		; E
P.ADK:	BYTE	(7)"P","A","S","S","O"		; PASSO
	BYTE	(7)"U","T","P","U","T"		; UTPUT
P.ADL:	BYTE	(7)"T","Y","P","E","I"		; TYPEI
	BYTE	(7)"N",000,000,000,000		; N
P.ADM:	BYTE	(7)"N","O","R","E","T"		; NORET
	BYTE	(7)"U","R","N",000,000		; URN
P.ADN:	BYTE	(7)"G","E","T","T","Y"		; GETTY
	BYTE	(7)"P","E","O","U","T"		; PEOUT
P.ADO:	BYTE	(7)"C","L","E","A","R"		; CLEAR
	BYTE	(7)"T","Y","P","E","O"		; TYPEO
	BYTE	(7)"U","T",000,000,000		; UT
P.ADP:	BYTE	(7)"K","I","L","L","P"		; KILLP
	BYTE	(7)"R","O","G","R","A"		; ROGRA
	BYTE	(7)"M",000,000,000,000		; M
P.ADQ:	BYTE	(7)"D","I","S","P","L"		; DISPL
	BYTE	(7)"A","Y",000,000,000		; AY
P.ADR:	BYTE	(7)"B","I","N","A","R"		; BINAR
	BYTE	(7)"Y",000,000,000,000		; Y
P.ADS:	BYTE	(7)"E","X","I","T",000		; EXIT
P.ADT:	BYTE	(7)"S","A","V","E",000		; SAVE
P.ADU:	BYTE	(7)"T","O","P","R","O"		; TOPRO
	BYTE	(7)"G","R","A","M",000		; GRAM
P.ADV:	BYTE	(7)"A","B","O","R","T"		; ABORT
P.ADW:	BYTE	(7)"N","O","P",000,000		; NOP
P.ADX:	BYTE	(7)"C","A","L","L",000		; CALL
P.ADY:	BYTE	(7)"D","C","M",000,000		; DCM
P.ADZ:	BYTE	(7)"P","A","S","O",000		; PASO
	EXP	116
P.AAZ:	EXP	P.ABA+10003000000
	EXP	P.ABB+11003000000
	EXP	P.ABC+12003000000
	EXP	P.ABD+13003000000
	EXP	P.ABE+14003000000
	EXP	P.ABF+15003000000
	EXP	P.ABG+25011000000
	EXP	P.ABH+26007000000
	EXP	P.ABI+27007000000
	EXP	P.ABJ+30012000000
	EXP	P.ABK+31005000000
	EXP	P.ABL+32003000000
	EXP	P.ABM+33010000000
	EXP	P.ABN+34007000000
	EXP	P.ABO+35006000000
	EXP	P.ABP+36003000000
	EXP	P.ABQ+37002000000
	EXP	P.ABR+40004000000
	EXP	P.ABS+41004000000
	EXP	P.ABT+42004000000
	EXP	P.ABU+43006000000
	EXP	P.ABV+44004000000
	EXP	P.ABW+45004000000
	EXP	P.ABX+46002000000
	EXP	P.ABY+47002000000
	EXP	P.ABZ+50007000000
	EXP	P.ACA+51010000000
	EXP	P.ACB+52002000000
	EXP	P.ACC+53005000000
	EXP	P.ACD+54005000000
	EXP	P.ACE+55006000000
	EXP	P.ACF+133011000000
	EXP	P.ACG+56011000000
	EXP	P.ACH+57010000000
	EXP	P.ACI+60005000000
	EXP	P.ACJ+61005000000
	EXP	P.ACK+62011000000
	EXP	P.ACL+132006000000
	EXP	P.ACM+63012000000
	EXP	P.ACN+64007000000
	EXP	P.ACO+65004000000
	EXP	P.ACP+66006000000
	EXP	P.ACQ+67005000000
	EXP	P.ACR+70005000000
	EXP	P.ACS+71011000000
	EXP	P.ACT+72007000000
	EXP	P.ACU+73004000000
	EXP	P.ACV+74004000000
	EXP	P.ACW+75013000000
	EXP	P.ACX+76013000000
	EXP	P.ACY+77013000000
	EXP	P.ACZ+100013000000
	EXP	P.ADA+101013000000
	EXP	P.ADB+102005000000
	EXP	P.ADC+103006000000
	EXP	P.ADD+104004000000
	EXP	P.ADE+105011000000
	EXP	P.ADF+106007000000
	EXP	P.ADG+107005000000
	EXP	P.ADH+110006000000
	EXP	P.ADI+111006000000
	EXP	P.ADJ+113006000000
	EXP	P.ADK+114012000000
	EXP	P.ADL+115006000000
	EXP	P.ADM+116010000000
	EXP	P.ADN+117012000000
	EXP	P.ADO+120014000000
	EXP	P.ADP+121013000000
	EXP	P.ADQ+122007000000
	EXP	P.ADR+123006000000
	EXP	P.ADS+124004000000
	EXP	P.ADT+125004000000
	EXP	P.ADU+126011000000
	EXP	P.ADV+127005000000
	EXP	P.ADW+130003000000
	EXP	P.ADX+131004000000
	EXP	P.ADY+56003000000
	EXP	P.ADZ+114004000000
P.AEA:	EXP	53
	EXP	4
	EXP	55
	EXP	5
	EXP	52
	EXP	6
	EXP	57
	EXP	7
	EXP	75
	EXP	13
	EXP	50
	EXP	16
	EXP	51
	EXP	17
	EXP	73
	EXP	20
	EXP	72
	EXP	22
	EXP	54
	EXP	21
	EXP	74
	EXP	10
	EXP	76
	EXP	14
	EXP	133
	EXP	23
	EXP	135
	EXP	24
	EXP	42
	EXP	0
	EXP	173
	EXP	31
	EXP	175
	EXP	32
P.AEC:	BYTE	(7)"K","E","Y","W","O"		; KEYWO
	BYTE	(7)"R","D",000,000,000		; RD
P.AED:	BYTE	(7)"N","U","M","B","E"		; NUMBE
	BYTE	(7)"R",000,000,000,000		; R
P.AEE:	BYTE	(7)"N","O","I","S","E"		; NOISE
P.AEF:	BYTE	(7)"S","W","I","T","C"		; SWITC
	BYTE	(7)"H",000,000,000,000		; H
P.AEG:	BYTE	(7)"I","N","P","U","T"		; INPUT
	BYTE	(7)"F","I","L","E",000		; FILE
P.AEH:	BYTE	(7)"O","U","T","P","U"		; OUTPU
	BYTE	(7)"T","F","I","L","E"		; TFILE
P.AEI:	BYTE	(7)"F","I","L","E",000		; FILE
P.AEJ:	BYTE	(7)"F","I","E","L","D"		; FIELD
P.AEK:	BYTE	(7)"E","O","L",000,000		; EOL
P.AEL:	BYTE	(7)"D","I","R","E","C"		; DIREC
	BYTE	(7)"T","O","R","Y",000		; TORY
P.AEM:	BYTE	(7)"U","S","E","R","N"		; USERN
	BYTE	(7)"A","M","E",000,000		; AME
P.AEN:	BYTE	(7)"C","O","M","M","A"		; COMMA
P.AEO:	BYTE	(7)"D","E","V","I","C"		; DEVIC
	BYTE	(7)"E",000,000,000,000		; E
P.AEP:	BYTE	(7)"T","E","X","T",000		; TEXT
P.AEQ:	BYTE	(7)"D","A","Y","T","I"		; DAYTI
	BYTE	(7)"M","E",000,000,000		; ME
P.AER:	BYTE	(7)"Q","U","O","T","E"		; QUOTE
	BYTE	(7)"D","S","T","R","I"		; DSTRI
	BYTE	(7)"N","G",000,000,000		; NG
P.AES:	BYTE	(7)"T","O","K","E","N"		; TOKEN
P.AET:	BYTE	(7)"N","O","D","E",000		; NODE
P.AEU:	BYTE	(7)"F","I","L","E","L"		; FILEL
	BYTE	(7)"I","S","T",000,000		; IST
P.AEV:	BYTE	(7)"D","I","R","E","C"		; DIREC
	BYTE	(7)"T","O","R","Y","L"		; TORYL
	BYTE	(7)"I","S","T",000,000		; IST
P.AEW:	BYTE	(7)"U","S","E","R","L"		; USERL
	BYTE	(7)"I","S","T",000,000		; IST
	EXP	25
P.AEB:	EXP	P.AEC+7000000
	EXP	P.AED+1006000000
	EXP	P.AEE+2005000000
	EXP	P.AEF+3006000000
	EXP	P.AEG+4011000000
	EXP	P.AEH+5012000000
	EXP	P.AEI+6004000000
	EXP	P.AEJ+7005000000
	EXP	P.AEK+10003000000
	EXP	P.AEL+11011000000
	EXP	P.AEM+12010000000
	EXP	P.AEN+13005000000
	EXP	P.AEO+16006000000
	EXP	P.AEP+17004000000
	EXP	P.AEQ+20007000000
	EXP	P.AER+21014000000
	EXP	P.AES+23005000000
	EXP	P.AET+26004000000
	EXP	P.AEU+27010000000
	EXP	P.AEV+30015000000
	EXP	P.AEW+31010000000
P.AEX:	BYTE	(7)"L","i","n","e"," "		; Line
	BYTE	(7)000,000,000,000,000


	RELOC	0
PCCWKE::EXP	U.101


	EXTERN	PCMCER, PCMITS, PCMGMM, PCIFGS, PCICGS, PCIDFV, PCIDFS, PCIUDF, GTBUFX, BUF0, PCTEXT
	EXTERN	PCTXFR, PCGBST, PSDEFN, DICT, PSDEFL


; CERM1
U.51=		    P.AAA
; CERM2
U.52=		    P.AAB
; CERM3
U.53=		    P.AAC
; CERM4
U.54=		    P.AAD
; CERM5
U.55=		    P.AAE
; CERM6
U.56=		    P.AAF
; CERM7
U.57=		    P.AAG
; CERM8
U.58=		    P.AAH
; CERM9
U.59=		    P.AAI
; CERM10
U.60=		    P.AAJ
; CERM11
U.61=		    P.AAK
; CERM12
U.62=		    P.AAL
; CERM13
U.63=		    P.AAM
; CERM14
U.64=		    P.AAN
; CERM15
U.65=		    P.AAO
; CERM16
U.66=		    P.AAP
; CERM17
U.67=		    P.AAQ
; CERM18
U.68=		    P.AAR
; CERM19
U.69=		    P.AAS
; CERM20
U.70=		    P.AAT
; CERM21
U.71=		    P.AAU
; CERM22
U.72=		    P.AAV
; CERM23
U.73=		    P.AAW
; CERM24
U.74=		    P.AAX
; CERM101
U.75=		    P.AAY
; CODWRK
U.76=		    BUF0
; SYMWRK
U.77=		    BUF0+2000
; CNSWRK
U.78=		    BUF0+3000
; CURRTN
U.79=		    BUF0+11000
; CURNML
U.80=		    BUF0+11010
; CURCLS
U.81=		    BUF0+11011
; CURTYP
U.82=		    BUF0+11012
; CURTXT
U.83=		    BUF0+11013
; PRCARG
U.84=		    BUF0+11014
; CMDARG
U.85=		    BUF0+11024
; NEXTIN
U.86=		    BUF0+11025
; SCAPTR
U.87=		    BUF0+11026
; SCALIN
U.88=		    BUF0+11027
; LLNPTR
U.89=		    BUF0+11030
; SCATRP
U.90=		    BUF0+11031
; SCABUF
U.91=		    BUF0+11032
; SCATOM
U.92=		    BUF0+11063
; SCALEN
U.93=		    BUF0+11232
; SCANUM
U.94=		    BUF0+11233
; SCACOD
U.95=		    BUF0+11234
; NUMVRS
U.96=		    BUF0+11235
; CONSTP
U.97=		    BUF0+11236
; SYMTBP
U.98=		    BUF0+11237
; LBLNAM
U.99=		    BUF0+11240
; LBLADR
U.100=		    BUF0+11264
; LBLCNT
U.101=		    BUF0+11310
; RSNTBL
U.103=		    P.AAZ
; RESCHR
U.104=		    P.AEA
; FNMTBL
U.105=		    P.AEB


AC0=	0
AC1=	1
AC2=	2
AC3=	3
AC4=	4
AC5=	5
AC6=	6
AC7=	7
AC10=	10
AC11=	11
AC12=	12
AC13=	13
AC14=	14
FP=	15
AC16=	16
SP=	17


	RELOC	400656
; CERROR
U.1:	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC11,AC2			; PAR1,AC2
	MOVE	AC12,AC1			; MSG,AC1
	MOVE	AC13,C.1			; IPT,[POINT 7,P.AEX-1,34]  <1,7>
	MOVE	AC4,C.2				; OPT,[POINT 7,BUF0+11062,34]  <1,7>
L.1:	ILDB	AC14,AC13			; CHR,IPT
	JUMPE	AC14,L.2			; CHR,L.2
	IDPB	AC14,AC4			; CHR,OPT
	JRST	L.1				; L.1
L.2:	MOVE	AC1,U.88			; AC1,SCALIN
	MOVE	AC2,AC4				; AC2,OPT
	PUSHJ	SP,PCMITS			; SP,PCMITS
	MOVE	AC4,AC1				; OPT,AC1
	MOVEI	AC1,72				; AC1,72
	IDPB	AC1,AC4				; AC1,OPT
	MOVEI	AC1,40				; AC1,40
	IDPB	AC1,AC4				; AC1,OPT
	MOVE	AC1,AC12			; HLF,MSG
	HRLI	AC1,-337100			; HLF,-337100
	MOVE	AC13,AC1			; IPT,HLF
L.3:	ILDB	AC14,AC13			; CHR,IPT
	JUMPE	AC14,L.6			; CHR,L.6
	CAIE	AC14,43				; CHR,43
	JRST	L.5				; L.5
	IBP	AC13				; IPT
	MOVE	AC1,AC11			; HLF,PAR1
	HRLI	AC1,-337100			; HLF,-337100
	MOVE	AC2,AC1				; INSRT,HLF
L.4:	ILDB	AC14,AC2			; CHR,INSRT
	JUMPE	AC14,L.3			; CHR,L.3
	IDPB	AC14,AC4			; CHR,OPT
	JRST	L.4				; L.4
L.5:	IDPB	AC14,AC4			; CHR,OPT
	JRST	L.3				; L.3
L.6:	MOVE	AC13,U.89			; IPT,LLNPTR
	JUMPE	AC13,L.16			; IPT,L.16
	MOVEI	AC1,45				; AC1,45
	IDPB	AC1,AC4				; AC1,OPT
	MOVEI	AC1,137				; AC1,137
	IDPB	AC1,AC4				; AC1,OPT
	MOVEI	AC1,45				; AC1,45
	IDPB	AC1,AC4				; AC1,OPT
	MOVEI	AC3,400				; CT,400
L.7:	ILDB	AC14,AC13			; CHR,IPT
	CAIE	AC14,15				; CHR,15
	CAIG	AC3,5				; CT,5
	JRST	L.9				; L.9
	CAIN	AC14,45				; CHR,45
	CAIG	AC3,7				; CT,7
	JRST	L.8				; L.8
	MOVEI	AC1,45				; AC1,45
	IDPB	AC1,AC4				; AC1,OPT
	MOVEI	AC1,45				; AC1,45
	IDPB	AC1,AC4				; AC1,OPT
	MOVEI	AC1,45				; AC1,45
	IDPB	AC1,AC4				; AC1,OPT
	SUBI	AC3,3				; CT,3
	JRST	L.7				; L.7
L.8:	CAIN	AC14,45				; CHR,45
	JRST	L.9				; L.9
	IDPB	AC14,AC4			; CHR,OPT
	SOJA	AC3,L.7				; CT,L.7
L.9:	MOVEI	AC1,45				; AC1,45
	IDPB	AC1,AC4				; AC1,OPT
	MOVEI	AC1,137				; AC1,137
	IDPB	AC1,AC4				; AC1,OPT
	SUBI	AC3,2				; CT,2
	MOVE	AC13,U.89			; IPT,LLNPTR
	SETZ	AC5,				; POS,
L.10:	ILDB	AC14,AC13			; CHR,IPT
	CAIE	AC14,15				; CHR,15
	CAMN	AC13,U.87			; IPT,SCAPTR
	JRST	L.15				; L.15
	CAIE	AC14,11				; CHR,11
	JRST	L.13				; L.13
L.11:	SUBI	AC3,1				; CT,1
	CAIG	AC3,3				; CT,3
	JRST	L.12				; L.12
	MOVEI	AC1,56				; AC1,56
	IDPB	AC1,AC4				; AC1,OPT
L.12:	AOS	AC1,AC5				; AC1,POS
	IDIVI	AC1,10				; AC1,10
	JUMPN	AC2,L.11			; AC2,L.11
	JRST	L.10				; L.10
L.13:	SUBI	AC3,1				; CT,1
	CAIG	AC3,3				; CT,3
	JRST	L.14				; L.14
	MOVEI	AC1,56				; AC1,56
	IDPB	AC1,AC4				; AC1,OPT
L.14:	AOJA	AC5,L.10			; POS,L.10
L.15:	SUBI	AC3,1				; CT,1
	CAIG	AC3,1				; CT,1
	JRST	L.16				; L.16
	MOVEI	AC1,136				; AC1,136
	IDPB	AC1,AC4				; AC1,OPT
L.16:	SETZ	AC1,				; AC1,
	IDPB	AC1,AC4				; AC1,OPT
	MOVE	AC1,C.3				; AC1,[SCATOM]
	PUSHJ	SP,PCMCER			; SP,PCMCER
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,
C.1:	POINT	7,P.AEX-1,34			; 7,P.AEX-1,34
C.2:	POINT	7,BUF0+11062,34			; 7,BUF0+11062,34
C.3:	EXP	U.92				; SCATOM

; Routine Size:  110 words


;	  0573	
;	  0574	ROUTINE SCACHR =		! Return next character from input stream
;	  0575	
;	  0576	!++
;	  0577	! Functional description:
;	  0578	!	Returns next character from source input stream.
;	  0579	!
;	  0580	! Formal parameters:
;	  0581	!	None
;	  0582	!
;	  0583	! Implicit inputs:
;	  0584	!	Source pointer
;	  0585	!
;	  0586	! Implicit outputs:
;	  0587	!	Last line-start pointer, line counter
;	  0588	!
;	  0589	! Routine value:
;	  0590	!	ASCII character from source; a null indicates the end
;	  0591	!
;	  0592	! Side effects:
;	  0593	!	None
;	  0594	!
;	  0595	!--
;	  0596	
;	  0597	    BEGIN
;	  0598	    LOCAL
;	  0599		CHR;
;	  0600	    CHR = CH$RCHAR_A(SCAPTR);
;	  0601	    IF .CHR EQL $CHLFD OR .CHR EQL $CHFFD
;	  0602	    THEN
;	  0603		BEGIN
;	  0604		SCALIN = .SCALIN + 1;
;	  0605		LLNPTR = .SCAPTR
;	  0606		END
;	  0607	    ELSE
;	  0608	    IF .CHR EQL $CHNUL THEN LLNPTR = 0;
;	  0609	    .CHR
;	  0610	    END;


; SCACHR
U.2:	ILDB	AC1,U.87			; CHR,SCAPTR
	CAIN	AC1,12				; CHR,12
	JRST	L.17				; L.17
	CAIE	AC1,14				; CHR,14
	JRST	L.18				; L.18
L.17:	AOS	U.88				; SCALIN
	MOVE	AC2,U.87			; AC2,SCAPTR
	MOVEM	AC2,U.89			; AC2,LLNPTR
	POPJ	SP,				; SP,
L.18:	JUMPN	AC1,L.19			; CHR,L.19
	SETZM	U.89				; LLNPTR
L.19:	POPJ	SP,				; SP,

; Routine Size:  12 words


;	  0611	
;	  0612	ROUTINE SCAN =			! Get next atom
;	  0613	
;	  0614	!++
;	  0615	! Functional description:
;	  0616	!	  Reads next atom from source file and converts it into scan code.
;	  0617	!	Conversion may require resolution of reserved words and special
;	  0618	!	symbols, and interpretation of numeric and string constants.
;	  0619	!	Comments are skipped as they are read; alphabetic atoms are folded
;	  0620	!	to upper case (outside quoted strings).  Alphabetic atoms are
;	  0621	!	returned transparently (i.e., not converted into reserved words)
;	  0622	!	if the SCATRP flag is set.  Returns scan code; end-of-file is
;	  0623	!	represented by a particular scan code.  If atom type requires it,
;	  0624	!	atom is left in	SCATOM, with length in SCALEN, or in SCANUM.
;	  0625	!
;	  0626	! Formal parameters:
;	  0627	!	None
;	  0628	!
;	  0629	! Implicit inputs:
;	  0630	!	Source characters, reserved character and word tables, SCATRP
;	  0631	!
;	  0632	! Implicit outputs:
;	  0633	!	SCATOM, SCALEN, SCACOD, SCANUM
;	  0634	!
;	  0635	! Routine value:
;	  0636	!	Scan code
;	  0637	!
;	  0638	! Side effects:
;	  0639	!	None
;	  0640	!
;	  0641	!--
;	  0642	
;	  0643	    BEGIN
;	  0644	    EXTERNAL REGISTER Z=0;
;	  0645	    LOCAL CHR;
;	  0646	                                ! [fun42]+ Inline comments !{...}!
;	  0647	    !+
;	  0648	    ! Scan service routine Long_comment
;	  0649	    ! We have parsed a "!{" (the { is in .chr.
;	  0650	    ! Scan past long comments, skipping imbedded comments and strings.
;	  0651	    ! No other side effects.
;	  0652	    !-
;	  0653	
;	  0654	    routine long_comment : novalue = begin
;	  0655	    external register z = 0;
;	  0656	    local
;	  0657	       chr,   
;	  0658	       count;                       ! Number of unclosed !{ encountered
;	  0659	
;	  0660	    count = 1;
;	  0661	    chr = scachr();
;	  0662	    while 1 do begin            ! LOOP on all characters within
;	  0663	                                ! long comment
;	  0664	                                !  !!! each alternative which loops
;	  0665	                                ! must grab the next character in .chr
;	  0666	       if .chr eql 0 then
;	  0667	          error ('Unterminated !{....}! comment')
;	  0668	       else if .chr eql %c'}' then begin ! Check for imbedded comments
;	  0669	          if (chr = scachr()) eql %c'!' then begin
;	  0670	             if (count = .count - 1) eql 0 then
;	  0671	                exitloop;
;	  0672	             end
;	  0673	          end
;	  0674	       else if .chr eql %c'!' then begin  ! New imbedded comment ?
;	  0675	          if (chr = scachr()) eql %c'{' then begin
;	  0676	             count = .count + 1;
;	  0677	             chr = scachr();
;	  0678	             end;
;	  0679	          end
;	  0680	       else
;	  0681	          chr = scachr();
;	  0682	         
;	  0683	       end;
;	  0684	    end;


P.AEY:	BYTE	(7)"U","n","t","e","r"		; Unter
	BYTE	(7)"m","i","n","a","t"		; minat
	BYTE	(7)"e","d"," ","!","{"		; ed !{
	BYTE	(7)".",".",".",".","}"		; ....}
	BYTE	(7)"!"," ","c","o","m"		; ! com
	BYTE	(7)"m","e","n","t",000		; ment


; LONG_COMMENT
U.106:	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVEI	AC13,1				; COUNT,1
L.20:	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
L.21:	JUMPN	AC14,L.22			; CHR,L.22
	MOVEI	AC1,P.AEY			; AC1,P.AEY
	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.21				; L.21
L.22:	CAIE	AC14,175			; CHR,175
	JRST	L.23				; L.23
	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIE	AC14,41				; CHR,41
	JRST	L.21				; L.21
	SOJN	AC13,L.21			; COUNT,L.21
	JRST	L.24				; L.24
L.23:	CAIE	AC14,41				; CHR,41
	JRST	L.20				; L.20
	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIE	AC14,173			; CHR,173
	JRST	L.21				; L.21
	AOJA	AC13,L.20			; COUNT,L.20
L.24:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  27 words


;	  0685	                                ! [fun42]- Inline comments !{...}!
;	  0686	    DO BEGIN 
;	  0687		CHR = SCACHR();
;	  0688	                                ! [fun42]+ Inline comments !{...}!
;	  0689		while .chr eql %c'!' do begin
;	  0690	            chr = scachr();
;	  0691	            if .chr eql %c'{' then begin
;	  0692	               long_comment();
;	  0693	               chr = scachr();
;	  0694	               end
;	  0695	            else begin
;	  0696	               while (.chr neq $chlfd) and (.chr neq $chffd) and (.chr neq 0)
;	  0697	                  do chr = scachr();
;	  0698	               exitloop;
;	  0699	               end;
;	  0700	            end 
;	  0701	        end
;	  0702	                                ! [fun42]- Inline comments !{...}!
;	  0703	! FINAL TEST OF LOOP SCANNING FOR BLANKS
;	  0704	    WHILE
;	  0705		((.CHR EQL %C' ') OR (.CHR EQL $CHCRT) OR (.CHR EQL $CHLFD)
;	  0706		 OR (.CHR EQL 9) OR (.CHR EQL $CHFFD));
;	  0707	    IF .CHR LEQ 0 THEN RETURN (SCACOD=SCN_EOFILE);
;	  0708	    IF .CHR GEQ %C'a' AND .CHR LEQ %C'z' THEN CHR = .CHR - %C'a'+%C'A';
;	  0709	    SELECTONE .CHR OF
;	  0710		SET
;	  0711	[%C'A' TO %C'Z']:
;	  0712		BEGIN
;	  0713		! Scan an alphanumeric string of some sort, either a reserved
;	  0714		! word or a user identifier.  Copy the string into the atom
;	  0715		! buffer, then look it up in the reserved word table and
;	  0716		! set the scan code appropriately.
;	  0717		LOCAL
;	  0718		    PTR,		! String pointer
;	  0719		    LEN,		! String length
;	  0720		    PTRI,		! More pointers
;	  0721		    PTRO;
;	  0722		PTR = CH$PTR(SCATOM);
;	  0723		SCATOM[0] = 0;
;	  0724		LEN=0;
;	  0725		DO
;	  0726		    BEGIN
;	  0727		    LEN=.LEN+1;
;	  0728		    IF .LEN GTR 40 THEN ERROR('Atom too long');
;	  0729		    CH$WCHAR_A(.CHR,PTR);
;	  0730		    CHR = SCACHR();
;	  0731		    IF .CHR GEQ %C'a' AND .CHR LEQ %C'z' THEN CHR = .CHR - %C'a'+%C'A'
;	  0732		    END
;	  0733		WHILE
;	  0734		    (.CHR GEQ %C'A' AND .CHR LEQ %C'Z') OR
;	  0735		    (.CHR GEQ %C'0' AND .CHR LEQ %C'9') OR .CHR EQL %C'_';
;	  0736		CH$WCHAR_A($CHNUL,PTR);
;	  0737		SCACOD = SCN_IDENT;
;	  0738		SCALEN = .LEN;
;	  0739		IF .SCATRP EQL 0
;	  0740		THEN
;	  0741		(DECR PTR FROM RSNCNT-1 DO
;	  0742		    IF .LEN EQL .RSNTBL[.PTR,RSNLEN]
;	  0743		    THEN
;	  0744			IF CH$EQL(.LEN,CH$PTR(SCATOM),
;	  0745				  .LEN,BYTPTR(.RSNTBL[.PTR,RSNSTR]))
;	  0746			THEN
;	  0747			    (SCACOD = .RSNTBL[.PTR,RSNSCN]; EXITLOOP);
;	  0748		0)
;	  0749		END;
;	  0750	[%C'0' TO %C'9']:
;	  0751		    BEGIN
;	  0752	                               ! [fun25]+ Scan based numbers
;	  0753		    ! Scan a based number base%number, store in atom buffer.
;	  0754		    LOCAL NUM,BASE;
;	  0755		    NUM=0;
;	  0756		    DO
;	  0757			(NUM=.NUM*10+.CHR-%C'0'; CHR=SCACHR())
;	  0758		    WHILE
;	  0759			.CHR GEQ %C'0' AND .CHR LEQ %C'9';
;	  0760	            if .chr eql %c'%' then begin
;	  0761	               local            ! [fun63]
;	  0762	
;	  0763	                  numhigh;      ! [fun63]
;	  0764	               if (.num lss 2 or .num gtr 36) then      ! based number
;	  0765	                  error ('Invalid number base');
;	  0766	               base = .num;
;	  0767	               num = 0;
;	  0768	               numhigh = 0;
;	  0769	               while 1 do begin
;	  0770	                  chr = scachr();
;	  0771	                  selectone .chr of set
;	  0772	[%c'0' to %c'9']:
;	  0773	                     chr = .chr - %c'0';
;	  0774	[%c'A' to %c'Z']:
;	  0775	                     chr = .chr - %c'A' + 10;
;	  0776	[%c'a' to %c'z']:
;	  0777	                     chr = .chr - %c'a' + 10;
;	  0778	[otherwise]:
;	  0779	                     exitloop;
;	  0780	                     tes;
;	  0781	                  if .chr geq .base then
;	  0782	                     exitloop;
;	  0783	                                ! [fun63]+
;	  0784	                  begin         !  num = .num * .base + .chr;
;	  0785	                     register
;	  0786	                        r1=1, r2=2, r3=3, r4=4;
;	  0787	                     r1 = .numhigh;
;	  0788	                     r2 = .num;
;	  0789	                     r3 = 0;    ! dmul .num,.base
;	  0790	                     r4 = .base;
;	  0791	                     machop (%o'116', 1, 3);
;	  0792	                     r2 = .chr; ! dadd .result,.chr
;	  0793	                     machop (%o'114', 1, 3);
;	  0794	                     numhigh = .r1;
;	  0795	                     num = .r2;
;	  0796	                     end;
;	  0797	                  if .numhigh gtr 1 then error ('Number too big');
;	  0798	                                ! end of machine code section
;	  0799	                  end;          ! End loop assembling based number
;	  0800	
;	  0801	               if .numhigh eql 1 then   ! Fix high bit
;	  0802	                  num = .num or %o'400000000000';
;	  0803	               end;             ! End od number assembly
;	  0804	                                ! [fun63]-
;	  0805	            scanum = .num;      ! Store scanned number
;	  0806	                                ! [fun25]- Scan based numbers
;	  0807		    SCACOD = SCN_NUMB
;	  0808		    END;
;	  0809	[%C'$']:
;	  0810		    BEGIN
;	  0811		    ! Scan a system identifier, store in atom buffer
;	  0812		    LOCAL
;	  0813			PTR,		! Pointer to atom buffer
;	  0814			LEN;		! Name length
;	  0815		    PTR = CH$PTR(SCATOM);
;	  0816		    SCATOM[0] = 0;
;	  0817		    LEN = 0;
;	  0818		    DO
;	  0819			BEGIN
;	  0820			CHR = SCACHR();
;	  0821			IF .CHR GEQ %C'a' AND .CHR LEQ %C'z' THEN CHR=.CHR-%C'a'+%C'A';
;	  0822			IF (.CHR GEQ %C'A' AND .CHR LEQ %C'Z') OR .CHR EQL %C'_'
;	  0823	                OR (.CHR GEQ %C'0' AND .CHR LEQ %C'9')  ! [fun40] allow digits
;	  0824			THEN
;	  0825			    BEGIN
;	  0826			    CH$WCHAR_A(.CHR,PTR);
;	  0827			    LEN = .LEN + 1
;	  0828			    END
;	  0829			END
;	  0830		    WHILE
;	  0831			(.CHR GEQ %C'A' AND .CHR LEQ %C'Z') OR .CHR EQL %C'_'
;	  0832	                OR (.CHR GEQ %C'0' AND .CHR LEQ %C'9'); ! [fun40] allow digits
;	  0833		    PTR =
;	  0834			(DECR I FROM PSDEFL-1 DO
;	  0835			    IF .PSDEFN[.I,SYN_NML] EQL .LEN THEN
;	  0836				IF CH$EQL(  .LEN,CH$PTR(SCATOM),
;	  0837					    .LEN,BYTPTR(.PSDEFN[.I,SYN_NAM]))
;	  0838				    THEN
;	  0839					EXITLOOP .I);
;	  0840		    IF .PTR LSS 0 THEN ERROR('No such system name');
;	  0841		    SCATOM = .PTR;
;	  0842		    SCACOD = SCN_SYSNAME
;	  0843		    END;
;	  0844	[OTHERWISE]:
;	  0845		    BEGIN
;	  0846		    ! Scan a special character
;	  0847		    SCACOD =
;	  0848		       (DECR I FROM RSCCNT-1 DO
;	  0849			    IF .CHR EQL .RESCHR[.I*2]
;	  0850			    THEN
;	  0851				EXITLOOP .RESCHR[.I*2+1]);
;	  0852		    IF .SCACOD LSS 0 THEN ERROR('Illegal character');
;	  0853		    IF .CHR EQL %C'"'
;	  0854		    THEN
;	  0855			BEGIN
;	  0856			! Quoted string
;	  0857			LOCAL
;	  0858			    LEN,
;	  0859			    PTRO;
;	  0860			PTRO = CH$PTR(SCATOM);
;	  0861			LEN=0;
;	  0862			WHILE
;	  0863			    1
;	  0864			DO
;	  0865			    BEGIN
;	  0866			    CHR = SCACHR();
;	  0867			    IF .CHR EQL %C'"'
;	  0868			    THEN
;	  0869				BEGIN
;	  0870				CHR = SCACHR();
;	  0871				IF .CHR NEQ %C'"' THEN EXITLOOP
;	  0872				END;
;	  0873			    LEN = .LEN + 1;
;	  0874			    IF .LEN GTR 512 THEN ERROR('String over 512 characters');
;	  0875			    CH$WCHAR_A(.CHR,PTRO)
;	  0876			    END;
;	  0877			CH$WCHAR_A($CHNUL,PTRO);
;	  0878			SCACOD = SCN_QSTRING;
;	  0879			SCALEN = .LEN
;	  0880			END
;	  0881		    ELSE
;	  0882		    IF .CHR EQL %C'<'
;	  0883		    THEN
;	  0884			BEGIN
;	  0885			CHR = SCACHR();
;	  0886			IF .CHR EQL %C'>'
;	  0887			THEN
;	  0888			    BEGIN
;	  0889			    SCACOD = SCN_NEQ;
;	  0890			    SCACHR()
;	  0891			    END
;	  0892			ELSE
;	  0893			IF .CHR EQL %C'='
;	  0894			THEN
;	  0895			    BEGIN
;	  0896			    SCACOD = SCN_LEQ;
;	  0897			    SCACHR()
;	  0898			    END
;	  0899			END
;	  0900		    ELSE
;	  0901		    IF .CHR EQL %C'>'
;	  0902		    THEN
;	  0903			BEGIN
;	  0904			IF SCACHR() EQL %C'='
;	  0905			THEN
;	  0906			    BEGIN
;	  0907			    SCACOD = SCN_GEQ;
;	  0908			    SCACHR()
;	  0909			    END
;	  0910			END
;	  0911		    ELSE
;	  0912			SCACHR()
;	  0913		    END;
;	  0914		TES;
;	  0915	    SCAPTR = CH$PLUS(.SCAPTR, -1);
;	  0916	    .SCACOD
;	  0917	END;


P.AEZ:	BYTE	(7)"A","t","o","m"," "		; Atom
	BYTE	(7)"t","o","o"," ","l"		; too l
	BYTE	(7)"o","n","g",000,000		; ong
P.AFA:	BYTE	(7)"I","n","v","a","l"		; Inval
	BYTE	(7)"i","d"," ","n","u"		; id nu
	BYTE	(7)"m","b","e","r"," "		; mber
	BYTE	(7)"b","a","s","e",000		; base
P.AFB:	BYTE	(7)"N","u","m","b","e"		; Numbe
	BYTE	(7)"r"," ","t","o","o"		; r too
	BYTE	(7)" ","b","i","g",000		;  big
P.AFC:	BYTE	(7)"N","o"," ","s","u"		; No su
	BYTE	(7)"c","h"," ","s","y"		; ch sy
	BYTE	(7)"s","t","e","m"," "		; stem
	BYTE	(7)"n","a","m","e",000		; name
P.AFD:	BYTE	(7)"I","l","l","e","g"		; Illeg
	BYTE	(7)"a","l"," ","c","h"		; al ch
	BYTE	(7)"a","r","a","c","t"		; aract
	BYTE	(7)"e","r",000,000,000		; er
P.AFE:	BYTE	(7)"S","t","r","i","n"		; Strin
	BYTE	(7)"g"," ","o","v","e"		; g ove
	BYTE	(7)"r"," ","5","1","2"		; r 512
	BYTE	(7)" ","c","h","a","r"		;  char
	BYTE	(7)"a","c","t","e","r"		; acter
	BYTE	(7)"s",000,000,000,000		; s


; SCAN
U.3:	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
L.25:	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIE	AC14,41				; CHR,41
	JRST	L.27				; L.27
	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIE	AC14,173			; CHR,173
	JRST	L.26				; L.26
	PUSHJ	SP,U.106			; SP,LONG_COMMENT
	JRST	L.25				; L.25
L.26:	CAIE	AC14,12				; CHR,12
	CAIN	AC14,14				; CHR,14
	JRST	L.27				; L.27
	JUMPE	AC14,L.27			; CHR,L.27
	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	JRST	L.26				; L.26
L.27:	CAIE	AC14,40				; CHR,40
	CAIN	AC14,15				; CHR,15
	JRST	L.25				; L.25
	CAIE	AC14,12				; CHR,12
	CAIN	AC14,11				; CHR,11
	JRST	L.25				; L.25
	CAIN	AC14,14				; CHR,14
	JRST	L.25				; L.25
	JUMPG	AC14,L.28			; CHR,L.28
	MOVEI	AC1,134				; AC1,134
	MOVEM	AC1,U.95			; AC1,SCACOD
	JRST	L.76				; L.76
L.28:	CAIL	AC14,141			; CHR,141
	CAILE	AC14,172			; CHR,172
	JRST	L.29				; L.29
	SUBI	AC14,40				; CHR,40
L.29:	CAIL	AC14,101			; CHR,101
	CAILE	AC14,132			; CHR,132
	JRST	L.37				; L.37
	MOVE	AC13,C.2			; PTR,[POINT 7,BUF0+11062,34]  <1,7>
	SETZB	AC12,U.92			; LEN,SCATOM
L.30:	ADDI	AC12,1				; LEN,1
	CAIG	AC12,50				; LEN,50
	JRST	L.31				; L.31
	MOVEI	AC1,P.AEZ			; AC1,P.AEZ
	PUSHJ	SP,U.1				; SP,CERROR
L.31:	IDPB	AC14,AC13			; CHR,PTR
	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIL	AC14,141			; CHR,141
	CAILE	AC14,172			; CHR,172
	JRST	L.32				; L.32
	SUBI	AC14,40				; CHR,40
L.32:	CAIGE	AC14,101			; CHR,101
	JRST	L.33				; L.33
	CAIG	AC14,132			; CHR,132
	JRST	L.30				; L.30
L.33:	CAIGE	AC14,60				; CHR,60
	JRST	L.34				; L.34
	CAIG	AC14,71				; CHR,71
	JRST	L.30				; L.30
L.34:	CAIN	AC14,137			; CHR,137
	JRST	L.30				; L.30
	SETZ	AC1,				; AC1,
	IDPB	AC1,AC13			; AC1,PTR
	MOVEI	AC1,1				; AC1,1
	MOVEM	AC1,U.95			; AC1,SCACOD
	MOVEM	AC12,U.93			; LEN,SCALEN
	SKIPE	U.90				; SCATRP
	JRST	L.75				; L.75
	MOVEI	AC3,114				; PTR,114
L.35:	LDB	AC1,C.4				; AC1,[POINT 9,RSNTBL(PTR),17]  <18,9>
	CAME	AC12,AC1			; LEN,AC1
	JRST	L.36				; L.36
	HRRZ	AC5,U.103(AC3)			; HLF,RSNTBL(PTR)
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,AC12			; AC1,LEN
	MOVE	AC2,C.2				; AC2,[POINT 7,BUF0+11062,34]  <1,7>
	MOVE	AC4,AC12			; AC4,LEN
	EXTEND	AC1,C.5				; AC1,[CMPSE ]
	JRST	L.36				; L.36
	LDB	AC1,C.6				; AC1,[POINT 9,RSNTBL(PTR),8]  <27,9>
	JRST	L.60				; L.60
L.36:	SOJGE	AC3,L.35			; PTR,L.35
	JRST	L.75				; L.75
L.37:	CAIL	AC14,60				; CHR,60
	CAILE	AC14,71				; CHR,71
	JRST	L.48				; L.48
	SETZ	AC13,				; NUM,
L.38:	MOVE	AC1,AC13			; AC1,NUM
	IMULI	AC1,12				; AC1,12
	ADD	AC1,AC14			; AC1,CHR
	MOVE	AC13,AC1			; NUM,AC1
	SUBI	AC13,60				; NUM,60
	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIL	AC14,60				; CHR,60
	CAILE	AC14,71				; CHR,71
	JRST	L.39				; L.39
	JRST	L.38				; L.38
L.39:	CAIE	AC14,45				; CHR,45
	JRST	L.47				; L.47
	CAIGE	AC13,2				; NUM,2
	JRST	L.40				; L.40
	CAIG	AC13,44				; NUM,44
	JRST	L.41				; L.41
L.40:	MOVEI	AC1,P.AFA			; AC1,P.AFA
	PUSHJ	SP,U.1				; SP,CERROR
L.41:	MOVE	AC11,AC13			; BASE,NUM
	SETZB	AC13,AC12			; NUM,NUMHIGH
L.42:	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIL	AC14,60				; CHR,60
	CAILE	AC14,71				; CHR,71
	JRST	L.43				; L.43
	SUBI	AC14,60				; CHR,60
	JRST	L.45				; L.45
L.43:	CAIL	AC14,101			; CHR,101
	CAILE	AC14,132			; CHR,132
	JRST	L.44				; L.44
	SUBI	AC14,67				; CHR,67
	JRST	L.45				; L.45
L.44:	CAIL	AC14,141			; CHR,141
	CAILE	AC14,172			; CHR,172
	JRST	L.46				; L.46
	SUBI	AC14,127			; CHR,127
L.45:	CAML	AC14,AC11			; CHR,BASE
	JRST	L.46				; L.46
	MOVE	AC1,AC12			; R1,NUMHIGH
	MOVE	AC2,AC13			; R2,NUM
	SETZ	AC3,				; R3,
	MOVE	AC4,AC11			; R4,BASE
	DMUL	1,3				; 1,3
	MOVE	AC2,AC14			; R2,CHR
	DADD	1,3				; 1,3
	MOVE	AC12,AC1			; NUMHIGH,R1
	MOVE	AC13,AC2			; NUM,R2
	CAIG	AC12,1				; NUMHIGH,1
	JRST	L.42				; L.42
	MOVEI	AC1,P.AFB			; AC1,P.AFB
	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.42				; L.42
L.46:	CAIN	AC12,1				; NUMHIGH,1
	TLO	AC13,400000			; NUM,400000
L.47:	MOVEM	AC13,U.94			; NUM,SCANUM
	MOVEI	AC1,2				; AC1,2
	JRST	L.60				; L.60
L.48:	CAIE	AC14,44				; CHR,44
	JRST	L.61				; L.61
	MOVE	AC12,C.2			; PTR,[POINT 7,BUF0+11062,34]  <1,7>
	SETZB	AC13,U.92			; LEN,SCATOM
L.49:	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIL	AC14,141			; CHR,141
	CAILE	AC14,172			; CHR,172
	JRST	L.50				; L.50
	SUBI	AC14,40				; CHR,40
L.50:	CAIGE	AC14,101			; CHR,101
	JRST	L.51				; L.51
	CAIG	AC14,132			; CHR,132
	JRST	L.52				; L.52
L.51:	CAIN	AC14,137			; CHR,137
	JRST	L.52				; L.52
	CAIL	AC14,60				; CHR,60
	CAILE	AC14,71				; CHR,71
	JRST	L.53				; L.53
L.52:	IDPB	AC14,AC12			; CHR,PTR
	ADDI	AC13,1				; LEN,1
L.53:	CAIGE	AC14,101			; CHR,101
	JRST	L.54				; L.54
	CAIG	AC14,132			; CHR,132
	JRST	L.49				; L.49
L.54:	CAIN	AC14,137			; CHR,137
	JRST	L.49				; L.49
	CAIL	AC14,60				; CHR,60
	CAILE	AC14,71				; CHR,71
	JRST	L.55				; L.55
	JRST	L.49				; L.49
L.55:	MOVEI	AC3,PSDEFL-1			; I,PSDEFL-1
	AOJA	AC3,L.57			; I,L.57
L.56:	MOVE	AC1,AC3				; AC1,I
	IMULI	AC1,2				; AC1,2
	HRRZ	AC2,PSDEFN(AC1)			; AC2,PSDEFN(AC1)
	CAME	AC2,AC13			; AC2,LEN
	JRST	L.57				; L.57
	HLRZ	AC5,PSDEFN+1(AC1)		; HLF,PSDEFN+1(AC1)
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,AC13			; AC1,LEN
	MOVE	AC2,C.2				; AC2,[POINT 7,BUF0+11062,34]  <1,7>
	MOVE	AC4,AC13			; AC4,LEN
	EXTEND	AC1,C.5				; AC1,[CMPSE ]
	JRST	L.57				; L.57
	MOVE	AC12,AC3			; PTR,I
	JRST	L.58				; L.58
L.57:	SOJGE	AC3,L.56			; I,L.56
	SETO	AC12,				; PTR,
L.58:	JUMPGE	AC12,L.59			; PTR,L.59
	MOVEI	AC1,P.AFC			; AC1,P.AFC
	PUSHJ	SP,U.1				; SP,CERROR
L.59:	MOVEM	AC12,U.92			; PTR,SCATOM
	MOVEI	AC1,112				; AC1,112
L.60:	MOVEM	AC1,U.95			; AC1,SCACOD
	JRST	L.75				; L.75
L.61:	MOVEI	AC1,40				; I,40
L.62:	CAME	AC14,U.104(AC1)			; CHR,RESCHR(I)
	JRST	L.63				; L.63
	MOVE	AC1,U.104+1(AC1)		; AC1,RESCHR+1(I)
	JRST	L.64				; L.64
L.63:	SUBI	AC1,2				; I,2
	JUMPGE	AC1,L.62			; I,L.62
	SETO	AC1,				; AC1,
L.64:	MOVEM	AC1,U.95			; AC1,SCACOD
	SKIPL	U.95				; SCACOD
	JRST	L.65				; L.65
	MOVEI	AC1,P.AFD			; AC1,P.AFD
	PUSHJ	SP,U.1				; SP,CERROR
L.65:	CAIE	AC14,42				; CHR,42
	JRST	L.70				; L.70
	MOVE	AC11,C.2			; PTRO,[POINT 7,BUF0+11062,34]  <1,7>
	SETZ	AC12,				; LEN,
L.66:	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIE	AC14,42				; CHR,42
	JRST	L.67				; L.67
	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIE	AC14,42				; CHR,42
	JRST	L.69				; L.69
L.67:	ADDI	AC12,1				; LEN,1
	CAIG	AC12,1000			; LEN,1000
	JRST	L.68				; L.68
	MOVEI	AC1,P.AFE			; AC1,P.AFE
	PUSHJ	SP,U.1				; SP,CERROR
L.68:	IDPB	AC14,AC11			; CHR,PTRO
	JRST	L.66				; L.66
L.69:	SETZ	AC1,				; AC1,
	IDPB	AC1,AC11			; AC1,PTRO
	MOVEI	AC1,3				; AC1,3
	MOVEM	AC1,U.95			; AC1,SCACOD
	MOVEM	AC12,U.93			; LEN,SCALEN
	JRST	L.75				; L.75
L.70:	CAIE	AC14,74				; CHR,74
	JRST	L.72				; L.72
	PUSHJ	SP,U.2				; SP,SCACHR
	MOVE	AC14,AC1			; CHR,AC1
	CAIE	AC14,76				; CHR,76
	JRST	L.71				; L.71
	MOVEI	AC1,12				; AC1,12
	JRST	L.73				; L.73
L.71:	CAIE	AC14,75				; CHR,75
	JRST	L.75				; L.75
	MOVEI	AC1,11				; AC1,11
	JRST	L.73				; L.73
L.72:	CAIE	AC14,76				; CHR,76
	JRST	L.74				; L.74
	PUSHJ	SP,U.2				; SP,SCACHR
	CAIE	AC1,75				; AC1,75
	JRST	L.75				; L.75
	MOVEI	AC1,15				; AC1,15
L.73:	MOVEM	AC1,U.95			; AC1,SCACOD
L.74:	PUSHJ	SP,U.2				; SP,SCACHR
L.75:	SETO	AC1,				; AC1,
	ADJBP	AC1,U.87			; AC1,SCAPTR
	MOVEM	AC1,U.87			; AC1,SCAPTR
	MOVE	AC1,U.95			; AC1,SCACOD
L.76:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,
C.4:	POINT	9,U.103(AC3),17			; 9,RSNTBL(PTR),17
C.5:	CMPSE					; 
C.6:	POINT	9,U.103(AC3),8			; 9,RSNTBL(PTR),8

; Routine Size:  274 words


;	  0918	
;	  0919	
;	  0920	
;	  0921	ROUTINE ADDSMB =		! Add current atom to symbol table
;	  0922	
;	  0923	!++
;	  0924	! Functional description:
;	  0925	!	Define the current atom as a new entry in the symbol table,
;	  0926	!	and return the index of the new entry.	Entry must be unique;
;	  0927	!	duplicate names return -1.  Fills in only the name, so the
;	  0928	!	caller must fill in everything else as he sees fit.
;	  0929	!
;	  0930	! Formal parameters:
;	  0931	!	None
;	  0932	!
;	  0933	! Implicit inputs:
;	  0934	!	Current atom
;	  0935	!
;	  0936	! Implicit outputs:
;	  0937	!	Symbol table, constants (to store identifier name)
;	  0938	!
;	  0939	! Routine value:
;	  0940	!	Index of new symbol table entry, or -1 if not unique
;	  0941	!
;	  0942	! Side effects:
;	  0943	!	None
;	  0944	!
;	  0945	!--
;	  0946	
;	  0947	    BEGIN
;	  0948	    EXTERNAL REGISTER Z=0;
;	  0949	    LOCAL
;	  0950		CHR,			! Character
;	  0951		SYMP,			! Symbol table index
;	  0952		CP;			! Constant table index
;	  0953	    LABEL
;	  0954		F;
;	  0955	    DECR I FROM .SYMTBP-1 DO
;	  0956		IF .SCALEN EQL .SYMWRK[.I,STE_NML] THEN
;	  0957		    IF CH$EQL(	.SCALEN,CH$PTR(SCATOM),
;	  0958				.SCALEN,BYTPTR(CNSWRK[.SYMWRK[.I,STE_NMA]]))
;	  0959		    THEN
;	  0960			RETURN -1;
;	  0961	    SYMP = .SYMTBP;
;	  0962	    SYMTBP = .SYMTBP+1;
;	  0963	    IF .SYMTBP GTR CURSML THEN ERROR('Compiler symbol table full');
;	  0964	    SYMWRK[.SYMP,STE_VLD] = STE_VLD_NUM;
;	  0965	    CP =
;	  0966	F:	BEGIN
;	  0967		LOCAL VAL;
;	  0968		DECR I FROM .CONSTP-1 DO
;	  0969		    IF CH$EQL(.SCALEN+1,CH$PTR(SCATOM),.SCALEN+1,BYTPTR(CNSWRK[.I]))
;	  0970		    THEN
;	  0971			LEAVE F WITH .I;
;	  0972		IF .CONSTP + (.SCALEN+5)/5 GTR CNSWKL
;	  0973		THEN
;	  0974		    CERROR(CERM1);
;	  0975		CH$COPY(.SCALEN,CH$PTR(SCATOM),0,.SCALEN+1,BYTPTR(CNSWRK[.CONSTP]));
;	  0976		VAL = .CONSTP;
;	  0977		CONSTP = .CONSTP + (.SCALEN+5)/5;
;	  0978		.VAL
;	  0979		END;
;	  0980	    SYMWRK[.SYMP,STE_NML] = .SCALEN;
;	  0981	    SYMWRK[.SYMP,STE_NMA] = .CP;
;	  0982	    .SYMP
;	  0983	    END;


P.AFF:	BYTE	(7)"C","o","m","p","i"		; Compi
	BYTE	(7)"l","e","r"," ","s"		; ler s
	BYTE	(7)"y","m","b","o","l"		; ymbol
	BYTE	(7)" ","t","a","b","l"		;  tabl
	BYTE	(7)"e"," ","f","u","l"		; e ful
	BYTE	(7)"l",000,000,000,000		; l


; ADDSMB
U.4:	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC3,U.98			; I,SYMTBP
	JRST	L.78				; L.78
L.77:	MOVE	AC1,AC3				; AC1,I
	IMULI	AC1,2				; AC1,2
	HLRZ	AC2,U.77+1(AC1)			; AC2,SYMWRK+1(AC1)
	CAME	AC2,U.93			; AC2,SCALEN
	JRST	L.78				; L.78
	HRRZ	AC5,U.77+1(AC1)			; HLF,SYMWRK+1(AC1)
	ADD	AC5,C.9				; HLF,[CNSWRK]
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,U.93			; AC1,SCALEN
	MOVE	AC2,C.2				; AC2,[POINT 7,BUF0+11062,34]  <1,7>
	MOVE	AC4,U.93			; AC4,SCALEN
	EXTEND	AC1,C.5				; AC1,[CMPSE ]
	JRST	L.78				; L.78
	SETO	AC1,				; AC1,
	JRST	L.84				; L.84
L.78:	SOJGE	AC3,L.77			; I,L.77
	MOVE	AC13,U.98			; SYMP,SYMTBP
	AOS	U.98				; SYMTBP
	MOVEI	AC1,400				; AC1,400
	CAML	AC1,U.98			; AC1,SYMTBP
	JRST	L.79				; L.79
	MOVEI	AC1,P.AFF			; AC1,P.AFF
	PUSHJ	SP,U.1				; SP,CERROR
L.79:	MOVE	AC14,AC13			; AC14,SYMP
	IMULI	AC14,2				; AC14,2
	MOVEI	AC1,2				; AC1,2
	DPB	AC1,C.7				; AC1,[POINT 3,SYMWRK(AC14),2]  <33,3>
	MOVE	AC16,U.93			; AC16,SCALEN
	ADDI	AC16,1				; AC16,1
	MOVE	AC3,U.97			; I,CONSTP
	JRST	L.81				; L.81
L.80:	MOVE	AC5,AC3				; HLF,I
	ADD	AC5,C.9				; HLF,[CNSWRK]
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,AC16			; AC1,AC16
	MOVE	AC2,C.2				; AC2,[POINT 7,BUF0+11062,34]  <1,7>
	MOVE	AC4,AC16			; AC4,AC16
	EXTEND	AC1,C.5				; AC1,[CMPSE ]
	JRST	L.81				; L.81
	JRST	L.83				; L.83
L.81:	SOJGE	AC3,L.80			; I,L.80
	MOVE	AC1,U.93			; AC1,SCALEN
	ADDI	AC1,5				; AC1,5
	IDIVI	AC1,5				; AC1,5
	ADD	AC1,U.97			; AC1,CONSTP
	CAIG	AC1,6000			; AC1,6000
	JRST	L.82				; L.82
	MOVEI	AC1,U.51			; AC1,CERM1
	PUSHJ	SP,U.1				; SP,CERROR
L.82:	MOVE	AC4,U.93			; AC4,SCALEN
	ADDI	AC4,1				; AC4,1
	MOVE	AC5,U.97			; HLF,CONSTP
	ADD	AC5,C.9				; HLF,[CNSWRK]
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,U.93			; AC1,SCALEN
	MOVE	AC2,C.2				; AC2,[POINT 7,BUF0+11062,34]  <1,7>
	EXTEND	AC1,C.8				; AC1,C.8
	JFCL					; 
	MOVE	AC3,U.97			; VAL,CONSTP
	MOVE	AC1,U.93			; AC1,SCALEN
	ADDI	AC1,5				; AC1,5
	IDIVI	AC1,5				; AC1,5
	ADDM	AC1,U.97			; AC1,CONSTP
L.83:	MOVE	AC1,U.93			; AC1,SCALEN
	HRLM	AC1,U.77+1(AC14)		; AC1,SYMWRK+1(AC14)
	HRRM	AC3,U.77+1(AC14)		; CP,SYMWRK+1(AC14)
	MOVE	AC1,AC13			; AC1,SYMP
L.84:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,
C.7:	POINT	3,U.77(AC14),2			; 3,SYMWRK(AC14),2
C.8:	MOVSLJ					; 
	EXP	0				; 0
C.9:	EXP	U.78				; CNSWRK

; Routine Size:  78 words
;	  0984	
;	  0985	ROUTINE FNDSMB(CLASS,TYPE) =	! Find current atom in symbol table
;	  0986	
;	  0987	!++
;	  0988	! Functional description:
;	  0989	!	Search symbol table for entry with the same name as the current
;	  0990	!	atom, and the same class, and data type if a variable or function.
;	  0991	!
;	  0992	! Formal parameters:
;	  0993	!	Class of symbol (STE_CLS), -1 if unimportant
;	  0994	!	Type of variable or function (STE_TYP), -1 if unimportant
;	  0995	!
;	  0996	! Implicit inputs:
;	  0997	!	Symbol table, current atom
;	  0998	!
;	  0999	! Implicit outputs:
;	  1000	!	None
;	  1001	!
;	  1002	! Routine value:
;	  1003	!	Symbol table index of entry,
;	  1004	!	-1 if name not found,
;	  1005	!	-2 if name found but of wrong class or type
;	  1006	!
;	  1007	!  Side effects:
;	  1008	!	None
;	  1009	!
;	  1010	!--
;	  1011	
;	  1012	    DECR I FROM .SYMTBP-1 DO
;	  1013		IF .SYMWRK[.I,STE_NML] EQL .SCALEN THEN
;	  1014		    IF CH$EQL(	.SCALEN,CH$PTR(SCATOM),
;	  1015				.SCALEN,BYTPTR(CNSWRK[.SYMWRK[.I,STE_NMA]]))
;	  1016		    THEN
;	  1017			BEGIN
;	  1018			IF .CLASS GEQ 0 AND .SYMWRK[.I,STE_CLS] NEQ .CLASS
;	  1019			THEN
;	  1020			    RETURN -2;
;	  1021			IF .SYMWRK[.I,STE_CLS] NEQ STE_CLS_PRC
;	  1022			THEN
;	  1023			    IF .TYPE GEQ 0 AND .SYMWRK[.I,STE_TYP] NEQ .TYPE
;	  1024			    THEN
;	  1025				RETURN -2;
;	  1026			RETURN .I
;	  1027			END;


; FNDSMB
U.5:	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC13,AC2			; TYPE,AC2
	MOVE	AC14,AC1			; CLASS,AC1
	MOVE	AC16,U.98			; I,SYMTBP
	JRST	L.89				; L.89
L.85:	MOVE	AC3,AC16			; AC3,I
	IMULI	AC3,2				; AC3,2
	HLRZ	AC1,U.77+1(AC3)			; AC1,SYMWRK+1(AC3)
	CAME	AC1,U.93			; AC1,SCALEN
	JRST	L.89				; L.89
	HRRZ	AC5,U.77+1(AC3)			; HLF,SYMWRK+1(AC3)
	ADD	AC5,C.9				; HLF,[CNSWRK]
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,U.93			; AC1,SCALEN
	MOVE	AC2,C.2				; AC2,[POINT 7,BUF0+11062,34]  <1,7>
	MOVE	AC4,U.93			; AC4,SCALEN
	EXTEND	AC1,C.5				; AC1,[CMPSE ]
	JRST	L.89				; L.89
	JUMPL	AC14,L.86			; CLASS,L.86
	LDB	AC1,C.10			; AC1,[POINT 3,SYMWRK(AC3),5]  <30,3>
	CAME	AC1,AC14			; AC1,CLASS
	JRST	L.87				; L.87
L.86:	LDB	AC1,C.10			; AC1,[POINT 3,SYMWRK(AC3),5]  <30,3>
	CAIN	AC1,3				; AC1,3
	JRST	L.88				; L.88
	JUMPL	AC13,L.88			; TYPE,L.88
	LDB	AC1,C.11			; AC1,[POINT 1,SYMWRK(AC3),6]  <29,1>
	CAMN	AC1,AC13			; AC1,TYPE
	JRST	L.88				; L.88
L.87:	HRROI	AC1,-2				; AC1,-2
	JRST	L.90				; L.90
L.88:	MOVE	AC1,AC16			; AC1,I
	JRST	L.90				; L.90
L.89:	SOJGE	AC16,L.85			; I,L.85
	SETO	AC1,				; AC1,
L.90:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,
C.10:	POINT	3,U.77(AC3),5			; 3,SYMWRK(AC3),5
C.11:	POINT	1,U.77(AC3),6			; 1,SYMWRK(AC3),6

; Routine Size:  41 words


;	  1028	
;	  1029	ROUTINE DEFLBL: NOVALUE =	! Define label
;	  1030	
;	  1031	!++
;	  1032	! Functional description:
;	  1033	!	Defines the current atom to be a label with a given code index,
;	  1034	!	by locating or creating an entry in the label table.
;	  1035	!	If the entry already exists with outstanding references,
;	  1036	!	they are resolved.
;	  1037	!
;	  1038	! Formal parameters:
;	  1039	!	None
;	  1040	!
;	  1041	! Implicit inputs:
;	  1042	!	Current atom
;	  1043	!
;	  1044	! Implicit outputs:
;	  1045	!	Label table, code
;	  1046	!
;	  1047	! Routine value:
;	  1048	!	None
;	  1049	!
;	  1050	! Side effects:
;	  1051	!	None
;	  1052	!
;	  1053	!--
;	  1054	
;	  1055	    BEGIN
;	  1056	    EXTERNAL REGISTER Z=0;
;	  1057	    LOCAL
;	  1058		LPTR;			! Label table index
;	  1059	    LPTR =
;	  1060		(DECR I FROM .LBLCNT-1 DO
;	  1061		    IF CH$EQL(.SCALEN+1, .LBLNAM[.I], .SCALEN+1, BYTPTR(SCATOM))
;	  1062		    THEN
;	  1063			EXITLOOP .I);
;	  1064	    IF .LPTR LSS 0
;	  1065	    THEN
;	  1066		BEGIN
;	  1067		LBLNAM[.LBLCNT] = BYTPTR(PCMGMM((.SCALEN+5)/5, DICT));
;	  1068		CH$MOVE(.SCALEN+1, BYTPTR(SCATOM), .LBLNAM[.LBLCNT]);
;	  1069		LBLADR[.LBLCNT] = .NEXTIN;
;	  1070		LBLCNT = .LBLCNT + 1;
;	  1071		IF .LBLCNT GTR MAXLBL THEN CERROR(CERM10)
;	  1072		END
;	  1073	    ELSE
;	  1074		IF .LBLADR[.LPTR] LSS 0
;	  1075		THEN
;	  1076		    BEGIN
;	  1077		    LOCAL
;	  1078			CPTR,		! Code pointers
;	  1079			NPTR,
;	  1080			HLFTMP: HLF_WRD;
;	  1081		    CPTR = - .LBLADR[.LPTR];
;	  1082		    WHILE
;	  1083			.CPTR GTR 0
;	  1084		    DO
;	  1085			BEGIN
;	  1086			IF .CPTR LSS 2^17
;	  1087			THEN
;	  1088			    BEGIN
;	  1089			    NPTR = .CODWRK[.CPTR,COD_OPA];
;	  1090			    CODWRK[.CPTR,COD_OPA] = .NEXTIN
;	  1091			    END
;	  1092			ELSE
;	  1093			    BEGIN
;	  1094			    CPTR = .CPTR - 2^17;
;	  1095			    HLFTMP = .CNSWRK[.CPTR];
;	  1096			    NPTR = .HLFTMP[HLF_RGT];
;	  1097			    HLFTMP[HLF_RGT] = .NEXTIN;
;	  1098			    CNSWRK[.CPTR] = .HLFTMP
;	  1099			    END;
;	  1100			CPTR = .NPTR
;	  1101			END;
;	  1102		    LBLADR[.LPTR] = .NEXTIN
;	  1103		    END
;	  1104	    END;


; DEFLBL
U.6:	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC13,U.101			; AC13,LBLCNT
	MOVE	AC14,U.93			; AC14,SCALEN
	ADDI	AC14,1				; AC14,1
	MOVE	AC3,AC13			; I,AC13
	JRST	L.92				; L.92
L.91:	MOVE	AC5,C.3				; HLF,[SCATOM]
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,AC14			; AC1,AC14
	MOVE	AC2,U.99(AC3)			; AC2,LBLNAM(I)
	MOVE	AC4,AC14			; AC4,AC14
	EXTEND	AC1,C.5				; AC1,[CMPSE ]
	JRST	L.92				; L.92
	MOVE	AC14,AC3			; LPTR,I
	JRST	L.93				; L.93
L.92:	SOJGE	AC3,L.91			; I,L.91
	SETO	AC14,				; LPTR,
L.93:	JUMPGE	AC14,L.94			; LPTR,L.94
	MOVE	AC1,U.93			; AC1,SCALEN
	ADDI	AC1,5				; AC1,5
	IDIVI	AC1,5				; AC1,5
	MOVEI	AC2,DICT			; AC2,DICT
	PUSHJ	SP,PCMGMM			; SP,PCMGMM
	HRLI	AC1,-337100			; HLF,-337100
	MOVEM	AC1,U.99(AC13)			; HLF,LBLNAM(AC13)
	MOVE	AC1,U.93			; AC1,SCALEN
	ADDI	AC1,1				; AC1,1
	MOVE	AC2,C.3				; HLF,[SCATOM]
	HRLI	AC2,-337100			; HLF,-337100
	MOVE	AC3,U.101			; AC3,LBLCNT
	MOVE	AC4,AC1				; AC4,AC1
	MOVE	AC5,U.99(AC3)			; AC5,LBLNAM(AC3)
	EXTEND	AC1,C.12			; AC1,[MOVSLJ ]
	JFCL					; 
	MOVE	AC1,U.86			; AC1,NEXTIN
	MOVEM	AC1,U.100(AC3)			; AC1,LBLADR(AC3)
	AOS	U.101				; LBLCNT
	MOVEI	AC1,24				; AC1,24
	CAML	AC1,U.101			; AC1,LBLCNT
	JRST	L.99				; L.99
	MOVEI	AC1,U.60			; AC1,CERM10
	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.99				; L.99
L.94:	MOVE	AC1,U.100(AC14)			; AC1,LBLADR(LPTR)
	JUMPGE	AC1,L.99			; AC1,L.99
	MOVN	AC1,AC1				; CPTR,AC1
L.95:	JUMPLE	AC1,L.98			; CPTR,L.98
	CAML	AC1,C.13			; CPTR,[1000000]
	JRST	L.96				; L.96
	HRRZ	AC3,U.76(AC1)			; NPTR,CODWRK(CPTR)
	MOVE	AC4,U.86			; AC4,NEXTIN
	HRRM	AC4,U.76(AC1)			; AC4,CODWRK(CPTR)
	JRST	L.97				; L.97
L.96:	SUB	AC1,C.13			; CPTR,[1000000]
	MOVE	AC2,U.78(AC1)			; HLFTMP,CNSWRK(CPTR)
	MOVEI	AC3,0(AC2)			; NPTR,0(HLFTMP)
	HRR	AC2,U.86			; HLFTMP,NEXTIN
	MOVEM	AC2,U.78(AC1)			; HLFTMP,CNSWRK(CPTR)
L.97:	MOVE	AC1,AC3				; CPTR,NPTR
	JRST	L.95				; L.95
L.98:	MOVE	AC1,U.86			; AC1,NEXTIN
	MOVEM	AC1,U.100(AC14)			; AC1,LBLADR(LPTR)
L.99:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,
C.12:	MOVSLJ					; 
C.13:	EXP	1000000				; 1000000

; Routine Size:  68 words


;	  1105	
;	  1106	ROUTINE GENINS(OPR,OPA,OPB,OPC) =	! Generate an instruction
;	  1107	
;	  1108	!++
;	  1109	! Functional description:
;	  1110	!	Add an instruction in the code work area, with the given
;	  1111	!	operation code and operand descriptors, and the current
;	  1112	!	source line number.  Steps the next-instruction
;	  1113	!	index by 1 or 2 depending on the operation code.
;	  1114	!
;	  1115	! Formal parameters:
;	  1116	!	Operation code
;	  1117	!	Three operand descriptors
;	  1118	!
;	  1119	! Implicit inputs:
;	  1120	!	Next instruction index
;	  1121	!
;	  1122	! Implicit outputs:
;	  1123	!	Code
;	  1124	!
;	  1125	! Routine value:
;	  1126	!	Index of code location of instruction
;	  1127	!
;	  1128	! Side effects:
;	  1129	!	None
;	  1130	!
;	  1131	!--
;	  1132	
;	  1133	    BEGIN
;	  1134	    EXTERNAL REGISTER Z=0;
;	  1135	    LOCAL
;	  1136		PTR,		! Code pointers
;	  1137		EPTR;
;	  1138	    PTR  = .NEXTIN;
;	  1139	    IF .OPR LSS OPR_11W THEN EPTR = .PTR+2 ELSE EPTR = .PTR+1;
;	  1140	    IF .EPTR GEQ CODWKL THEN ERROR('Code work area full');
;	  1141	    CODWRK[.PTR,COD_VLD] = COD_VLD_NUM;
;	  1142	    CODWRK[.PTR,COD_LNO] = .SCALIN;
;	  1143	    CODWRK[.PTR,COD_OPR] = .OPR;
;	  1144	    CODWRK[.PTR,COD_OPA] = .OPA;
;	  1145	    IF .OPR LSS OPR_11W
;	  1146	    THEN
;	  1147		(CODWRK[.PTR,COD_OPB] = .OPB;
;	  1148		 CODWRK[.PTR,COD_OPC] = .OPC);
;	  1149	    NEXTIN = .EPTR;
;	  1150	    .PTR
;	  1151	END;


P.AFG:	BYTE	(7)"C","o","d","e"," "		; Code
	BYTE	(7)"w","o","r","k"," "		; work
	BYTE	(7)"a","r","e","a"," "		; area
	BYTE	(7)"f","u","l","l",000		; full


; GENINS
U.7:	PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,2				; SP,2
	MOVEM	AC4,0(SP)			; AC4,0(SP)
	MOVEM	AC3,-1(SP)			; AC3,-1(SP)
	MOVE	AC12,AC2			; OPA,AC2
	MOVE	AC13,AC1			; OPR,AC1
	MOVE	AC14,U.86			; PTR,NEXTIN
	SETZ	AC10,				; AC10,
	CAIL	AC13,32				; OPR,32
	JRST	L.100				; L.100
	MOVEI	AC10,1				; AC10,1
	MOVE	AC11,AC14			; EPTR,PTR
	ADDI	AC11,2				; EPTR,2
	JRST	L.101				; L.101
L.100:	MOVE	AC11,AC14			; EPTR,PTR
	ADDI	AC11,1				; EPTR,1
L.101:	CAIGE	AC11,2000			; EPTR,2000
	JRST	L.102				; L.102
	MOVEI	AC1,P.AFG			; AC1,P.AFG
	PUSHJ	SP,U.1				; SP,CERROR
L.102:	MOVEI	AC1,5				; AC1,5
	DPB	AC1,C.14			; AC1,[POINT 3,CODWRK(PTR),2]  <33,3>
	MOVE	AC1,U.88			; AC1,SCALIN
	DPB	AC1,C.15			; AC1,[POINT 9,CODWRK(PTR),11]  <24,9>
	DPB	AC13,C.16			; OPR,[POINT 6,CODWRK(PTR),17]  <18,6>
	HRRM	AC12,U.76(AC14)			; OPA,CODWRK(PTR)
	TRNN	AC10,1				; AC10,1
	JRST	L.103				; L.103
	MOVE	AC1,-1(SP)			; AC1,-1(SP)
	HRLM	AC1,U.76+1(AC14)		; AC1,CODWRK+1(PTR)
	MOVE	AC1,0(SP)			; AC1,0(SP)
	HRRM	AC1,U.76+1(AC14)		; AC1,CODWRK+1(PTR)
L.103:	MOVEM	AC11,U.86			; EPTR,NEXTIN
	MOVE	AC1,AC14			; AC1,PTR
	ADJSP	SP,-2				; SP,-2
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,
C.14:	POINT	3,U.76(AC14),2			; 3,CODWRK(PTR),2
C.15:	POINT	9,U.76(AC14),11			; 9,CODWRK(PTR),11
C.16:	POINT	6,U.76(AC14),17			; 6,CODWRK(PTR),17

; Routine Size:  48 words


;	  1152	
;	  1153	ROUTINE GETCNS(VALUE,TYPE)=	! Find/create constant
;	  1154	
;	  1155	!++
;	  1156	! Functional description:
;	  1157	!	Locates desired constant in constant pool work area, or
;	  1158	!	creates it if not found.  Returns constant table index.
;	  1159	!
;	  1160	! Formal parameters:
;	  1161	!	Value of constant (integer number or real stringvalue)
;	  1162	!	Type of constant (STE_TYP)
;	  1163	!
;	  1164	! Implicit inputs:
;	  1165	!	None
;	  1166	!
;	  1167	! Implicit outputs:
;	  1168	!	Constant pool
;	  1169	!
;	  1170	! Routine value:
;	  1171	!	Index into constant pool
;	  1172	!
;	  1173	! Side effects:
;	  1174	!	None
;	  1175	!
;	  1176	!--
;	  1177	
;	  1178	BEGIN
;	  1179	EXTERNAL REGISTER Z=0;
;	  1180	IF .TYPE EQL STE_TYP_INT
;	  1181	THEN
;	  1182	    BEGIN
;	  1183	    DECR I FROM .CONSTP-1 DO
;	  1184		IF .CNSWRK[.I] EQL .VALUE THEN RETURN .I;
;	  1185	    IF .CONSTP GEQ CNSWKL THEN CERROR(CERM1);
;	  1186	    CNSWRK[.CONSTP] = .VALUE;
;	  1187	    CONSTP = .CONSTP + 1;
;	  1188	    .CONSTP - 1
;	  1189	    END
;	  1190	ELSE
;	  1191	    BEGIN
;	  1192	    MAP VALUE:STR_VAL;
;	  1193	    LOCAL
;	  1194		LEN,			! String length
;	  1195		PTR,			! String pointer
;	  1196		SVAL: STR_VAL,		! String value of constant
;	  1197		CPTR;			! Constant table pointer
;	  1198	    LABEL
;	  1199		FOUND;
;	  1200	    LEN = .VALUE[STV_LEN];
;	  1201	    PTR = BYTPTR(.VALUE[STV_ADR]);
;	  1202	    CPTR =
;	  1203	FOUND:	BEGIN
;	  1204		DECR I FROM .CONSTP-1 DO
;	  1205		    IF CH$EQL(.LEN+1,.PTR,.LEN+1,CH$PTR(CNSWRK[.I]))
;	  1206		    THEN
;	  1207			LEAVE FOUND WITH .I;
;	  1208		IF .CONSTP + (.LEN+5)/5 GTR CNSWKL
;	  1209		THEN
;	  1210		    CERROR(CERM1);
;	  1211		CH$COPY(.LEN,.PTR,0,.LEN+1,CH$PTR(CNSWRK[.CONSTP]));
;	  1212		PTR = .CONSTP;
;	  1213		CONSTP = .CONSTP + (.LEN+5)/5;
;	  1214		.PTR
;	  1215		END;
;	  1216	    SVAL[STV_ADR] = .CPTR;
;	  1217	    SVAL[STV_LEN] = .LEN;
;	  1218	    DECR I FROM .CONSTP-1 DO
;	  1219		IF .CNSWRK[.I] EQL .SVAL THEN RETURN .I;
;	  1220	    IF .CONSTP GEQ CNSWKL THEN CERROR(CERM1);
;	  1221	    CPTR = .CONSTP;
;	  1222	    CNSWRK[.CPTR] = .SVAL;
;	  1223	    CONSTP = .CPTR + 1;
;	  1224	    .CPTR
;	  1225	    END
;	  1226	END;


; GETCNS
U.8:	PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC13,AC1			; VALUE,AC1
	MOVE	AC10,U.97			; AC10,CONSTP
	MOVE	AC14,AC10			; AC14,AC10
	SUBI	AC14,1				; AC14,1
	JUMPN	AC2,L.107			; TYPE,L.107
	MOVE	AC2,AC14			; I,AC14
	AOJA	AC2,L.105			; I,L.105
L.104:	CAMN	AC13,U.78(AC2)			; VALUE,CNSWRK(I)
	JRST	L.115				; L.115
L.105:	SOJGE	AC2,L.104			; I,L.104
	CAIGE	AC10,6000			; AC10,6000
	JRST	L.106				; L.106
	MOVEI	AC1,U.51			; AC1,CERM1
	PUSHJ	SP,U.1				; SP,CERROR
L.106:	MOVE	AC1,U.97			; AC1,CONSTP
	MOVEM	AC13,U.78(AC1)			; VALUE,CNSWRK(AC1)
	AOS	AC2,U.97			; AC2,CONSTP
	SOJA	AC2,L.115			; AC2,L.115
L.107:	HLRZ	AC12,AC13			; LEN,VALUE
	MOVEI	AC1,0(AC13)			; HLF,0(VALUE)
	HRLI	AC1,-337100			; HLF,-337100
	MOVE	AC11,AC1			; PTR,HLF
	MOVE	AC13,AC12			; AC13,LEN
	ADDI	AC13,1				; AC13,1
	MOVE	AC3,AC14			; I,AC14
	AOJA	AC3,L.109			; I,L.109
L.108:	MOVEI	AC5,U.78-1(AC3)			; AC5,CNSWRK-1(I)
	HRLI	AC5,10700			; AC5,10700
	MOVE	AC1,AC13			; AC1,AC13
	MOVE	AC2,AC11			; AC2,PTR
	MOVE	AC4,AC13			; AC4,AC13
	EXTEND	AC1,C.5				; AC1,[CMPSE ]
	JRST	L.109				; L.109
	MOVE	AC14,AC3			; CPTR,I
	JRST	L.111				; L.111
L.109:	SOJGE	AC3,L.108			; I,L.108
	MOVE	AC14,AC12			; AC14,LEN
	ADDI	AC14,5				; AC14,5
	MOVE	AC1,AC14			; AC1,AC14
	IDIVI	AC1,5				; AC1,5
	MOVE	AC14,AC1			; AC14,AC1
	MOVE	AC2,AC10			; AC2,AC10
	ADD	AC2,AC14			; AC2,AC14
	CAIG	AC2,6000			; AC2,6000
	JRST	L.110				; L.110
	MOVEI	AC1,U.51			; AC1,CERM1
	PUSHJ	SP,U.1				; SP,CERROR
L.110:	MOVE	AC3,U.97			; AC3,CONSTP
	MOVEI	AC5,U.78-1(AC3)			; AC5,CNSWRK-1(AC3)
	HRLI	AC5,10700			; AC5,10700
	MOVE	AC1,AC12			; AC1,LEN
	MOVE	AC2,AC11			; AC2,PTR
	MOVE	AC4,AC13			; AC4,AC13
	EXTEND	AC1,C.8				; AC1,C.8
	JFCL					; 
	MOVE	AC11,AC3			; PTR,AC3
	ADDM	AC14,U.97			; AC14,CONSTP
	MOVE	AC14,AC11			; CPTR,PTR
L.111:	HRR	AC13,AC14			; SVAL,CPTR
	HRL	AC13,AC12			; SVAL,LEN
	MOVE	AC2,U.97			; AC2,CONSTP
	MOVE	AC1,AC2				; I,AC2
	JRST	L.113				; L.113
L.112:	CAMN	AC13,U.78(AC1)			; SVAL,CNSWRK(I)
	JRST	L.116				; L.116
L.113:	SOJGE	AC1,L.112			; I,L.112
	CAIGE	AC2,6000			; AC2,6000
	JRST	L.114				; L.114
	MOVEI	AC1,U.51			; AC1,CERM1
	PUSHJ	SP,U.1				; SP,CERROR
L.114:	MOVE	AC14,U.97			; CPTR,CONSTP
	MOVEM	AC13,U.78(AC14)			; SVAL,CNSWRK(CPTR)
	MOVE	AC1,AC14			; AC1,CPTR
	ADDI	AC1,1				; AC1,1
	MOVEM	AC1,U.97			; AC1,CONSTP
	MOVE	AC2,AC14			; AC2,CPTR
L.115:	MOVE	AC1,AC2				; AC1,AC2
L.116:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,

; Routine Size:  88 words


;	  1227	
;	  1228	ROUTINE ASMPRC: NOVALUE =		! Assemble components
;	  1229	
;	  1230	!++
;	  1231	! Functional description:
;	  1232	!	Merge the parameter list, constant pool, and symbol table into
;	  1233	!	the code work area, find the total length of the procedure text,
;	  1234	!	allocate space for it in the text region, copy into the text region the
;	  1235	!	procedure's text.  Leaves assorted information around to be
;	  1236	!	entered into global symbol table.
;	  1237	!
;	  1238	! Formal parameters:
;	  1239	!	None
;	  1240	!
;	  1241	! Implicit inputs:
;	  1242	!	Code, arguments, constants, symbols
;	  1243	!
;	  1244	! Implicit outputs:
;	  1245	!	Text area
;	  1246	!
;	  1247	!  Routine value:
;	  1248	!	None
;	  1249	!
;	  1250	! Side effects:
;	  1251	!	None
;	  1252	!
;	  1253	!--
;	  1254	
;	  1255	    BEGIN
;	  1256	    EXTERNAL REGISTER Z=0;
;	  1257	    MAP
;	  1258		SYMWRK: VECTOR;		! Simpler access
;	  1259	    LOCAL
;	  1260		PTRI,			! Copy pointers
;	  1261		PTRO;
;	  1262	    CURTXT = PCMGMM(.NEXTIN+.PRCARG[0]+.CONSTP+.SYMTBP*STE_LEN, PCTXFR);
;	  1263	    IF .CURTXT LEQ 0 THEN ERROR('Out of text space');
;	  1264	    PTRI = CODWRK;
;	  1265	    PTRO = .CURTXT;
;	  1266	    DECR I FROM .NEXTIN-1 DO
;	  1267		BEGIN
;	  1268		.PTRO = ..PTRI;
;	  1269		PTRI = .PTRI + 1;
;	  1270		PTRO = .PTRO + 1
;	  1271		END;
;	  1272	    PTRI = PRCARG[1];
;	  1273	    DECR I FROM .PRCARG[0]-1 DO
;	  1274		BEGIN
;	  1275		.PTRO = ..PTRI;
;	  1276		PTRI = .PTRI + 1;
;	  1277		PTRO = .PTRO + 1
;	  1278		END;
;	  1279	    PTRI = CNSWRK;
;	  1280	    DECR I FROM .CONSTP-1 DO
;	  1281		BEGIN
;	  1282		.PTRO = ..PTRI;
;	  1283		PTRI = .PTRI + 1;
;	  1284		PTRO = .PTRO + 1
;	  1285		END;
;	  1286	    PTRI = SYMWRK;
;	  1287	    DECR I FROM (.SYMTBP*STE_LEN)-1 DO
;	  1288		BEGIN
;	  1289		.PTRO = ..PTRI;
;	  1290		PTRI = .PTRI + 1;
;	  1291		PTRO = .PTRO + 1
;	  1292		END
;	  1293	    END;


P.AFH:	BYTE	(7)"O","u","t"," ","o"		; Out o
	BYTE	(7)"f"," ","t","e","x"		; f tex
	BYTE	(7)"t"," ","s","p","a"		; t spa
	BYTE	(7)"c","e",000,000,000		; ce


; ASMPRC
U.9:	MOVE	AC1,U.86			; AC1,NEXTIN
	ADD	AC1,U.84			; AC1,PRCARG
	ADD	AC1,U.97			; AC1,CONSTP
	MOVE	AC2,U.98			; AC2,SYMTBP
	IMULI	AC2,2				; AC2,2
	ADD	AC1,AC2				; AC1,AC2
	MOVEI	AC2,PCTXFR			; AC2,PCTXFR
	PUSHJ	SP,PCMGMM			; SP,PCMGMM
	MOVEM	AC1,U.83			; AC1,CURTXT
	SKIPLE	U.83				; CURTXT
	JRST	L.117				; L.117
	MOVEI	AC1,P.AFH			; AC1,P.AFH
	PUSHJ	SP,U.1				; SP,CERROR
L.117:	MOVEI	AC1,U.76			; PTRI,CODWRK
	MOVE	AC3,U.83			; PTRO,CURTXT
	MOVE	AC2,U.86			; I,NEXTIN
	JRST	L.119				; L.119
L.118:	MOVE	AC4,0(AC1)			; AC4,0(PTRI)
	MOVEM	AC4,0(AC3)			; AC4,0(PTRO)
	ADDI	AC1,1				; PTRI,1
	ADDI	AC3,1				; PTRO,1
L.119:	SOJGE	AC2,L.118			; I,L.118
	MOVE	AC1,C.17			; PTRI,[PRCARG+1]
	MOVE	AC2,U.84			; I,PRCARG
	JRST	L.121				; L.121
L.120:	MOVE	AC4,0(AC1)			; AC4,0(PTRI)
	MOVEM	AC4,0(AC3)			; AC4,0(PTRO)
	ADDI	AC1,1				; PTRI,1
	ADDI	AC3,1				; PTRO,1
L.121:	SOJGE	AC2,L.120			; I,L.120
	MOVE	AC1,C.9				; PTRI,[CNSWRK]
	MOVE	AC2,U.97			; I,CONSTP
	JRST	L.123				; L.123
L.122:	MOVE	AC4,0(AC1)			; AC4,0(PTRI)
	MOVEM	AC4,0(AC3)			; AC4,0(PTRO)
	ADDI	AC1,1				; PTRI,1
	ADDI	AC3,1				; PTRO,1
L.123:	SOJGE	AC2,L.122			; I,L.122
	MOVE	AC1,C.18			; PTRI,[SYMWRK]
	MOVE	AC2,U.98			; AC2,SYMTBP
	IMULI	AC2,2				; AC2,2
	JRST	L.125				; L.125
L.124:	MOVE	AC4,0(AC1)			; AC4,0(PTRI)
	MOVEM	AC4,0(AC3)			; AC4,0(PTRO)
	ADDI	AC1,1				; PTRI,1
	ADDI	AC3,1				; PTRO,1
L.125:	SOJGE	AC2,L.124			; I,L.124
	POPJ	SP,				; SP,
C.17:	EXP	U.84+1				; PRCARG+1
C.18:	EXP	U.77				; SYMWRK

; Routine Size:  50 words


;	  1294	
;	  1295	ROUTINE DEFPRC: NOVALUE =	! Define procedure
;	  1296	
;	  1297	!++
;	  1298	! Functional description:
;	  1299	!	Creates global symbol table entry for newly-compiled routine.
;	  1300	!
;	  1301	! Formal parameters:
;	  1302	!	None
;	  1303	!
;	  1304	! Implicit inputs:
;	  1305	!	Key indices describing lengths of various objects
;	  1306	!
;	  1307	! Implicit outputs:
;	  1308	!	Global symbol table
;	  1309	!
;	  1310	! Routine value:
;	  1311	!	None
;	  1312	!
;	  1313	! Side effects:
;	  1314	!	None
;	  1315	!
;	  1316	!--
;	  1317	
;	  1318	    BEGIN
;	  1319	    EXTERNAL REGISTER Z=0;
;	  1320	    LOCAL
;	  1321		GS:BLOCK[GST_LEN] FIELD (GST_FLD);	! A global symbol entry
;	  1322	    GS[GST_CLS] = .CURCLS;
;	  1323	    IF .CURCLS EQL GST_CLS_CMD
;	  1324	    THEN
;	  1325		GS[GST_CMA] = .CMDARG
;	  1326	    ELSE
;	  1327		GS[GST_PCT] = .PRCARG[0];
;	  1328	    IF .CURCLS EQL GST_CLS_FCN THEN GS[GST_TYP] = .CURTYP;
;	  1329	    GS[GST_SLN] = .NUMVRS;
;	  1330	    GS[GST_TXT] = .CURTXT;
;	  1331	    GS[GST_COD] = .NEXTIN;
;	  1332	    GS[GST_CNS] = .CONSTP;
;	  1333	    GS[GST_SML] = .SYMTBP;
;	  1334	    GS[GST_NML] = .CURNML;
;	  1335	    GS[GST_NMA] = GTBUFX(((.CURNML+5)/5));
;	  1336	    CH$COPY(.CURNML, CH$PTR(CURRTN), 0, .CURNML+1, BYTPTR(.GS[GST_NMA]));
;	  1337	    PCICGS(GS)
;	  1338	    END;


; DEFPRC
U.10:	ADJSP	SP,3				; SP,3
	MOVE	AC1,U.81			; AC1,CURCLS
	DPB	AC1,C.19			; AC1,[POINT 3,GS,4]  <31,3>
	JUMPN	AC1,L.126			; AC1,L.126
	SKIPA	AC2,U.85			; AC2,CMDARG
L.126:	MOVE	AC2,U.84			; AC2,PRCARG
	DPB	AC2,C.20			; AC2,[POINT 4,GS,9]  <26,4>
	CAIE	AC1,3				; AC1,3
	JRST	L.127				; L.127
	MOVE	AC1,U.82			; AC1,CURTYP
	DPB	AC1,C.21			; AC1,[POINT 1,GS,5]  <30,1>
L.127:	MOVE	AC1,U.96			; AC1,NUMVRS
	DPB	AC1,C.22			; AC1,[POINT 8,GS,17]  <18,8>
	MOVE	AC1,U.83			; AC1,CURTXT
	HRRM	AC1,-2(SP)			; AC1,GS
	MOVE	AC1,U.86			; AC1,NEXTIN
	DPB	AC1,C.23			; AC1,[POINT 12,GS+1,35]  <0,12>
	MOVE	AC1,U.97			; AC1,CONSTP
	DPB	AC1,C.24			; AC1,[POINT 12,GS+1,23]  <12,12>
	MOVE	AC1,U.98			; AC1,SYMTBP
	DPB	AC1,C.25			; AC1,[POINT 12,GS+1,11]  <24,12>
	MOVE	AC1,U.80			; AC1,CURNML
	HRLM	AC1,0(SP)			; AC1,GS+2
	MOVE	AC1,U.80			; AC1,CURNML
	ADDI	AC1,5				; AC1,5
	IDIVI	AC1,5				; AC1,5
	PUSHJ	SP,GTBUFX			; SP,GTBUFX
	HRRM	AC1,0(SP)			; AC1,GS+2
	MOVE	AC4,U.80			; AC4,CURNML
	ADDI	AC4,1				; AC4,1
	HRRZ	AC5,0(SP)			; HLF,GS+2
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,U.80			; AC1,CURNML
	MOVE	AC2,C.26			; AC2,[POINT 7,BUF0+10777,34]  <1,7>
	EXTEND	AC1,C.8				; AC1,C.8
	JFCL					; 
	MOVEI	AC1,-2(SP)			; AC1,GS
	PUSHJ	SP,PCICGS			; SP,PCICGS
	ADJSP	SP,-3				; SP,-3
	POPJ	SP,				; SP,
C.19:	POINT	3,-2(SP),4			; 3,GS,4
C.20:	POINT	4,-2(SP),9			; 4,GS,9
C.21:	POINT	1,-2(SP),5			; 1,GS,5
C.22:	POINT	8,-2(SP),17			; 8,GS,17
C.23:	POINT	12,-1(SP),35			; 12,GS+1,35
C.24:	POINT	12,-1(SP),23			; 12,GS+1,23
C.25:	POINT	12,-1(SP),11			; 12,GS+1,11
C.26:	POINT	7,BUF0+10777,34			; 7,BUF0+10777,34

; Routine Size:  48 words


;	  1339	
;	  1340	GLOBAL ROUTINE PCCCPL(CPLPTR): NOVALUE =	! Main routine
;	  1341	
;	  1342	!++
;	  1343	! Functional description:
;	  1344	!	Defines a sequence of commands, procedures, and global variables,
;	  1345	!	from source string provided by caller.
;	  1346	!
;	  1347	! Formal parameters:
;	  1348	!	Pointer to ASCIZ source string
;	  1349	!
;	  1350	! Implicit inputs:
;	  1351	!	The source
;	  1352	!
;	  1353	! Implicit outputs:
;	  1354	!	Text region, global symbol table, the three work areas
;	  1355	!
;	  1356	! Routine value:
;	  1357	!	None
;	  1358	!
;	  1359	! Side effects:
;	  1360	!	None
;	  1361	!
;	  1362	!--
;	  1363	
;	  1364	    BEGIN
;	  1365	    EXTERNAL REGISTER Z=0;
;	  1366	    SCAPTR = .CPLPTR;
;	  1367	    LLNPTR = .SCAPTR;
;	  1368	    SCATRP = 0;
;	  1369	    SCALIN = 1;
;	  1370	    SCAN();
;	  1371	    DO
;	  1372		BEGIN
;	  1373		SELECTONE .SCACOD OF
;	  1374		    SET
;	  1375	[SCN_COMMAND]:	CURCLS = GST_CLS_CMD;
;	  1376	[SCN_INTEGER,
;	  1377	 SCN_STRING]:	BEGIN
;	  1378			CURTYP =
;	  1379			(IF .SCACOD EQL SCN_INTEGER THEN GST_TYP_INT ELSE GST_TYP_STR);
;	  1380			IF SCAN() EQL SCN_PROCEDURE
;	  1381			THEN
;	  1382			    CURCLS = GST_CLS_FCN
;	  1383			ELSE
;	  1384			IF .SCACOD EQL SCN_IDENT
;	  1385			THEN
;	  1386			    CURCLS = GST_CLS_VAR
;	  1387			ELSE
;	  1388			    ERROR('PROCEDURE or variable name missing')
;	  1389			END;
;	  1390	[SCN_PROCEDURE]:
;	  1391			CURCLS = GST_CLS_PRC;
;	  1392	[SCN_SYNONYM,
;	  1393	 SCN_NOORIGINAL]:
;	  1394			BEGIN
;	  1395			CURCLS = GST_CLS_SYN;
;	  1396			CURTYP = (IF .SCACOD EQL SCN_SYNONYM THEN 0 ELSE 1)
;	  1397			END;
;	  1398	[OTHERWISE]:	ERROR('Unable to recognize definition')
;	  1399		    TES;
;	  1400		SELECTONE .CURCLS OF
;	  1401		    SET
;	  1402	[GST_CLS_VAR]:	CPVARD();
;	  1403	[GST_CLS_SYN]:	CPSYND();
;	  1404	[OTHERWISE]:	CPCMPL()
;	  1405		    TES;
;	  1406		IF .SCACOD EQL SCN_SEMI THEN SCAN()
;	  1407		END
;	  1408	    UNTIL
;	  1409		.SCACOD EQL SCN_EOFILE
;	  1410	    END;


P.AFI:	BYTE	(7)"P","R","O","C","E"		; PROCE
	BYTE	(7)"D","U","R","E"," "		; DURE
	BYTE	(7)"o","r"," ","v","a"		; or va
	BYTE	(7)"r","i","a","b","l"		; riabl
	BYTE	(7)"e"," ","n","a","m"		; e nam
	BYTE	(7)"e"," ","m","i","s"		; e mis
	BYTE	(7)"s","i","n","g",000		; sing
P.AFJ:	BYTE	(7)"U","n","a","b","l"		; Unabl
	BYTE	(7)"e"," ","t","o"," "		; e to
	BYTE	(7)"r","e","c","o","g"		; recog
	BYTE	(7)"n","i","z","e"," "		; nize
	BYTE	(7)"d","e","f","i","n"		; defin
	BYTE	(7)"i","t","i","o","n"		; ition
	BYTE	(7)000,000,000,000,000


U.11:
PCCCPL::PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVEM	AC1,U.87			; CPLPTR,SCAPTR
	MOVEM	AC1,U.89			; AC1,LLNPTR
	SETZM	U.90				; SCATRP
	MOVEI	AC1,1				; AC1,1
	MOVEM	AC1,U.88			; AC1,SCALIN
	PUSHJ	SP,U.3				; SP,SCAN
	MOVE	AC13,U.95			; AC13,SCACOD
L.128:	CAIE	AC13,26				; AC13,26
	JRST	L.129				; L.129
	SETZM	U.81				; CURCLS
	JRST	L.137				; L.137
L.129:	CAIL	AC13,34				; AC13,34
	CAILE	AC13,35				; AC13,35
	JRST	L.132				; L.132
	CAIN	AC13,34				; AC13,34
	TDZA	AC1,AC1				; AC1,AC1
	MOVEI	AC1,1				; AC1,1
	MOVEM	AC1,U.82			; AC1,CURTYP
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,25				; AC1,25
	JRST	L.130				; L.130
	MOVEI	AC1,3				; AC1,3
	JRST	L.133				; L.133
L.130:	MOVEI	AC1,1				; AC1,1
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.131				; L.131
	MOVEI	AC1,2				; AC1,2
	JRST	L.133				; L.133
L.131:	MOVEI	AC1,P.AFI			; AC1,P.AFI
	JRST	L.136				; L.136
L.132:	CAIE	AC13,25				; AC13,25
	JRST	L.134				; L.134
	MOVEI	AC1,1				; AC1,1
L.133:	MOVEM	AC1,U.81			; AC1,CURCLS
	JRST	L.137				; L.137
L.134:	CAIL	AC13,27				; AC13,27
	CAILE	AC13,30				; AC13,30
	JRST	L.135				; L.135
	MOVEI	AC1,4				; AC1,4
	MOVEM	AC1,U.81			; AC1,CURCLS
	MOVEI	AC1,27				; AC1,27
	CAMN	AC1,U.95			; AC1,SCACOD
	TDZA	AC1,AC1				; AC1,AC1
	MOVEI	AC1,1				; AC1,1
	MOVEM	AC1,U.82			; AC1,CURTYP
	JRST	L.137				; L.137
L.135:	MOVEI	AC1,P.AFJ			; AC1,P.AFJ
L.136:	PUSHJ	SP,U.1				; SP,CERROR
L.137:	MOVE	AC14,U.81			; AC14,CURCLS
	CAIE	AC14,2				; AC14,2
	JRST	L.138				; L.138
	PUSHJ	SP,U.12				; SP,CPVARD
	JRST	L.140				; L.140
L.138:	CAIE	AC14,4				; AC14,4
	JRST	L.139				; L.139
	PUSHJ	SP,U.13				; SP,CPSYND
	JRST	L.140				; L.140
L.139:	PUSHJ	SP,U.14				; SP,CPCMPL
L.140:	MOVEI	AC1,20				; AC1,20
	CAMN	AC1,U.95			; AC1,SCACOD
	PUSHJ	SP,U.3				; SP,SCAN
	MOVE	AC13,U.95			; AC13,SCACOD
	CAIE	AC13,134			; AC13,134
	JRST	L.128				; L.128
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  69 words


;	  1411	
;	  1412	ROUTINE CPVARD: NOVALUE =	! Define a variable
;	  1413	
;	  1414	!++
;	  1415	! Functional description:
;	  1416	!	Defines a global variable.
;	  1417	!
;	  1418	! Formal parameters:
;	  1419	!	None
;	  1420	!
;	  1421	! Implicit inputs:
;	  1422	!	Source file, CURTYP
;	  1423	!
;	  1424	! Implicit outputs:
;	  1425	!	Global symbol table
;	  1426	!
;	  1427	! Routine value:
;	  1428	!	None
;	  1429	!
;	  1430	! Side effects:
;	  1431	!	Scans past variable name
;	  1432	!
;	  1433	!--
;	  1434	
;	  1435	    BEGIN
;	  1436	    EXTERNAL REGISTER Z=0;
;	  1437	    PCIDFV(.SCALEN^18 + SCATOM, (IF .CURTYP EQL GST_TYP_INT THEN 0 ELSE -1));
;	  1438	    SCAN()
;	  1439	    END;


; CPVARD
U.12:	HRLZ	AC1,U.93			; AC1,SCALEN
	ADD	AC1,C.3				; AC1,[SCATOM]
	SKIPN	U.82				; CURTYP
	TDZA	AC2,AC2				; AC2,AC2
	SETO	AC2,				; AC2,
	PUSHJ	SP,PCIDFV			; SP,PCIDFV
	JRST	U.3				; SCAN

; Routine Size:  7 words


;	  1440	
;	  1441	ROUTINE CPSYND: NOVALUE =	! Define a synonym
;	  1442	
;	  1443	!++
;	  1444	! Functional description:
;	  1445	!	Defines a synonym or removed original command.
;	  1446	!
;	  1447	! Formal parameters:
;	  1448	!	None
;	  1449	!
;	  1450	! Implicit inputs:
;	  1451	!	Source file, CURTYP
;	  1452	!
;	  1453	! Implicit outputs:
;	  1454	!	Global symbol table
;	  1455	!
;	  1456	! Routine value:
;	  1457	!	None
;	  1458	!
;	  1459	! Side effects:
;	  1460	!	Scans to unrecognized atom
;	  1461	!
;	  1462	!--
;	  1463	
;	  1464	    BEGIN
;	  1465	    EXTERNAL REGISTER Z=0;
;	  1466	    LOCAL
;	  1467		NAME: VECTOR[8],	! Command name
;	  1468		NAMVAL: STR_VAL,	! Stringvalue of it
;	  1469		NAMLEN,			! Its length
;	  1470		PTRI,			! Character pointers
;	  1471		PTRO,
;	  1472		CHR;
;	  1473	    SCATRP = -1;
;	  1474	    IF SCAN() NEQ SCN_IDENT THEN ERROR('Command name not found');
;	  1475	    PTRI = BYTPTR(SCATOM);
;	  1476	    PTRO = BYTPTR(NAME);
;	  1477	    DO
;	  1478		BEGIN
;	  1479		CHR = CH$RCHAR_A(PTRI);
;	  1480		IF .CHR GEQ %C'a' AND .CHR LEQ %C'z' THEN CHR = .CHR - %C'a' + %C'A';
;	  1481		IF .CHR EQL %C'_' THEN CHR = %C'-';
;	  1482		CH$WCHAR_A(.CHR,PTRO)
;	  1483		END
;	  1484	    UNTIL
;	  1485		.CHR EQL $CHNUL;
;	  1486	    NAMVAL[STV_ADR] = NAME;
;	  1487	    NAMVAL[STV_LEN] = .SCALEN;
;	  1488	    IF .CURTYP EQL 0
;	  1489	    THEN
;	  1490		BEGIN
;	  1491		IF SCAN() NEQ SCN_IDENT THEN ERROR('Old command name missing');
;	  1492		PTRI = PTRO = BYTPTR(SCATOM);
;	  1493		DO
;	  1494		    BEGIN
;	  1495		    CHR = CH$RCHAR_A(PTRI);
;	  1496		    IF .CHR EQL %C'_' THEN CHR = %C'-';
;	  1497		    CH$WCHAR_A(.CHR,PTRO)
;	  1498		    END
;	  1499		UNTIL
;	  1500		    .CHR EQL $CHNUL
;	  1501		END;
;	  1502	    SCATRP = 0;
;	  1503	    PCIDFS(.NAMVAL, (IF .CURTYP EQL 0 THEN SCATOM ELSE 0));
;	  1504	    SCAN()
;	  1505	    END;


P.AFK:	BYTE	(7)"C","o","m","m","a"		; Comma
	BYTE	(7)"n","d"," ","n","a"		; nd na
	BYTE	(7)"m","e"," ","n","o"		; me no
	BYTE	(7)"t"," ","f","o","u"		; t fou
	BYTE	(7)"n","d",000,000,000		; nd
P.AFL:	BYTE	(7)"O","l","d"," ","c"		; Old c
	BYTE	(7)"o","m","m","a","n"		; omman
	BYTE	(7)"d"," ","n","a","m"		; d nam
	BYTE	(7)"e"," ","m","i","s"		; e mis
	BYTE	(7)"s","i","n","g",000		; sing


; CPSYND
U.13:	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,10				; SP,10
	SETOM	U.90				; SCATRP
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,1				; AC1,1
	JRST	L.141				; L.141
	MOVEI	AC1,P.AFK			; AC1,P.AFK
	PUSHJ	SP,U.1				; SP,CERROR
L.141:	MOVE	AC1,C.3				; HLF,[SCATOM]
	HRLI	AC1,-337100			; HLF,-337100
	MOVE	AC11,AC1			; PTRI,HLF
	MOVEI	AC1,-7(SP)			; HLF,NAME
	HRLI	AC1,-337100			; HLF,-337100
	MOVE	AC13,AC1			; PTRO,HLF
L.142:	ILDB	AC14,AC11			; CHR,PTRI
	CAIL	AC14,141			; CHR,141
	CAILE	AC14,172			; CHR,172
	JRST	L.143				; L.143
	SUBI	AC14,40				; CHR,40
L.143:	CAIN	AC14,137			; CHR,137
	MOVEI	AC14,55				; CHR,55
	IDPB	AC14,AC13			; CHR,PTRO
	JUMPN	AC14,L.142			; CHR,L.142
	MOVEI	AC1,-7(SP)			; AC1,NAME
	HRR	AC12,AC1			; NAMVAL,AC1
	HRL	AC12,U.93			; NAMVAL,SCALEN
	SKIPE	U.82				; CURTYP
	JRST	L.146				; L.146
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,1				; AC1,1
	JRST	L.144				; L.144
	MOVEI	AC1,P.AFL			; AC1,P.AFL
	PUSHJ	SP,U.1				; SP,CERROR
L.144:	MOVE	AC1,C.3				; HLF,[SCATOM]
	HRLI	AC1,-337100			; HLF,-337100
	MOVE	AC13,AC1			; PTRO,HLF
	MOVE	AC11,AC1			; PTRI,HLF
L.145:	ILDB	AC14,AC11			; CHR,PTRI
	CAIN	AC14,137			; CHR,137
	MOVEI	AC14,55				; CHR,55
	IDPB	AC14,AC13			; CHR,PTRO
	JUMPN	AC14,L.145			; CHR,L.145
L.146:	SETZM	U.90				; SCATRP
	SKIPN	U.82				; CURTYP
	SKIPA	AC2,C.3				; AC2,[SCATOM]
	SETZ	AC2,				; AC2,
	MOVE	AC1,AC12			; AC1,NAMVAL
	PUSHJ	SP,PCIDFS			; SP,PCIDFS
	PUSHJ	SP,U.3				; SP,SCAN
	ADJSP	SP,-10				; SP,-10
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,

; Routine Size:  58 words


;	  1506	
;	  1507	ROUTINE CPCMPL: NOVALUE =	! Define a routine
;	  1508	
;	  1509	!++
;	  1510	! Functional description:
;	  1511	!	Compiles a command or procedure into temporary work areas defined
;	  1512	!	in EXECDE.  It then merges the generated code, constants, and
;	  1513	!	symbol table into the text region, and creates the global symbol
;	  1514	!	entry for the routine.
;	  1515	!
;	  1516	! Formal parameters:
;	  1517	!	None
;	  1518	!
;	  1519	! Implicit inputs:
;	  1520	!	The source, CURCLS, CURTYP
;	  1521	!
;	  1522	! Implicit outputs:
;	  1523	!	Text, global symbol table
;	  1524	!
;	  1525	! Routine value:
;	  1526	!	None
;	  1527	!
;	  1528	! Side effects:
;	  1529	!	Scans from routine name to after last atom of routine
;	  1530	!
;	  1531	!--
;	  1532	
;	  1533	    BEGIN
;	  1534	    EXTERNAL REGISTER Z=0;
;	  1535	    LOCAL
;	  1536		GS: REF GST_BLK;	! GST entry
;	  1537	    NEXTIN = 0;
;	  1538	    SCATRP = 0;
;	  1539	    CONSTP = 0;
;	  1540	    SYMTBP = 0;
;	  1541	    CURNML = 0;
;	  1542	    PRCARG[0] = 0;
;	  1543	    CMDARG = -1;
;	  1544	    NUMVRS = 0;
;	  1545	    LBLCNT = 0;
;	  1546	    CPRTNC();			! Compile the routine
;	  1547	    GENINS(OPR_RET,0,0,0);	! Provide a free RET
;	  1548	    ASMPRC();			! Assemble the components into text region
;	  1549	    DEFPRC()			! Define in global symbol table
;	  1550	    END;


; CPCMPL
U.14:	SETZM	U.86				; NEXTIN
	SETZM	U.90				; SCATRP
	SETZM	U.97				; CONSTP
	SETZM	U.98				; SYMTBP
	SETZM	U.80				; CURNML
	SETZM	U.84				; PRCARG
	SETOM	U.85				; CMDARG
	SETZM	U.96				; NUMVRS
	SETZM	U.101				; LBLCNT
	PUSHJ	SP,U.15				; SP,CPRTNC
	MOVEI	AC1,33				; AC1,33
	SETZB	AC2,AC3				; AC2,AC3
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
	PUSHJ	SP,U.9				; SP,ASMPRC
	JRST	U.10				; DEFPRC

; Routine Size:  16 words


;	  1551	
;	  1552	ROUTINE CPRTNC: NOVALUE =	! <Procedure-declaration>
;	  1553	
;	  1554	!++
;	  1555	! Functional description:
;	  1556	!	Compile one command, procedure or function.  Find routine name, proces
;	  1557	!	any formal parameter list, do routine body, do final label
;	  1558	!	processing.
;	  1559	!
;	  1560	! Formal parameters:
;	  1561	!	None
;	  1562	!
;	  1563	! Implicit inputs:
;	  1564	!	Source, label table
;	  1565	!
;	  1566	! Implicit outputs:
;	  1567	!	Routine name, class, type
;	  1568	!
;	  1569	! Routine value:
;	  1570	!	None
;	  1571	!
;	  1572	! Side effects:
;	  1573	!	Scans from routine name to unrecognized atom
;	  1574	!
;	  1575	!--
;	  1576	
;	  1577	    BEGIN
;	  1578	    EXTERNAL REGISTER Z=0;
;	  1579	    SCATRP = -1;
;	  1580	    IF SCAN() NEQ SCN_IDENT THEN CERROR(CERM3);
;	  1581	    SCATRP = 0;
;	  1582	    CURNML = .SCALEN;
;	  1583	    CH$MOVE(.SCALEN, CH$PTR(SCATOM), CH$PTR(CURRTN));
;	  1584	    IF .CURCLS EQL GST_CLS_CMD
;	  1585	    THEN
;	  1586		BEGIN
;	  1587		LOCAL PTR;
;	  1588		PTR = CH$PTR(CURRTN);
;	  1589		DECR I FROM .SCALEN-1 DO
;	  1590		    IF CH$RCHAR_A(PTR) EQL %C'_' THEN CH$WCHAR(%C'-',CH$PLUS(.PTR,-1))
;	  1591		END;
;	  1592	    IF SCAN() EQL SCN_LPAREN
;	  1593	    THEN
;	  1594		BEGIN
;	  1595		IF .CURCLS EQL GST_CLS_CMD THEN CPCARG() ELSE CPFRML();
;	  1596		IF .SCACOD NEQ SCN_RPAREN THEN CERROR(CERM6);
;	  1597		SCAN()
;	  1598		END;
;	  1599	    IF .SCACOD NEQ SCN_SEMI THEN CERROR(CERM6);
;	  1600	    SCAN();
;	  1601	    CPBODY();
;	  1602	    DECR I FROM .LBLCNT-1 DO
;	  1603		IF .LBLADR[.I] LSS 0
;	  1604		THEN
;	  1605		    BEGIN
;	  1606		    LOCAL
;	  1607			STR: STR_VAL;
;	  1608		    STR = .LBLNAM[.I];
;	  1609		    CERROR( UPLIT(%ASCIZ 'Label #1 left undefined'), .STR[STV_ADR])
;	  1610		    END
;	  1611	    END;


P.AFM:	BYTE	(7)"L","a","b","e","l"		; Label
	BYTE	(7)" ","#","1"," ","l"		;  #1 l
	BYTE	(7)"e","f","t"," ","u"		; eft u
	BYTE	(7)"n","d","e","f","i"		; ndefi
	BYTE	(7)"n","e","d",000,000		; ned


; CPRTNC
U.15:	PUSH	SP,AC14				; SP,AC14
	SETOM	U.90				; SCATRP
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,1				; AC1,1
	JRST	L.147				; L.147
	MOVEI	AC1,U.53			; AC1,CERM3
	PUSHJ	SP,U.1				; SP,CERROR
L.147:	SETZM	U.90				; SCATRP
	MOVE	AC1,U.93			; AC1,SCALEN
	MOVEM	AC1,U.80			; AC1,CURNML
	MOVE	AC1,U.93			; AC1,SCALEN
	MOVE	AC2,C.2				; AC2,[POINT 7,BUF0+11062,34]  <1,7>
	MOVE	AC4,U.93			; AC4,SCALEN
	MOVE	AC5,C.26			; AC5,[POINT 7,BUF0+10777,34]  <1,7>
	EXTEND	AC1,C.12			; AC1,[MOVSLJ ]
	JFCL					; 
	SKIPE	U.81				; CURCLS
	JRST	L.150				; L.150
	MOVE	AC3,C.26			; PTR,[POINT 7,BUF0+10777,34]  <1,7>
	MOVE	AC4,U.93			; I,SCALEN
	JRST	L.149				; L.149
L.148:	ILDB	AC1,AC3				; AC1,PTR
	CAIE	AC1,137				; AC1,137
	JRST	L.149				; L.149
	MOVEI	AC2,55				; AC2,55
	SETO	AC1,				; AC1,
	ADJBP	AC1,AC3				; AC1,PTR
	IDPB	AC2,AC1				; AC2,AC1
L.149:	SOJGE	AC4,L.148			; I,L.148
L.150:	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,16				; AC1,16
	JRST	L.154				; L.154
	SKIPE	U.81				; CURCLS
	JRST	L.151				; L.151
	PUSHJ	SP,U.17				; SP,CPCARG
	JRST	L.152				; L.152
L.151:	PUSHJ	SP,U.16				; SP,CPFRML
L.152:	MOVEI	AC1,17				; AC1,17
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.153				; L.153
	MOVEI	AC1,U.56			; AC1,CERM6
	PUSHJ	SP,U.1				; SP,CERROR
L.153:	PUSHJ	SP,U.3				; SP,SCAN
L.154:	MOVEI	AC1,20				; AC1,20
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.155				; L.155
	MOVEI	AC1,U.56			; AC1,CERM6
	PUSHJ	SP,U.1				; SP,CERROR
L.155:	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.18				; SP,CPBODY
	MOVE	AC14,U.101			; I,LBLCNT
	JRST	L.157				; L.157
L.156:	SKIPL	U.100(AC14)			; LBLADR(I)
	JRST	L.157				; L.157
	MOVE	AC3,U.99(AC14)			; STR,LBLNAM(I)
	MOVEI	AC1,P.AFM			; AC1,P.AFM
	MOVEI	AC2,0(AC3)			; AC2,0(STR)
	PUSHJ	SP,U.1				; SP,CERROR
L.157:	SOJGE	AC14,L.156			; I,L.156
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  61 words


;	  1612	
;	  1613	ROUTINE CPFRML: NOVALUE =	! <Formal-parameter-list>
;	  1614	
;	  1615	!++
;	  1616	! Functional description:
;	  1617	!	Called from <Procedure-declaration> to compile formal parameter
;	  1618	!	list.  Builds parameter list into PRCARG.
;	  1619	!
;	  1620	! Formal parameters:
;	  1621	!	None
;	  1622	!
;	  1623	! Implicit inputs:
;	  1624	!	Source
;	  1625	!
;	  1626	! Implicit outputs:
;	  1627	!	PRCARG
;	  1628	!
;	  1629	! Routine value:
;	  1630	!	None
;	  1631	!
;	  1632	! Side effects:
;	  1633	!	Scans from ( to )
;	  1634	!
;	  1635	!--
;	  1636	
;	  1637	    BEGIN
;	  1638	    EXTERNAL REGISTER Z=0;
;	  1639	    LOCAL
;	  1640		STE,			! Symbol table index of parameter
;	  1641		TYP;			! Type of parameter
;	  1642	    DO
;	  1643		BEGIN
;	  1644		TYP = SCAN();
;	  1645		IF .TYP NEQ SCN_INTEGER AND .TYP NEQ SCN_STRING
;	  1646		THEN
;	  1647		    ERROR('Type missing');
;	  1648		TYP = (IF .TYP EQL SCN_INTEGER THEN STE_TYP_INT ELSE STE_TYP_STR);
;	  1649		DO
;	  1650		    BEGIN
;	  1651		    IF SCAN() NEQ SCN_IDENT THEN CERROR(CERM3);
;	  1652		    STE = ADDSMB();
;	  1653		    IF .STE LSS 0 THEN CERROR(CERM4);
;	  1654		    SYMWRK[.STE,STE_CLS] = STE_CLS_FML;
;	  1655		    SYMWRK[.STE,STE_TYP] = .TYP;
;	  1656		    IF .PRCARG[0] GEQ MAXPRM THEN ERROR('Too many parameters');
;	  1657		    PRCARG[0] = .PRCARG[0] + 1;
;	  1658		    PRCARG[.PRCARG[0]] = .STE
;	  1659		    END
;	  1660		WHILE
;	  1661		    SCAN() EQL SCN_COMMA;
;	  1662		END
;	  1663	    WHILE
;	  1664		.SCACOD EQL SCN_SEMI;
;	  1665	    DECR I FROM .PRCARG[0] TO 1 DO
;	  1666		BEGIN
;	  1667		STE = .PRCARG[.I];
;	  1668		SYMWRK[.STE,STE_LOC] =  - .PRCARG[0] + .I - 1;
;	  1669		PRCARG[.I] = .SYMWRK[.STE,STE_TYP]
;	  1670		END
;	  1671	    END;


P.AFN:	BYTE	(7)"T","y","p","e"," "		; Type
	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g",000,000,000		; ng
P.AFO:	BYTE	(7)"T","o","o"," ","m"		; Too m
	BYTE	(7)"a","n","y"," ","p"		; any p
	BYTE	(7)"a","r","a","m","e"		; arame
	BYTE	(7)"t","e","r","s",000		; ters


; CPFRML
U.16:	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
L.158:	PUSHJ	SP,U.3				; SP,SCAN
	MOVE	AC14,AC1			; TYP,AC1
	CAIE	AC14,34				; TYP,34
	CAIN	AC14,35				; TYP,35
	JRST	L.159				; L.159
	MOVEI	AC1,P.AFN			; AC1,P.AFN
	PUSHJ	SP,U.1				; SP,CERROR
L.159:	CAIN	AC14,34				; TYP,34
	TDZA	AC14,AC14			; TYP,TYP
	MOVEI	AC14,1				; TYP,1
L.160:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,1				; AC1,1
	JRST	L.161				; L.161
	MOVEI	AC1,U.53			; AC1,CERM3
	PUSHJ	SP,U.1				; SP,CERROR
L.161:	PUSHJ	SP,U.4				; SP,ADDSMB
	MOVE	AC13,AC1			; STE,AC1
	JUMPGE	AC13,L.162			; STE,L.162
	MOVEI	AC1,U.54			; AC1,CERM4
	PUSHJ	SP,U.1				; SP,CERROR
L.162:	MOVE	AC1,AC13			; AC1,STE
	IMULI	AC1,2				; AC1,2
	MOVEI	AC2,2				; AC2,2
	DPB	AC2,C.27			; AC2,[POINT 3,SYMWRK(AC1),5]  <30,3>
	DPB	AC14,C.28			; TYP,[POINT 1,SYMWRK(AC1),6]  <29,1>
	MOVEI	AC1,10				; AC1,10
	CAMLE	AC1,U.84			; AC1,PRCARG
	JRST	L.163				; L.163
	MOVEI	AC1,P.AFO			; AC1,P.AFO
	PUSHJ	SP,U.1				; SP,CERROR
L.163:	AOS	AC1,U.84			; AC1,PRCARG
	MOVEM	AC13,U.84(AC1)			; STE,PRCARG(AC1)
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,21				; AC1,21
	JRST	L.160				; L.160
	MOVEI	AC1,20				; AC1,20
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.158				; L.158
	MOVE	AC2,U.84			; I,PRCARG
	AOJA	AC2,L.165			; I,L.165
L.164:	MOVE	AC13,U.84(AC2)			; STE,PRCARG(I)
	MOVE	AC1,AC13			; AC1,STE
	IMULI	AC1,2				; AC1,2
	MOVE	AC3,U.84			; AC3,PRCARG
	SUB	AC3,AC2				; AC3,I
	SETO	AC4,				; AC4,
	SUB	AC4,AC3				; AC4,AC3
	HRRM	AC4,U.77(AC1)			; AC4,SYMWRK(AC1)
	LDB	AC3,C.28			; AC3,[POINT 1,SYMWRK(AC1),6]  <29,1>
	MOVEM	AC3,U.84(AC2)			; AC3,PRCARG(I)
L.165:	SOJG	AC2,L.164			; I,L.164
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,
C.27:	POINT	3,U.77(AC1),5			; 3,SYMWRK(AC1),5
C.28:	POINT	1,U.77(AC1),6			; 1,SYMWRK(AC1),6

; Routine Size:  58 words


;	  1672	
;	  1673	ROUTINE CPCARG: NOVALUE =	! Command arguments
;	  1674	
;	  1675	!++
;	  1676	! Functional description:
;	  1677	!	Compile command arguments:  Generate appropriate field descriptors
;	  1678	!	in constants, containing descriptors of local symbols in which
;	  1679	!	results should be stored.  Declare each symbol used.
;	  1680	!
;	  1681	! Formal parameters:
;	  1682	!	None
;	  1683	!
;	  1684	! Implicit inputs:
;	  1685	!	Source
;	  1686	!
;	  1687	! Implicit outputs:
;	  1688	!	Constants
;	  1689	!
;	  1690	! Routine value:
;	  1691	!	None
;	  1692	!
;	  1693	! Side effects:
;	  1694	!	Scans from ( to )
;	  1695	!
;	  1696	!--
;	  1697	
;	  1698	    BEGIN
;	  1699	    EXTERNAL REGISTER Z=0;
;	  1700	    LOCAL
;	  1701		FNC,			! Parse-type code
;	  1702		FDB,			! Constant index of current FLDDB
;	  1703		LFDB;			! Constant index of last FLDDB
;	  1704	    LFDB = -1;
;	  1705	    DO
;	  1706		BEGIN
;	  1707		SCAN();
;	  1708		! Identify the parse-type
;	  1709		FDB = CPPRSI(1,0);
;	  1710		IF .FDB LSS 0 THEN ERROR('OTHERWISE meaningless here');
;	  1711		! Link the new FLDDB to the preceding FLDDB
;	  1712		IF .LFDB GEQ 0
;	  1713		THEN
;	  1714		    POINTR((CNSWRK[.LFDB+$CMFNP]),CM_LST) = .FDB
;	  1715		ELSE
;	  1716		    CMDARG = .FDB;
;	  1717		LFDB = .FDB;
;	  1718		END
;	  1719	    WHILE
;	  1720		.SCACOD EQL SCN_SEMI
;	  1721	    END;


P.AFP:	BYTE	(7)"O","T","H","E","R"		; OTHER
	BYTE	(7)"W","I","S","E"," "		; WISE
	BYTE	(7)"m","e","a","n","i"		; meani
	BYTE	(7)"n","g","l","e","s"		; ngles
	BYTE	(7)"s"," ","h","e","r"		; s her
	BYTE	(7)"e",000,000,000,000		; e


; CPCARG
U.17:	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	SETO	AC14,				; LFDB,
L.166:	PUSHJ	SP,U.3				; SP,SCAN
	MOVEI	AC1,1				; AC1,1
	SETZ	AC2,				; AC2,
	PUSHJ	SP,U.34				; SP,CPPRSI
	MOVE	AC13,AC1			; FDB,AC1
	JUMPGE	AC13,L.167			; FDB,L.167
	MOVEI	AC1,P.AFP			; AC1,P.AFP
	PUSHJ	SP,U.1				; SP,CERROR
L.167:	JUMPL	AC14,L.168			; LFDB,L.168
	HRRM	AC13,U.78(AC14)			; FDB,CNSWRK(LFDB)
	JRST	L.169				; L.169
L.168:	MOVEM	AC13,U.85			; FDB,CMDARG
L.169:	MOVE	AC14,AC13			; LFDB,FDB
	MOVEI	AC1,20				; AC1,20
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.166				; L.166
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  22 words


;	  1722	
;	  1723	ROUTINE CPBODY: NOVALUE =		!<Procedure-body>
;	  1724	
;	  1725	!++
;	  1726	! Functional description:
;	  1727	!	Called from <Procedure-declaration> to compile body of routine.
;	  1728	!	This may be a block or just a statement.
;	  1729	!
;	  1730	! Formal parameters:
;	  1731	!	None
;	  1732	!
;	  1733	! Implicit inputs:
;	  1734	!	Source
;	  1735	!
;	  1736	! Implicit outputs:
;	  1737	!	None
;	  1738	!
;	  1739	! Routine value:
;	  1740	!	None
;	  1741	!
;	  1742	! Side effects:
;	  1743	!	Scans from BEGIN to unrecognized atom
;	  1744	!
;	  1745	!--
;	  1746	
;	  1747	    BEGIN
;	  1748	    EXTERNAL REGISTER Z=0;
;	  1749	    IF .SCACOD NEQ SCN_BEGIN
;	  1750	    THEN
;	  1751		BEGIN
;	  1752		IF CPSTMT() EQL FALSE THEN CERROR(CERM9);
;	  1753		RETURN
;	  1754		END;
;	  1755	    SCAN();
;	  1756	    WHILE
;	  1757		CPDECL() NEQ FALSE
;	  1758	    DO
;	  1759		(IF .SCACOD NEQ SCN_SEMI THEN CERROR(CERM6); SCAN());
;	  1760	    WHILE
;	  1761		.SCACOD NEQ SCN_END AND CPSTMT() NEQ FALSE
;	  1762	    DO
;	  1763		(IF .SCACOD NEQ SCN_SEMI AND .SCACOD NEQ SCN_END
;	  1764		 THEN
;	  1765		    ERROR('No semicolon or End after last statement');
;	  1766		 IF .SCACOD EQL SCN_SEMI THEN SCAN());
;	  1767	    IF .SCACOD NEQ SCN_END THEN CERROR(CERM7);
;	  1768	    SCAN()
;	  1769	    END;


P.AFQ:	BYTE	(7)"N","o"," ","s","e"		; No se
	BYTE	(7)"m","i","c","o","l"		; micol
	BYTE	(7)"o","n"," ","o","r"		; on or
	BYTE	(7)" ","E","n","d"," "		;  End
	BYTE	(7)"a","f","t","e","r"		; after
	BYTE	(7)" ","l","a","s","t"		;  last
	BYTE	(7)" ","s","t","a","t"		;  stat
	BYTE	(7)"e","m","e","n","t"		; ement
	BYTE	(7)000,000,000,000,000


; CPBODY
U.18:	MOVEI	AC1,31				; AC1,31
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.170				; L.170
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPN	AC1,L.175			; AC1,L.175
	MOVEI	AC1,U.59			; AC1,CERM9
	JRST	U.1				; CERROR
L.170:	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.19				; SP,CPDECL
	JUMPE	AC1,L.171			; AC1,L.171
	MOVEI	AC1,20				; AC1,20
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.170				; L.170
	MOVEI	AC1,U.56			; AC1,CERM6
	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.170				; L.170
L.171:	MOVEI	AC1,32				; AC1,32
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.173				; L.173
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPE	AC1,L.173			; AC1,L.173
	MOVE	AC1,U.95			; AC1,SCACOD
	CAIE	AC1,20				; AC1,20
	CAIN	AC1,32				; AC1,32
	JRST	L.172				; L.172
	MOVEI	AC1,P.AFQ			; AC1,P.AFQ
	PUSHJ	SP,U.1				; SP,CERROR
L.172:	MOVEI	AC1,20				; AC1,20
	CAMN	AC1,U.95			; AC1,SCACOD
	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.171				; L.171
L.173:	MOVEI	AC1,32				; AC1,32
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.174				; L.174
	MOVEI	AC1,U.57			; AC1,CERM7
	PUSHJ	SP,U.1				; SP,CERROR
L.174:	PUSHJ	SP,U.3				; SP,SCAN
L.175:	POPJ	SP,				; SP,

; Routine Size:  38 words

;	  1770	
;	  1771	ROUTINE CPDECL =			! <Declaration>
;	  1772	
;	  1773	!++
;	  1774	! Functional description:
;	  1775	!	Called from <Procedure-body> to process one declaration.
;	  1776	!
;	  1777	! Formal parameters:
;	  1778	!	None
;	  1779	!
;	  1780	! Implicit inputs:
;	  1781	!	Source
;	  1782	!
;	  1783	! Implicit outputs:
;	  1784	!	Symbol table
;	  1785	!
;	  1786	! Routine value:
;	  1787	!	TRUE if declaration recognized, FALSE if not
;	  1788	!
;	  1789	! Side effects:
;	  1790	!	Scans from <Simple-type> past last <Identifier>
;	  1791	!
;	  1792	!--
;	  1793	
;	  1794	    BEGIN
;	  1795	    EXTERNAL REGISTER Z=0;
;	  1796	    LOCAL
;	  1797		STE,			! Symbol table index
;	  1798		CLS,			! Variable class
;	  1799		TYP;			! Variable type
;	  1800	    IF .SCACOD NEQ SCN_EXTERNAL AND .SCACOD NEQ SCN_INTEGER
;	  1801		AND .SCACOD NEQ SCN_STRING THEN RETURN FALSE;
;	  1802	    CLS = STE_CLS_VAR;
;	  1803	    IF .SCACOD EQL SCN_EXTERNAL THEN (CLS = STE_CLS_GBL; SCAN());
;	  1804	    IF .SCACOD EQL SCN_INTEGER OR .SCACOD EQL SCN_STRING
;	  1805	    THEN
;	  1806		BEGIN
;	  1807		TYP = (IF .SCACOD EQL SCN_INTEGER THEN STE_TYP_INT ELSE STE_TYP_STR);
;	  1808		IF SCAN() EQL SCN_PROCEDURE
;	  1809		THEN
;	  1810		    BEGIN
;	  1811		    CLS = STE_CLS_FCN;
;	  1812		    SCAN()
;	  1813		    END
;	  1814		END
;	  1815	    ELSE
;	  1816	    IF .SCACOD EQL SCN_PROCEDURE
;	  1817	    THEN
;	  1818		BEGIN
;	  1819		CLS = STE_CLS_PRC;
;	  1820		SCAN()
;	  1821		END
;	  1822	    ELSE
;	  1823		ERROR('Type not found where required');
;	  1824	    IF .SCACOD NEQ SCN_IDENT THEN CERROR(CERM3);
;	  1825	    WHILE
;	  1826		.SCACOD EQL SCN_IDENT
;	  1827	    DO
;	  1828		BEGIN
;	  1829		STE = ADDSMB();
;	  1830		IF .STE LSS 0 THEN CERROR(CERM4);
;	  1831		IF .NUMVRS GEQ MAXVRC THEN CERROR(CERM15);
;	  1832		SYMWRK[.STE,STE_CLS] = .CLS;
;	  1833		SYMWRK[.STE,STE_TYP] = .TYP;
;	  1834		IF .CLS EQL STE_CLS_VAR
;	  1835		THEN
;	  1836		    BEGIN
;	  1837		    SYMWRK[.STE,STE_LOC] = .NUMVRS + FRM_LOC;
;	  1838		    NUMVRS = .NUMVRS + 1
;	  1839		    END;
;	  1840		IF SCAN() NEQ SCN_COMMA THEN EXITLOOP;
;	  1841		SCAN()
;	  1842		END;
;	  1843	    TRUE
;	  1844	    END;


P.AFR:	BYTE	(7)"T","y","p","e"," "		; Type
	BYTE	(7)"n","o","t"," ","f"		; not f
	BYTE	(7)"o","u","n","d"," "		; ound
	BYTE	(7)"w","h","e","r","e"		; where
	BYTE	(7)" ","r","e","q","u"		;  requ
	BYTE	(7)"i","r","e","d",000		; ired


; CPDECL
U.19:	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC1,U.95			; AC1,SCACOD
	CAIE	AC1,33				; AC1,33
	CAIN	AC1,34				; AC1,34
	JRST	L.176				; L.176
	CAIN	AC1,35				; AC1,35
	JRST	L.176				; L.176
	SETZ	AC1,				; AC1,
	JRST	L.189				; L.189
L.176:	SETZ	AC14,				; CLS,
	CAIE	AC1,33				; AC1,33
	JRST	L.177				; L.177
	MOVEI	AC14,1				; CLS,1
	PUSHJ	SP,U.3				; SP,SCAN
L.177:	MOVE	AC1,U.95			; AC1,SCACOD
	SETZ	AC2,				; AC2,
	CAIE	AC1,34				; AC1,34
	JRST	L.178				; L.178
	MOVEI	AC2,1				; AC2,1
	JRST	L.179				; L.179
L.178:	CAIE	AC1,35				; AC1,35
	JRST	L.180				; L.180
L.179:	TRNE	AC2,1				; AC2,1
	TDZA	AC12,AC12			; TYP,TYP
	MOVEI	AC12,1				; TYP,1
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,25				; AC1,25
	JRST	L.183				; L.183
	MOVEI	AC14,4				; CLS,4
	JRST	L.181				; L.181
L.180:	CAIE	AC1,25				; AC1,25
	JRST	L.182				; L.182
	MOVEI	AC14,3				; CLS,3
L.181:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.183				; L.183
L.182:	MOVEI	AC1,P.AFR			; AC1,P.AFR
	PUSHJ	SP,U.1				; SP,CERROR
L.183:	MOVEI	AC1,1				; AC1,1
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.184				; L.184
	MOVEI	AC1,U.53			; AC1,CERM3
	PUSHJ	SP,U.1				; SP,CERROR
L.184:	MOVEI	AC1,1				; AC1,1
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.188				; L.188
	PUSHJ	SP,U.4				; SP,ADDSMB
	MOVE	AC13,AC1			; STE,AC1
	JUMPGE	AC13,L.185			; STE,L.185
	MOVEI	AC1,U.54			; AC1,CERM4
	PUSHJ	SP,U.1				; SP,CERROR
L.185:	MOVEI	AC1,200				; AC1,200
	CAMLE	AC1,U.96			; AC1,NUMVRS
	JRST	L.186				; L.186
	MOVEI	AC1,U.65			; AC1,CERM15
	PUSHJ	SP,U.1				; SP,CERROR
L.186:	MOVE	AC1,AC13			; AC1,STE
	IMULI	AC1,2				; AC1,2
	DPB	AC14,C.27			; CLS,[POINT 3,SYMWRK(AC1),5]  <30,3>
	DPB	AC12,C.28			; TYP,[POINT 1,SYMWRK(AC1),6]  <29,1>
	JUMPN	AC14,L.187			; CLS,L.187
	MOVE	AC2,U.96			; AC2,NUMVRS
	ADDI	AC2,2				; AC2,2
	HRRM	AC2,U.77(AC1)			; AC2,SYMWRK(AC1)
	AOS	U.96				; NUMVRS
L.187:	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,21				; AC1,21
	JRST	L.188				; L.188
	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.184				; L.184
L.188:	SETO	AC1,				; AC1,
L.189:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,

; Routine Size:  76 words


;	  1845	
;	  1846	ROUTINE CPSTMT =			! <Statement>
;	  1847	
;	  1848	!++
;	  1849	! Functional description:
;	  1850	!	Called to process one statement.
;	  1851	!
;	  1852	! Formal parameters:
;	  1853	!	None
;	  1854	!
;	  1855	! Implicit inputs:
;	  1856	!	Source
;	  1857	!
;	  1858	! Implicit outputs:
;	  1859	!	Code, Label table
;	  1860	!
;	  1861	! Routine value:
;	  1862	!	TRUE if statement recognized, FALSE if not
;	  1863	!
;	  1864	! Side effects:
;	  1865	!	Scans from potential statement keyword (or label) to unrecognized atom
;	  1866	!
;	  1867	!--
;	  1868	
;	  1869	    BEGIN
;	  1870	    EXTERNAL REGISTER Z=0;
;	  1871	    WHILE
;	  1872		.SCACOD EQL SCN_IDENT OR .SCACOD EQL SCN_SYSNAME
;	  1873	    DO
;	  1874		BEGIN
;	  1875		LOCAL
;	  1876		    IDNLLN,		! Pointer to line with bad identifier
;	  1877		    IDNPTR,		! Pointer to bad identifier
;	  1878		    IDNCOD;		! Scan code of identifier
;	  1879		IDNLLN = .LLNPTR;
;	  1880		IDNPTR = .SCAPTR;
;	  1881		IDNCOD = .SCACOD;
;	  1882		SCAN();
;	  1883		IF .IDNCOD EQL SCN_IDENT AND .SCACOD EQL SCN_COLON
;	  1884		THEN
;	  1885		    BEGIN
;	  1886		    DEFLBL();
;	  1887		    SCAN()
;	  1888		    END
;	  1889		ELSE
;	  1890		IF .SCACOD EQL SCN_EQL
;	  1891		THEN
;	  1892		    BEGIN
;	  1893		    CPASGN(.IDNCOD);
;	  1894		    RETURN TRUE
;	  1895		    END
;	  1896		ELSE
;	  1897		    BEGIN
;	  1898		    LLNPTR = .IDNLLN;
;	  1899		    SCAPTR = .IDNPTR;
;	  1900		    CERROR(CERM5);
;	  1901		    END
;	  1902		END;
;	  1903	    SELECTONE .SCACOD OF
;	  1904		SET
;	  1905	[SCN_BEGIN]:	BEGIN
;	  1906			SCAN();
;	  1907			WHILE
;	  1908			    .SCACOD NEQ SCN_END AND CPSTMT() NEQ FALSE
;	  1909			DO
;	  1910			    BEGIN
;	  1911			    IF .SCACOD NEQ SCN_SEMI AND .SCACOD NEQ SCN_END
;	  1912			    THEN
;	  1913				CERROR(CERM6);
;	  1914			    IF .SCACOD EQL SCN_SEMI THEN SCAN()
;	  1915			    END;
;	  1916			IF .SCACOD NEQ SCN_END
;	  1917			THEN
;	  1918			    CERROR(CERM7);
;	  1919			SCAN()
;	  1920			END;
;	  1921	[SCN_LET]:	CPASGN(-1);
;	  1922	[SCN_IF]:	CPCNDI();
;	  1923	[SCN_GOTO]:	CPGOTO();
;	  1924	[SCN_RETURN]:	CPRETN();
;	  1925	[SCN_CASE]:	CPCASE();
;	  1926	[SCN_DO,
;	  1927	 SCN_WHILE,
;	  1928	 SCN_UNTIL]:	CPLOOP();
;	  1929	[SCN_SELECT]:	CPSELE(FALSE);
;	  1930	[SCN_SELECTALL]:CPSELE(TRUE);! [fun45] Multiple tags in case/select/selectall
;	  1931	[SCN_DOCOMMAND]:CPPFRM();
;	  1932	[SCN_GUIDE]:	CPGUID();
;	  1933	[SCN_PARSE]:	CPPRSE();
;	  1934	[SCN_PROMPT]:	CPPMPT();
;	  1935	[SCN_INVOKE]:	CPINVK();
;	  1936	[SCN_TYPEIN]:	CPTYIN();
;	  1937	[SCN_GETTYPEOUT]:CPCOMS(OPR_GTO,1);
;	  1938	[SCN_CLEARTYPEOUT]: (GENINS(OPR_GTO,-1,0,0); SCAN());
;	  1939	[SCN_KILLPROGRAM]:  (GENINS(OPR_KIL,0,0,0); SCAN());
;	  1940	[SCN_DISPLAY]:	CPDPLY();
;	  1941	[SCN_EXIT]:	CPEXIT();
;	  1942	[SCN_ABORT]:	CPCOMS(OPR_ABT,0);
;	  1943	[SCN_NOP]:	(GENINS(OPR_NOP,0,0,0); SCAN());
;	  1944	[SCN_CALL]:	CPCALL();
;	  1945	[SCN_END]:	RETURN FALSE;
;	  1946	[SCN_EOFILE]:	CERROR(CERM17);
;	  1947	[SCN_INTEGER,
;	  1948	 SCN_STRING,
;	  1949	 SCN_EXTERNAL]:	ERROR('Declarations not permitted after first statement');
;	  1950	[OTHERWISE]:	CERROR(CERM5)
;	  1951		TES;
;	  1952	    TRUE
;	  1953	    END;


P.AFS:	BYTE	(7)"D","e","c","l","a"		; Decla
	BYTE	(7)"r","a","t","i","o"		; ratio
	BYTE	(7)"n","s"," ","n","o"		; ns no
	BYTE	(7)"t"," ","p","e","r"		; t per
	BYTE	(7)"m","i","t","t","e"		; mitte
	BYTE	(7)"d"," ","a","f","t"		; d aft
	BYTE	(7)"e","r"," ","f","i"		; er fi
	BYTE	(7)"r","s","t"," ","s"		; rst s
	BYTE	(7)"t","a","t","e","m"		; tatem
	BYTE	(7)"e","n","t",000,000		; ent


; CPSTMT
U.20:	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
L.190:	MOVE	AC1,U.95			; AC1,SCACOD
	CAIN	AC1,1				; AC1,1
	JRST	L.191				; L.191
	CAIE	AC1,112				; AC1,112
	JRST	L.194				; L.194
L.191:	MOVE	AC14,U.89			; IDNLLN,LLNPTR
	MOVE	AC13,U.87			; IDNPTR,SCAPTR
	MOVE	AC12,AC1			; IDNCOD,AC1
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC12,1				; IDNCOD,1
	JRST	L.192				; L.192
	MOVEI	AC1,22				; AC1,22
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.192				; L.192
	PUSHJ	SP,U.6				; SP,DEFLBL
	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.190				; L.190
L.192:	MOVEI	AC1,13				; AC1,13
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.193				; L.193
	MOVE	AC1,AC12			; AC1,IDNCOD
	JRST	L.200				; L.200
L.193:	MOVEM	AC14,U.89			; IDNLLN,LLNPTR
	MOVEM	AC13,U.87			; IDNPTR,SCAPTR
	MOVEI	AC1,U.55			; AC1,CERM5
	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.190				; L.190
L.194:	MOVE	AC14,U.95			; AC14,SCACOD
	CAIE	AC14,31				; AC14,31
	JRST	L.199				; L.199
L.195:	PUSHJ	SP,U.3				; SP,SCAN
L.196:	MOVEI	AC1,32				; AC1,32
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.198				; L.198
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPE	AC1,L.198			; AC1,L.198
	MOVE	AC1,U.95			; AC1,SCACOD
	CAIE	AC1,20				; AC1,20
	CAIN	AC1,32				; AC1,32
	JRST	L.197				; L.197
	MOVEI	AC1,U.56			; AC1,CERM6
	PUSHJ	SP,U.1				; SP,CERROR
L.197:	MOVEI	AC1,20				; AC1,20
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.196				; L.196
	JRST	L.195				; L.195
L.198:	MOVEI	AC1,32				; AC1,32
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.225				; L.225
	MOVEI	AC1,U.57			; AC1,CERM7
	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.225				; L.225
L.199:	CAIE	AC14,36				; AC14,36
	JRST	L.201				; L.201
	SETO	AC1,				; AC1,
L.200:	PUSHJ	SP,U.21				; SP,CPASGN
	JRST	L.232				; L.232
L.201:	CAIE	AC14,37				; AC14,37
	JRST	L.202				; L.202
	PUSHJ	SP,U.22				; SP,CPCNDI
	JRST	L.232				; L.232
L.202:	CAIE	AC14,42				; AC14,42
	JRST	L.203				; L.203
	PUSHJ	SP,U.24				; SP,CPGOTO
	JRST	L.232				; L.232
L.203:	CAIE	AC14,43				; AC14,43
	JRST	L.204				; L.204
	PUSHJ	SP,U.43				; SP,CPRETN
	JRST	L.232				; L.232
L.204:	CAIE	AC14,44				; AC14,44
	JRST	L.205				; L.205
	PUSHJ	SP,U.25				; SP,CPCASE
	JRST	L.232				; L.232
L.205:	CAIL	AC14,52				; AC14,52
	CAILE	AC14,54				; AC14,54
	JRST	L.206				; L.206
	PUSHJ	SP,U.26				; SP,CPLOOP
	JRST	L.232				; L.232
L.206:	CAIE	AC14,55				; AC14,55
	JRST	L.207				; L.207
	SETZ	AC1,				; AC1,
	JRST	L.208				; L.208
L.207:	CAIE	AC14,133			; AC14,133
	JRST	L.209				; L.209
	SETO	AC1,				; AC1,
L.208:	PUSHJ	SP,U.27				; SP,CPSELE
	JRST	L.232				; L.232
L.209:	CAIE	AC14,56				; AC14,56
	JRST	L.210				; L.210
	PUSHJ	SP,U.29				; SP,CPPFRM
	JRST	L.232				; L.232
L.210:	CAIE	AC14,60				; AC14,60
	JRST	L.211				; L.211
	PUSHJ	SP,U.30				; SP,CPGUID
	JRST	L.232				; L.232
L.211:	CAIE	AC14,61				; AC14,61
	JRST	L.212				; L.212
	PUSHJ	SP,U.33				; SP,CPPRSE
	JRST	L.232				; L.232
L.212:	CAIE	AC14,110			; AC14,110
	JRST	L.213				; L.213
	PUSHJ	SP,U.31				; SP,CPPMPT
	JRST	L.232				; L.232
L.213:	CAIE	AC14,113			; AC14,113
	JRST	L.214				; L.214
	PUSHJ	SP,U.32				; SP,CPINVK
	JRST	L.232				; L.232
L.214:	CAIE	AC14,115			; AC14,115
	JRST	L.215				; L.215
	PUSHJ	SP,U.38				; SP,CPTYIN
	JRST	L.232				; L.232
L.215:	CAIE	AC14,117			; AC14,117
	JRST	L.216				; L.216
	MOVEI	AC1,37				; AC1,37
	MOVEI	AC2,1				; AC2,1
	JRST	L.221				; L.221
L.216:	CAIE	AC14,120			; AC14,120
	JRST	L.217				; L.217
	MOVEI	AC1,37				; AC1,37
	SETO	AC2,				; AC2,
	JRST	L.224				; L.224
L.217:	CAIE	AC14,121			; AC14,121
	JRST	L.218				; L.218
	MOVEI	AC1,40				; AC1,40
	JRST	L.223				; L.223
L.218:	CAIE	AC14,122			; AC14,122
	JRST	L.219				; L.219
	PUSHJ	SP,U.39				; SP,CPDPLY
	JRST	L.232				; L.232
L.219:	CAIE	AC14,124			; AC14,124
	JRST	L.220				; L.220
	PUSHJ	SP,U.40				; SP,CPEXIT
	JRST	L.232				; L.232
L.220:	CAIE	AC14,127			; AC14,127
	JRST	L.222				; L.222
	MOVEI	AC1,45				; AC1,45
	SETZ	AC2,				; AC2,
L.221:	PUSHJ	SP,U.28				; SP,CPCOMS
	JRST	L.232				; L.232
L.222:	CAIE	AC14,130			; AC14,130
	JRST	L.226				; L.226
	MOVEI	AC1,46				; AC1,46
L.223:	SETZ	AC2,				; AC2,
L.224:	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
L.225:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.232				; L.232
L.226:	CAIE	AC14,131			; AC14,131
	JRST	L.227				; L.227
	PUSHJ	SP,U.41				; SP,CPCALL
	JRST	L.232				; L.232
L.227:	CAIE	AC14,32				; AC14,32
	JRST	L.228				; L.228
	SETZ	AC1,				; AC1,
	JRST	L.233				; L.233
L.228:	CAIE	AC14,134			; AC14,134
	JRST	L.229				; L.229
	MOVEI	AC1,U.67			; AC1,CERM17
	JRST	L.231				; L.231
L.229:	CAIL	AC14,33				; AC14,33
	CAILE	AC14,35				; AC14,35
	JRST	L.230				; L.230
	MOVEI	AC1,P.AFS			; AC1,P.AFS
	JRST	L.231				; L.231
L.230:	MOVEI	AC1,U.55			; AC1,CERM5
L.231:	PUSHJ	SP,U.1				; SP,CERROR
L.232:	SETO	AC1,				; AC1,
L.233:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,

; Routine Size:  174 words


;	  1954	
;	  1955	ROUTINE CPASGN(SCN): NOVALUE =	! <Assignment-statement>
;	  1956	
;	  1957	!++
;	  1958	! Functional description:
;	  1959	!	Called from <Statement> to process an assignment statement.
;	  1960	!
;	  1961	! Formal parameters:
;	  1962	!	Scan code of destination if already scanned and ready in SCATOM,
;	  1963	!	    -1 if it is yet to be scanned.  If the scan code is provided,
;	  1964	!	    then the equals sign is the current atom.
;	  1965	!
;	  1966	! Implicit inputs:
;	  1967	!	Source, symbol table
;	  1968	!
;	  1969	! Implicit outputs:
;	  1970	!	Code
;	  1971	!
;	  1972	! Routine value:
;	  1973	!	None
;	  1974	!
;	  1975	! Side effects:
;	  1976	!	Scans from LET or destination identifier to unrecognized atom
;	  1977	!
;	  1978	!--
;	  1979	
;	  1980	    BEGIN
;	  1981	    EXTERNAL REGISTER Z=0;
;	  1982	    LOCAL
;	  1983		DSTN,			! Destination designator
;	  1984		TYPE;			! Data type
;	  1985	    IF .SCN LSS 0 THEN SCAN() ELSE SCACOD = .SCN;
;	  1986	    IF .SCACOD EQL SCN_IDENT
;	  1987	    THEN
;	  1988		BEGIN
;	  1989		DSTN = FNDSMB(-1,-1);
;	  1990		IF .DSTN LSS 0 THEN ERROR('Undefined variable');
;	  1991		IF .SYMWRK[.DSTN,STE_CLS] EQL STE_CLS_PRC
;	  1992		    OR .SYMWRK[.DSTN,STE_CLS] EQL STE_CLS_FCN
;	  1993		THEN
;	  1994		    ERROR('Cannot store into a procedure');
;	  1995		TYPE = .SYMWRK[.DSTN,STE_TYP]
;	  1996		END
;	  1997	    ELSE
;	  1998	    IF .SCACOD EQL SCN_SYSNAME
;	  1999	    THEN
;	  2000		BEGIN
;	  2001		MAP DSTN: OPRAND;
;	  2002		IF .PSDEFN[.SCATOM,SYN_CLS] NEQ SYN_CLS_VAR
;	  2003		THEN
;	  2004		    ERROR('Cannot store into routine');
;	  2005		IF NOT .PSDEFN[.SCATOM,SYN_WRT] THEN ERROR('Variable is readonly');
;	  2006		DSTN[OPN_ADR] = .SCATOM;
;	  2007		DSTN[OPN_CLS] = OPN_CLS_SYN;
;	  2008		TYPE = .PSDEFN[.SCATOM,SYN_TYP]
;	  2009		END
;	  2010	    ELSE
;	  2011		CERROR(CERM8);
;	  2012	    IF .SCN LSS 0 THEN IF SCAN() NEQ SCN_EQL THEN ERROR('Equal sign missing');
;	  2013	    SCAN();
;	  2014	    CASE .TYPE FROM STE_TYP_INT TO STE_TYP_STR OF
;	  2015		SET
;	  2016	[STE_TYP_INT]:	CPIEXP(.DSTN);
;	  2017	[STE_TYP_STR]:	CPSEXP(.DSTN);
;	  2018		TES
;	  2019	    END;


P.AFT:	BYTE	(7)"U","n","d","e","f"		; Undef
	BYTE	(7)"i","n","e","d"," "		; ined
	BYTE	(7)"v","a","r","i","a"		; varia
	BYTE	(7)"b","l","e",000,000		; ble
P.AFU:	BYTE	(7)"C","a","n","n","o"		; Canno
	BYTE	(7)"t"," ","s","t","o"		; t sto
	BYTE	(7)"r","e"," ","i","n"		; re in
	BYTE	(7)"t","o"," ","a"," "		; to a
	BYTE	(7)"p","r","o","c","e"		; proce
	BYTE	(7)"d","u","r","e",000		; dure
P.AFV:	BYTE	(7)"C","a","n","n","o"		; Canno
	BYTE	(7)"t"," ","s","t","o"		; t sto
	BYTE	(7)"r","e"," ","i","n"		; re in
	BYTE	(7)"t","o"," ","r","o"		; to ro
	BYTE	(7)"u","t","i","n","e"		; utine
	BYTE	(7)000,000,000,000,000
P.AFW:	BYTE	(7)"V","a","r","i","a"		; Varia
	BYTE	(7)"b","l","e"," ","i"		; ble i
	BYTE	(7)"s"," ","r","e","a"		; s rea
	BYTE	(7)"d","o","n","l","y"		; donly
	BYTE	(7)000,000,000,000,000
P.AFX:	BYTE	(7)"E","q","u","a","l"		; Equal
	BYTE	(7)" ","s","i","g","n"		;  sign
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g",000,000		; ing


; CPASGN
U.21:	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	SETZ	AC12,				; AC12,
	JUMPGE	AC1,L.234			; SCN,L.234
	MOVEI	AC12,1				; AC12,1
	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.235				; L.235
L.234:	MOVEM	AC1,U.95			; SCN,SCACOD
L.235:	MOVE	AC1,U.95			; AC1,SCACOD
	CAIE	AC1,1				; AC1,1
	JRST	L.239				; L.239
	SETOB	AC1,AC2				; AC1,AC2
	PUSHJ	SP,U.5				; SP,FNDSMB
	MOVE	AC13,AC1			; DSTN,AC1
	JUMPGE	AC13,L.236			; DSTN,L.236
	MOVEI	AC1,P.AFT			; AC1,P.AFT
	PUSHJ	SP,U.1				; SP,CERROR
L.236:	MOVE	AC14,AC13			; AC14,DSTN
	IMULI	AC14,2				; AC14,2
	LDB	AC1,C.29			; AC1,[POINT 3,SYMWRK(AC14),5]  <30,3>
	CAIN	AC1,3				; AC1,3
	JRST	L.237				; L.237
	CAIE	AC1,4				; AC1,4
	JRST	L.238				; L.238
L.237:	MOVEI	AC1,P.AFU			; AC1,P.AFU
	PUSHJ	SP,U.1				; SP,CERROR
L.238:	LDB	AC14,C.30			; TYPE,[POINT 1,SYMWRK(AC14),6]  <29,1>
	JRST	L.243				; L.243
L.239:	CAIE	AC1,112				; AC1,112
	JRST	L.242				; L.242
	MOVE	AC1,U.92			; AC1,SCATOM
	IMULI	AC1,2				; AC1,2
	LDB	AC2,C.31			; AC2,[POINT 3,PSDEFN(AC1),17]  <18,3>
	CAIN	AC2,2				; AC2,2
	JRST	L.240				; L.240
	MOVEI	AC1,P.AFV			; AC1,P.AFV
	PUSHJ	SP,U.1				; SP,CERROR
L.240:	MOVE	AC1,U.92			; AC1,SCATOM
	IMULI	AC1,2				; AC1,2
	MOVSI	AC2,200000			; AC2,200000
	TDNE	AC2,PSDEFN(AC1)			; AC2,PSDEFN(AC1)
	JRST	L.241				; L.241
	MOVEI	AC1,P.AFW			; AC1,P.AFW
	PUSHJ	SP,U.1				; SP,CERROR
L.241:	MOVE	AC1,U.92			; AC1,SCATOM
	DPB	AC1,C.32			; AC1,[POINT 15,DSTN,35]  <0,15>
	TRZ	AC13,-200000			; DSTN,-200000
	TRO	AC13,200000			; DSTN,200000
	MOVE	AC1,U.92			; AC1,SCATOM
	IMULI	AC1,2				; AC1,2
	LDB	AC14,C.33			; TYPE,[POINT 3,PSDEFN(AC1),14]  <21,3>
	JRST	L.243				; L.243
L.242:	MOVEI	AC1,U.58			; AC1,CERM8
	PUSHJ	SP,U.1				; SP,CERROR
L.243:	TRNN	AC12,1				; AC12,1
	JRST	L.244				; L.244
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,13				; AC1,13
	JRST	L.244				; L.244
	MOVEI	AC1,P.AFX			; AC1,P.AFX
	PUSHJ	SP,U.1				; SP,CERROR
L.244:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.245(AC14)			; L.245(TYPE)
L.245:	JRST	L.246				; L.246
	JRST	L.247				; L.247
L.246:	MOVE	AC1,AC13			; AC1,DSTN
	PUSHJ	SP,U.44				; SP,CPIEXP
	JRST	L.248				; L.248
L.247:	MOVE	AC1,AC13			; AC1,DSTN
	PUSHJ	SP,U.45				; SP,CPSEXP
L.248:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,
C.29:	POINT	3,U.77(AC14),5			; 3,SYMWRK(AC14),5
C.30:	POINT	1,U.77(AC14),6			; 1,SYMWRK(AC14),6
C.31:	POINT	3,PSDEFN(AC1),17		; 3,PSDEFN(AC1),17
C.32:	POINT	15,AC13,35			; 15,DSTN,35
C.33:	POINT	3,PSDEFN(AC1),14		; 3,PSDEFN(AC1),14

; Routine Size:  80 words


;	  2020	
;	  2021	ROUTINE CPCNDI: NOVALUE =		! <Conditional-statement>
;	  2022	
;	  2023	!++
;	  2024	! Functional description:
;	  2025	!	Called from <Statement> to process a conditional statement.
;	  2026	!
;	  2027	! Formal parameters:
;	  2028	!	None
;	  2029	!
;	  2030	! Implicit inputs:
;	  2031	!	Source
;	  2032	!
;	  2033	! Implicit outputs:
;	  2034	!	Code
;	  2035	!
;	  2036	! Routine value:
;	  2037	!	None
;	  2038	!
;	  2039	! Side effects:
;	  2040	!	Scans from IF to unrecognized atom
;	  2041	!
;	  2042	!--
;	  2043	
;	  2044	    BEGIN
;	  2045	    EXTERNAL REGISTER Z=0;
;	  2046	    LOCAL
;	  2047		CNDADR,		! Location of Compare instruction
;	  2048		JMPADR;		! Location if Jump instruction before Else
;	  2049	    SCAN();
;	  2050	    CNDADR = CPIFST();	! Emit Compare and true-statement
;	  2051	    IF .SCACOD EQL SCN_ELSE
;	  2052	    THEN
;	  2053		BEGIN
;	  2054		JMPADR = .NEXTIN;
;	  2055		GENINS(OPR_JMP,0,0,0);
;	  2056		CODWRK[.CNDADR,COD_OPA] = .NEXTIN;
;	  2057		SCAN();
;	  2058		IF CPSTMT() EQL FALSE THEN CERROR(CERM9);
;	  2059		CODWRK[.JMPADR,COD_OPA] = .NEXTIN
;	  2060		END
;	  2061	    END;


; CPCNDI
U.22:	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.23				; SP,CPIFST
	MOVE	AC14,AC1			; CNDADR,AC1
	MOVEI	AC1,41				; AC1,41
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.250				; L.250
	MOVE	AC13,U.86			; JMPADR,NEXTIN
	MOVEI	AC1,32				; AC1,32
	SETZB	AC2,AC3				; AC2,AC3
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC14)			; AC1,CODWRK(CNDADR)
	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPN	AC1,L.249			; AC1,L.249
	MOVEI	AC1,U.59			; AC1,CERM9
	PUSHJ	SP,U.1				; SP,CERROR
L.249:	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC13)			; AC1,CODWRK(JMPADR)
L.250:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  25 words


;	  2062	
;	  2063	ROUTINE CPIFST =		! <If-statement>
;	  2064	
;	  2065	!++
;	  2066	!  Functional description:
;	  2067	!	Called from <Conditional-statement> to compile a simple IF
;	  2068	!	statement, generating the appropriate Compare instruction
;	  2069	!	and the true-statement, with the Compare branch address
;	  2070	!	adjusted after the true-statement.
;	  2071	!
;	  2072	! Formal parameters:
;	  2073	!	None
;	  2074	!
;	  2075	! Implicit inputs:
;	  2076	!	Source
;	  2077	!
;	  2078	! Implicit outputs:
;	  2079	!	Code
;	  2080	!
;	  2081	! Routine value:
;	  2082	!	Code index of Compare instruction
;	  2083	!
;	  2084	! Side effects:
;	  2085	!	Scans from first atom of logical expression past last atom
;	  2086	!	of true-expression
;	  2087	!
;	  2088	!--
;	  2089	
;	  2090	    BEGIN
;	  2091	    EXTERNAL REGISTER Z=0;
;	  2092	    LOCAL
;	  2093		IFADDR;			! Location of Compare instruction
;	  2094	    IFADDR = CPLEXP();
;	  2095	    IF .SCACOD NEQ SCN_THEN THEN ERROR('THEN missing');
;	  2096	    SCAN();
;	  2097	    IF CPSTMT() EQL FALSE THEN CERROR(CERM9);
;	  2098	    CODWRK[.IFADDR,COD_OPA] = .NEXTIN;
;	  2099	    .IFADDR
;	  2100	    END;


P.AFY:	BYTE	(7)"T","H","E","N"," "		; THEN
	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g",000,000,000		; ng


; CPIFST
U.23:	PUSH	SP,AC14				; SP,AC14
	PUSHJ	SP,U.46				; SP,CPLEXP
	MOVE	AC14,AC1			; IFADDR,AC1
	MOVEI	AC1,40				; AC1,40
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.251				; L.251
	MOVEI	AC1,P.AFY			; AC1,P.AFY
	PUSHJ	SP,U.1				; SP,CERROR
L.251:	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPN	AC1,L.252			; AC1,L.252
	MOVEI	AC1,U.59			; AC1,CERM9
	PUSHJ	SP,U.1				; SP,CERROR
L.252:	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC14)			; AC1,CODWRK(IFADDR)
	MOVE	AC1,AC14			; AC1,IFADDR
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  18 words


;	  2101	
;	  2102	ROUTINE CPGOTO: NOVALUE =	! <Goto-statement>
;	  2103	
;	  2104	!++
;	  2105	! Functional description:
;	  2106	!	Called from <Statement> to process a Goto statement.
;	  2107	!	Generates a Jump to the labelled location; if the label is not yet
;	  2108	!	defined, the Jump address is placed in the labels table.
;	  2109	!
;	  2110	! Formal parameters:
;	  2111	!	None
;	  2112	!
;	  2113	! Implicit inputs:
;	  2114	!	Code, label table
;	  2115	!
;	  2116	! Implicit outputs:
;	  2117	!	Code, label table
;	  2118	!
;	  2119	! Routine value:
;	  2120	!	None
;	  2121	!
;	  2122	! Side effects:
;	  2123	!	Scans from GOTO to unrecognized atom
;	  2124	!
;	  2125	!--
;	  2126	
;	  2127	    BEGIN
;	  2128	    EXTERNAL REGISTER Z=0;
;	  2129	    LOCAL PTR;
;	  2130	    IF SCAN() NEQ SCN_IDENT THEN CERROR(CERM3);
;	  2131	    PTR =
;	  2132		(DECR I FROM .LBLCNT-1 DO
;	  2133		    IF CH$EQL(.SCALEN+1, BYTPTR(SCATOM), .SCALEN+1, .LBLNAM[.I])
;	  2134		    THEN
;	  2135			EXITLOOP .I);
;	  2136	    IF .PTR LSS 0
;	  2137	    THEN
;	  2138		BEGIN
;	  2139		IF .LBLCNT GEQ MAXLBL THEN CERROR(CERM10);
;	  2140		LBLNAM[.LBLCNT] = BYTPTR(PCMGMM((.SCALEN+5)/5, DICT));
;	  2141		CH$MOVE(.SCALEN+1, BYTPTR(SCATOM), .LBLNAM[.LBLCNT]);
;	  2142		LBLADR[.LBLCNT] = -.NEXTIN;
;	  2143		LBLCNT = .LBLCNT + 1;
;	  2144		PTR = 0
;	  2145		END
;	  2146	    ELSE
;	  2147	    IF .LBLADR[.PTR] LSS 0
;	  2148	    THEN
;	  2149		BEGIN
;	  2150		LOCAL
;	  2151		    EPTR;
;	  2152		EPTR = - .LBLADR[.PTR];
;	  2153		LBLADR[.PTR] = - .NEXTIN;
;	  2154		PTR = .EPTR
;	  2155		END
;	  2156	    ELSE
;	  2157		PTR = .LBLADR[.PTR];
;	  2158	    GENINS(OPR_JMP,.PTR,0,0);
;	  2159	    SCAN()
;	  2160	    END;


; CPGOTO
U.24:	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,1				; AC1,1
	JRST	L.253				; L.253
	MOVEI	AC1,U.53			; AC1,CERM3
	PUSHJ	SP,U.1				; SP,CERROR
L.253:	MOVE	AC13,U.101			; AC13,LBLCNT
	MOVE	AC3,U.93			; AC3,SCALEN
	ADDI	AC3,1				; AC3,1
	MOVE	AC14,AC13			; I,AC13
	JRST	L.255				; L.255
L.254:	MOVE	AC2,C.3				; HLF,[SCATOM]
	HRLI	AC2,-337100			; HLF,-337100
	MOVE	AC1,AC3				; AC1,AC3
	MOVE	AC4,AC3				; AC4,AC3
	MOVE	AC5,U.99(AC14)			; AC5,LBLNAM(I)
	EXTEND	AC1,C.5				; AC1,[CMPSE ]
	JRST	L.255				; L.255
	JRST	L.256				; L.256
L.255:	SOJGE	AC14,L.254			; I,L.254
	SETO	AC14,				; PTR,
L.256:	JUMPGE	AC14,L.258			; PTR,L.258
	CAIGE	AC13,24				; AC13,24
	JRST	L.257				; L.257
	MOVEI	AC1,U.60			; AC1,CERM10
	PUSHJ	SP,U.1				; SP,CERROR
L.257:	MOVE	AC13,U.101			; AC13,LBLCNT
	MOVE	AC1,U.93			; AC1,SCALEN
	ADDI	AC1,5				; AC1,5
	IDIVI	AC1,5				; AC1,5
	MOVEI	AC2,DICT			; AC2,DICT
	PUSHJ	SP,PCMGMM			; SP,PCMGMM
	HRLI	AC1,-337100			; HLF,-337100
	MOVEM	AC1,U.99(AC13)			; HLF,LBLNAM(AC13)
	MOVE	AC1,U.93			; AC1,SCALEN
	ADDI	AC1,1				; AC1,1
	MOVE	AC2,C.3				; HLF,[SCATOM]
	HRLI	AC2,-337100			; HLF,-337100
	MOVE	AC3,U.101			; AC3,LBLCNT
	MOVE	AC4,AC1				; AC4,AC1
	MOVE	AC5,U.99(AC3)			; AC5,LBLNAM(AC3)
	EXTEND	AC1,C.12			; AC1,[MOVSLJ ]
	JFCL					; 
	MOVE	AC1,U.86			; AC1,NEXTIN
	MOVNM	AC1,U.100(AC3)			; AC1,LBLADR(AC3)
	AOS	U.101				; LBLCNT
	SETZ	AC14,				; PTR,
	JRST	L.260				; L.260
L.258:	MOVE	AC1,U.100(AC14)			; AC1,LBLADR(PTR)
	JUMPGE	AC1,L.259			; AC1,L.259
	MOVN	AC1,AC1				; EPTR,AC1
	MOVE	AC2,U.86			; AC2,NEXTIN
	MOVNM	AC2,U.100(AC14)			; AC2,LBLADR(PTR)
L.259:	MOVE	AC14,AC1			; PTR,AC1
L.260:	MOVEI	AC1,32				; AC1,32
	MOVE	AC2,AC14			; AC2,PTR
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	PUSHJ	SP,U.3				; SP,SCAN
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  63 words


;	  2161	
;	  2162	ROUTINE CPCASE: NOVALUE =	! <Case-statement>
;	  2163	
;	  2164	!++
;	  2165	! Functional description:
;	  2166	!	Called from <Statement> to compile a Case statement.
;	  2167	!
;	  2168	! Formal parameters:
;	  2169	!	None
;	  2170	!
;	  2171	! Implicit inputs:
;	  2172	!	Source atoms
;	  2173	!
;	  2174	! Implicit outputs:
;	  2175	!	Code, constants
;	  2176	!
;	  2177	! Routine value:
;	  2178	!	None
;	  2179	!
;	  2180	! Side effects:
;	  2181	!	Scans from CASE to unrecognized atom
;	  2182	!
;	  2183	!--
;	  2184	
;	  2185	    BEGIN
;	  2186	    EXTERNAL REGISTER Z=0;
;	  2187	    LOCAL
;	  2188		OPN,			! Operand descriptor
;	  2189		IDX,			! Case index
;	  2190		LOC,			! Location of CAS-JMP sequence
;	  2191		LEN,			! Length of dispatch table
;	  2192		TBL,			! Constant index of dispatch table
;	  2193		BIAS,			! User's index to first word
;	  2194		BRKHAK,			! Hack flag to handle omission of ['s
;	  2195	                                ! [fun45]: multiple tags in case
;	  2196	        fro;                    ! Lower index in [...fro TO upto]
;	  2197	    SCAN();
;	  2198	    OPN = CPIEXP(OPN_TMP_INT);
;	  2199	    IF .OPN LSS 0 THEN ERROR('Index missing');
;	  2200	    IF .SCACOD NEQ SCN_FROM THEN ERROR('FROM missing');
;	  2201	    IF SCAN() NEQ SCN_NUMB THEN ERROR('Starting index missing');
;	  2202	    BIAS = .SCANUM;
;	  2203	    IF SCAN() NEQ SCN_TO THEN ERROR('TO missing');
;	  2204	    IF SCAN() NEQ SCN_NUMB THEN ERROR('Ending index missing');
;	  2205	    LEN = .SCANUM-.BIAS+1;
;	  2206	    IF .LEN LEQ 0 THEN ERROR('Invalid range');
;	  2207	    TBL = .CONSTP + 1;
;	  2208	    CONSTP = .CONSTP + .LEN + 2;
;	  2209	    IF .CONSTP GEQ CNSWKL THEN CERROR(CERM1);
;	  2210	    CNSWRK[.TBL] = .LEN;	! Table[0] = length of jump vector
;	  2211	    CNSWRK[.TBL-1] = -1;	! No OUTRANGE jump address yet
;	  2212	    DECR I FROM .LEN DO CNSWRK[.TBL+.I+1] = -1;
;	  2213	    LOC = GENINS(OPR_CAS,.OPN,.TBL,GETCNS(.BIAS,STE_TYP_INT));
;	  2214	    GENINS(OPR_JMP,0,0,0);
;	  2215	    IF SCAN() NEQ SCN_OF THEN CERROR(CERM20);
;	  2216	    IF SCAN() NEQ SCN_BEGIN THEN CERROR(CERM21);
;	  2217	
;	  2218	    DO
;	  2219		BEGIN
;	  2220		IF SCAN() EQL SCN_END THEN EXITLOOP;
;	  2221		BRKHAK = 0;		! Assume no square brackets around labels
;	  2222		IF .SCACOD EQL SCN_LBRKT
;	  2223		THEN
;	  2224		    BEGIN
;	  2225		    BRKHAK = -1;	! We do have square brackets on this one
;	  2226		    SCAN()		! Read next token (skip over bracket)
;	  2227		    END;
;	  2228	                                ! [fun45]+ Multiple tags in case
;	  2229	        while true do begin     ! loop on all tags within one case
;	  2230	                                ! !!! the parse lets [] parse ok !!!
;	  2231	                                ! Each alternative below must exit with scan()
;	  2232	                                ! [...N1  or [...N1 TO N2
;	  2233	           if .scacod eql scn_numb then
;	  2234	                                !    [...n1 TO n2
;	  2235	              if scan() eql scn_to then begin
;	  2236	                 if .scanum lss .bias or .scanum geq .bias+.len then
;	  2237	                    error ('Index out of range');
;	  2238	                 fro = .scanum;
;	  2239	                 if scan() neq scn_numb then 
;	  2240	                    error ('missing number after to');
;	  2241	                 if .scanum lss .bias or .scanum geq .bias+.len then
;	  2242	                    error ('Index out of range');
;	  2243	                 incr i from .fro to .scanum by 1 do
;	  2244	                    cnswrk[.tbl+1+.i-.bias] = .nextin;
;	  2245	                 scan();
;	  2246	                 end
;	  2247	                                ! [...n1
;	  2248	              else begin
;	  2249	                 if .scanum lss .bias or .scanum geq .bias+.len then
;	  2250	                     error('Index out of range');
;	  2251	                 cnswrk[.tbl+1+.scanum-.bias] = .nextin;
;	  2252	                 end
;	  2253	                                ! [...INRANGE
;	  2254	           else if .scacod eql scn_inrange then begin
;	  2255	              decr i from .len do
;	  2256	                 if .cnswrk[.tbl+1+.i] eql -1 then cnswrk[.tbl+1+.i] = .nextin;
;	  2257	              scan();
;	  2258	              end
;	  2259	           else if .scacod eql scn_outrange then begin
;	  2260	              cnswrk[.tbl-1] = .nextin;
;	  2261	              scan();
;	  2262	              end
;	  2263	           else
;	  2264	              error ('Number or INRANGE/OUTRANGE missing in CASE');
;	  2265	                                ! [..., or [...] ?
;	  2266	                                ! Find next item n1, or n1] or n1:
;	  2267	           if .scacod neq scn_comma then
;	  2268	              exitloop;
;	  2269	
;	  2270	           scan();              ! Next item needed for this loop
;	  2271	           end;                 ! Loop on all tags within one case
;	  2272	
;	  2273	                                ! Check final ] if needed
;	  2274	        if .scacod eql scn_rbrkt then begin
;	  2275	           if .brkhak eql 0 then
;	  2276	              error ('Extraneous ] in Case');
;	  2277	           scan();              ! grab next token
;	  2278	           end
;	  2279	        else if .brkhak neq 0 then
;	  2280	           error ('Missing ] in Case');
;	  2281	
;	  2282	
;	  2283		IF .SCACOD NEQ SCN_COLON THEN CERROR(CERM11);
;	  2284	                                ! [fun45]- Multiple tags in case
;	  2285		SCAN();
;	  2286		IF CPSTMT() EQL FALSE THEN CERROR(CERM12);
;	  2287		GENINS(OPR_JMP,.LOC+2,0,0)
;	  2288		END
;	  2289	    UNTIL
;	  2290		.SCACOD NEQ SCN_SEMI;
;	  2291	    IF .SCACOD NEQ SCN_END THEN CERROR(CERM7);
;	  2292	    SCAN();
;	  2293	    CODWRK[.LOC+2,COD_OPA] = .NEXTIN
;	  2294	    END;


P.AFZ:	BYTE	(7)"I","n","d","e","x"		; Index
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g",000,000		; ing
P.AGA:	BYTE	(7)"F","R","O","M"," "		; FROM
	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g",000,000,000		; ng
P.AGB:	BYTE	(7)"S","t","a","r","t"		; Start
	BYTE	(7)"i","n","g"," ","i"		; ing i
	BYTE	(7)"n","d","e","x"," "		; ndex
	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g",000,000,000		; ng
P.AGC:	BYTE	(7)"T","O"," ","m","i"		; TO mi
	BYTE	(7)"s","s","i","n","g"		; ssing
	BYTE	(7)000,000,000,000,000
P.AGD:	BYTE	(7)"E","n","d","i","n"		; Endin
	BYTE	(7)"g"," ","i","n","d"		; g ind
	BYTE	(7)"e","x"," ","m","i"		; ex mi
	BYTE	(7)"s","s","i","n","g"		; ssing
	BYTE	(7)000,000,000,000,000
P.AGE:	BYTE	(7)"I","n","v","a","l"		; Inval
	BYTE	(7)"i","d"," ","r","a"		; id ra
	BYTE	(7)"n","g","e",000,000		; nge
P.AGF:	BYTE	(7)"I","n","d","e","x"		; Index
	BYTE	(7)" ","o","u","t"," "		;  out
	BYTE	(7)"o","f"," ","r","a"		; of ra
	BYTE	(7)"n","g","e",000,000		; nge
P.AGG:	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g"," ","n","u"		; ng nu
	BYTE	(7)"m","b","e","r"," "		; mber
	BYTE	(7)"a","f","t","e","r"		; after
	BYTE	(7)" ","t","o",000,000		;  to
P.AGH:	BYTE	(7)"I","n","d","e","x"		; Index
	BYTE	(7)" ","o","u","t"," "		;  out
	BYTE	(7)"o","f"," ","r","a"		; of ra
	BYTE	(7)"n","g","e",000,000		; nge
P.AGI:	BYTE	(7)"I","n","d","e","x"		; Index
	BYTE	(7)" ","o","u","t"," "		;  out
	BYTE	(7)"o","f"," ","r","a"		; of ra
	BYTE	(7)"n","g","e",000,000		; nge
P.AGJ:	BYTE	(7)"N","u","m","b","e"		; Numbe
	BYTE	(7)"r"," ","o","r"," "		; r or
	BYTE	(7)"I","N","R","A","N"		; INRAN
	BYTE	(7)"G","E","/","O","U"		; GE/OU
	BYTE	(7)"T","R","A","N","G"		; TRANG
	BYTE	(7)"E"," ","m","i","s"		; E mis
	BYTE	(7)"s","i","n","g"," "		; sing
	BYTE	(7)"i","n"," ","C","A"		; in CA
	BYTE	(7)"S","E",000,000,000		; SE
P.AGK:	BYTE	(7)"E","x","t","r","a"		; Extra
	BYTE	(7)"n","e","o","u","s"		; neous
	BYTE	(7)" ","]"," ","i","n"		;  ] in
	BYTE	(7)" ","C","a","s","e"		;  Case
	BYTE	(7)000,000,000,000,000
P.AGL:	BYTE	(7)"M","i","s","s","i"		; Missi
	BYTE	(7)"n","g"," ","]"," "		; ng ]
	BYTE	(7)"i","n"," ","C","a"		; in Ca
	BYTE	(7)"s","e",000,000,000		; se


; CPCASE
U.25:	PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,2				; SP,2
	PUSHJ	SP,U.3				; SP,SCAN
	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	MOVE	AC12,AC1			; OPN,AC1
	JUMPGE	AC12,L.261			; OPN,L.261
	MOVEI	AC1,P.AFZ			; AC1,P.AFZ
	PUSHJ	SP,U.1				; SP,CERROR
L.261:	MOVEI	AC1,45				; AC1,45
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.262				; L.262
	MOVEI	AC1,P.AGA			; AC1,P.AGA
	PUSHJ	SP,U.1				; SP,CERROR
L.262:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,2				; AC1,2
	JRST	L.263				; L.263
	MOVEI	AC1,P.AGB			; AC1,P.AGB
	PUSHJ	SP,U.1				; SP,CERROR
L.263:	MOVE	AC11,U.94			; BIAS,SCANUM
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,46				; AC1,46
	JRST	L.264				; L.264
	MOVEI	AC1,P.AGC			; AC1,P.AGC
	PUSHJ	SP,U.1				; SP,CERROR
L.264:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,2				; AC1,2
	JRST	L.265				; L.265
	MOVEI	AC1,P.AGD			; AC1,P.AGD
	PUSHJ	SP,U.1				; SP,CERROR
L.265:	MOVE	AC1,U.94			; AC1,SCANUM
	SUB	AC1,AC11			; AC1,BIAS
	MOVE	AC10,AC1			; LEN,AC1
	AOJG	AC10,L.266			; LEN,L.266
	MOVEI	AC1,P.AGE			; AC1,P.AGE
	PUSHJ	SP,U.1				; SP,CERROR
L.266:	MOVE	AC14,U.97			; TBL,CONSTP
	ADDI	AC14,1				; TBL,1
	MOVE	AC1,U.97			; AC1,CONSTP
	ADD	AC1,AC10			; AC1,LEN
	ADDI	AC1,2				; AC1,2
	MOVEM	AC1,U.97			; AC1,CONSTP
	MOVEI	AC1,6000			; AC1,6000
	CAMLE	AC1,U.97			; AC1,CONSTP
	JRST	L.267				; L.267
	MOVEI	AC1,U.51			; AC1,CERM1
	PUSHJ	SP,U.1				; SP,CERROR
L.267:	MOVEM	AC10,U.78(AC14)			; LEN,CNSWRK(TBL)
	SETOM	U.78-1(AC14)			; CNSWRK-1(TBL)
	MOVE	AC1,AC10			; I,LEN
	AOJA	AC1,L.269			; I,L.269
L.268:	MOVE	AC3,AC14			; AC3,TBL
	ADD	AC3,AC1				; AC3,I
	SETOM	U.78+1(AC3)			; CNSWRK+1(AC3)
L.269:	SOJGE	AC1,L.268			; I,L.268
	MOVE	AC1,AC11			; AC1,BIAS
	SETZ	AC2,				; AC2,
	PUSHJ	SP,U.8				; SP,GETCNS
	MOVE	AC4,AC1				; AC4,AC1
	MOVEI	AC1,24				; AC1,24
	MOVE	AC2,AC12			; AC2,OPN
	MOVE	AC3,AC14			; AC3,TBL
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC12,AC1			; LOC,AC1
	MOVEI	AC1,32				; AC1,32
	SETZB	AC2,AC3				; AC2,AC3
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,47				; AC1,47
	JRST	L.270				; L.270
	MOVEI	AC1,U.70			; AC1,CERM20
	PUSHJ	SP,U.1				; SP,CERROR
L.270:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,31				; AC1,31
	JRST	L.271				; L.271
	MOVEI	AC1,U.71			; AC1,CERM21
	PUSHJ	SP,U.1				; SP,CERROR
L.271:	ADDI	AC12,2				; LOC,2
L.272:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,32				; AC1,32
	JRST	L.298				; L.298
	SETZM	0(SP)				; BRKHAK
	MOVEI	AC1,23				; AC1,23
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.273				; L.273
	SETOM	0(SP)				; BRKHAK
	JRST	L.291				; L.291
L.273:	MOVE	AC13,U.95			; AC13,SCACOD
	CAIE	AC13,2				; AC13,2
	JRST	L.284				; L.284
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,46				; AC1,46
	JRST	L.281				; L.281
	CAMLE	AC11,U.94			; BIAS,SCANUM
	JRST	L.274				; L.274
	MOVE	AC1,AC11			; AC1,BIAS
	ADD	AC1,AC10			; AC1,LEN
	CAMLE	AC1,U.94			; AC1,SCANUM
	JRST	L.275				; L.275
L.274:	MOVEI	AC1,P.AGF			; AC1,P.AGF
	PUSHJ	SP,U.1				; SP,CERROR
L.275:	MOVE	AC1,U.94			; AC1,SCANUM
	MOVEM	AC1,-1(SP)			; AC1,FRO
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,2				; AC1,2
	JRST	L.276				; L.276
	MOVEI	AC1,P.AGG			; AC1,P.AGG
	PUSHJ	SP,U.1				; SP,CERROR
L.276:	CAMLE	AC11,U.94			; BIAS,SCANUM
	JRST	L.277				; L.277
	MOVE	AC1,AC11			; AC1,BIAS
	ADD	AC1,AC10			; AC1,LEN
	CAMLE	AC1,U.94			; AC1,SCANUM
	JRST	L.278				; L.278
L.277:	MOVEI	AC1,P.AGH			; AC1,P.AGH
	PUSHJ	SP,U.1				; SP,CERROR
L.278:	MOVE	AC2,U.94			; AC2,SCANUM
	MOVE	AC1,-1(SP)			; I,FRO
	SOJA	AC1,L.280			; I,L.280
L.279:	MOVE	AC3,AC14			; AC3,TBL
	ADD	AC3,AC1				; AC3,I
	SUB	AC3,AC11			; AC3,BIAS
	MOVE	AC4,U.86			; AC4,NEXTIN
	MOVEM	AC4,U.78+1(AC3)			; AC4,CNSWRK+1(AC3)
L.280:	ADDI	AC1,1				; I,1
	CAMG	AC1,AC2				; I,AC2
	JRST	L.279				; L.279
	JRST	L.288				; L.288
L.281:	CAMLE	AC11,U.94			; BIAS,SCANUM
	JRST	L.282				; L.282
	MOVE	AC1,AC11			; AC1,BIAS
	ADD	AC1,AC10			; AC1,LEN
	CAMLE	AC1,U.94			; AC1,SCANUM
	JRST	L.283				; L.283
L.282:	MOVEI	AC1,P.AGI			; AC1,P.AGI
	PUSHJ	SP,U.1				; SP,CERROR
L.283:	MOVE	AC1,U.94			; AC1,SCANUM
	MOVE	AC3,AC14			; AC3,TBL
	ADD	AC3,AC1				; AC3,AC1
	SUB	AC3,AC11			; AC3,BIAS
	MOVE	AC1,U.86			; AC1,NEXTIN
	MOVEM	AC1,U.78+1(AC3)			; AC1,CNSWRK+1(AC3)
	JRST	L.290				; L.290
L.284:	CAIE	AC13,50				; AC13,50
	JRST	L.287				; L.287
	MOVE	AC1,AC10			; I,LEN
	AOJA	AC1,L.286			; I,L.286
L.285:	MOVE	AC3,AC14			; AC3,TBL
	ADD	AC3,AC1				; AC3,I
	SETO	AC2,				; AC2,
	CAME	AC2,U.78+1(AC3)			; AC2,CNSWRK+1(AC3)
	JRST	L.286				; L.286
	MOVE	AC2,U.86			; AC2,NEXTIN
	MOVEM	AC2,U.78+1(AC3)			; AC2,CNSWRK+1(AC3)
L.286:	SOJGE	AC1,L.285			; I,L.285
	JRST	L.288				; L.288
L.287:	CAIE	AC13,51				; AC13,51
	JRST	L.289				; L.289
	MOVE	AC1,U.86			; AC1,NEXTIN
	MOVEM	AC1,U.78-1(AC14)		; AC1,CNSWRK-1(TBL)
L.288:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.290				; L.290
L.289:	MOVEI	AC1,P.AGJ			; AC1,P.AGJ
	PUSHJ	SP,U.1				; SP,CERROR
L.290:	MOVEI	AC1,21				; AC1,21
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.292				; L.292
L.291:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.273				; L.273
L.292:	MOVEI	AC1,24				; AC1,24
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.294				; L.294
	SKIPE	0(SP)				; BRKHAK
	JRST	L.293				; L.293
	MOVEI	AC1,P.AGK			; AC1,P.AGK
	PUSHJ	SP,U.1				; SP,CERROR
L.293:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.295				; L.295
L.294:	SKIPN	0(SP)				; BRKHAK
	JRST	L.295				; L.295
	MOVEI	AC1,P.AGL			; AC1,P.AGL
	PUSHJ	SP,U.1				; SP,CERROR
L.295:	MOVEI	AC1,22				; AC1,22
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.296				; L.296
	MOVEI	AC1,U.61			; AC1,CERM11
	PUSHJ	SP,U.1				; SP,CERROR
L.296:	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPN	AC1,L.297			; AC1,L.297
	MOVEI	AC1,U.62			; AC1,CERM12
	PUSHJ	SP,U.1				; SP,CERROR
L.297:	MOVEI	AC1,32				; AC1,32
	MOVE	AC2,AC12			; AC2,AC12
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEI	AC1,20				; AC1,20
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.272				; L.272
L.298:	MOVEI	AC1,32				; AC1,32
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.299				; L.299
	MOVEI	AC1,U.57			; AC1,CERM7
	PUSHJ	SP,U.1				; SP,CERROR
L.299:	PUSHJ	SP,U.3				; SP,SCAN
	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC12)			; AC1,CODWRK(AC12)
	ADJSP	SP,-2				; SP,-2
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,

; Routine Size:  219 words


;	  2295	
;	  2296	ROUTINE CPLOOP: NOVALUE =	! <Do-statement>
;	  2297	
;	  2298	!++
;	  2299	! Functional description:
;	  2300	!	Called from <Statement> to compile a DO statement.  This may
;	  2301	!	be a DO-WHILE, DO-UNTIL, WHILE-DO, or UNTIL-DO statement.
;	  2302	!
;	  2303	! Formal parameters:
;	  2304	!	None
;	  2305	!
;	  2306	! Implicit inputs:
;	  2307	!	Current atom, source
;	  2308	!
;	  2309	! Implicit outputs:
;	  2310	!	Code
;	  2311	!
;	  2312	! Routine value:
;	  2313	!	None
;	  2314	!
;	  2315	! Side effects:
;	  2316	!	Scans from statement keyword to unrecognized atom
;	  2317	!
;	  2318	!--
;	  2319	
;	  2320	    BEGIN
;	  2321	    EXTERNAL REGISTER Z=0;
;	  2322	    LOCAL
;	  2323		TOPADR,			! Location of top of loop
;	  2324		IFADDR;			! Location of compare instruction
;	  2325	    CASE .SCACOD FROM SCN_DO TO SCN_UNTIL OF
;	  2326		SET
;	  2327	[SCN_DO]:   BEGIN
;	  2328		    LOCAL
;	  2329			SWITCH;
;	  2330		    TOPADR = .NEXTIN;
;	  2331		    SCAN();
;	  2332		    IF CPSTMT() EQL FALSE THEN CERROR(CERM9);
;	  2333		    IF .SCACOD EQL SCN_WHILE OR .SCACOD EQL SCN_UNTIL
;	  2334		    THEN
;	  2335			SWITCH = .SCACOD
;	  2336		    ELSE
;	  2337			ERROR('WHILE or UNTIL missing');
;	  2338		    SCAN();
;	  2339		    IFADDR = CPLEXP();
;	  2340		    IF .SWITCH EQL SCN_WHILE
;	  2341		    THEN
;	  2342			BEGIN
;	  2343			CODWRK[.IFADDR,COD_OPA] = .IFADDR + 3;
;	  2344			GENINS(OPR_JMP,.TOPADR,0,0)
;	  2345			END
;	  2346		    ELSE
;	  2347			CODWRK[.IFADDR,COD_OPA] = .TOPADR
;	  2348		    END;
;	  2349	[SCN_WHILE]:BEGIN
;	  2350		    TOPADR = .NEXTIN;
;	  2351		    SCAN();
;	  2352		    IFADDR = CPLEXP();
;	  2353		    IF .SCACOD NEQ SCN_DO THEN ERROR('DO missing after WHILE');
;	  2354		    SCAN();
;	  2355		    IF CPSTMT() EQL FALSE THEN CERROR(CERM9);
;	  2356		    GENINS(OPR_JMP,.TOPADR,0,0);
;	  2357		    CODWRK[.IFADDR,COD_OPA] = .NEXTIN
;	  2358		    END;
;	  2359	[SCN_UNTIL]:BEGIN
;	  2360		    TOPADR = .NEXTIN;
;	  2361		    SCAN();
;	  2362		    IFADDR = CPLEXP();
;	  2363		    GENINS(OPR_JMP,0,0,0);
;	  2364		    CODWRK[.IFADDR,COD_OPA] = .NEXTIN;
;	  2365		    IF .SCACOD NEQ SCN_DO THEN ERROR('DO missing after UNTIL');
;	  2366		    SCAN();
;	  2367		    IF CPSTMT() EQL FALSE THEN CERROR(CERM9);
;	  2368		    GENINS(OPR_JMP,.TOPADR,0,0);
;	  2369		    CODWRK[.IFADDR+2,COD_OPA] = .NEXTIN
;	  2370		    END
;	  2371		TES
;	  2372	    END;


P.AGM:	BYTE	(7)"W","H","I","L","E"		; WHILE
	BYTE	(7)" ","o","r"," ","U"		;  or U
	BYTE	(7)"N","T","I","L"," "		; NTIL
	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g",000,000,000		; ng
P.AGN:	BYTE	(7)"D","O"," ","m","i"		; DO mi
	BYTE	(7)"s","s","i","n","g"		; ssing
	BYTE	(7)" ","a","f","t","e"		;  afte
	BYTE	(7)"r"," ","W","H","I"		; r WHI
	BYTE	(7)"L","E",000,000,000		; LE
P.AGO:	BYTE	(7)"D","O"," ","m","i"		; DO mi
	BYTE	(7)"s","s","i","n","g"		; ssing
	BYTE	(7)" ","a","f","t","e"		;  afte
	BYTE	(7)"r"," ","U","N","T"		; r UNT
	BYTE	(7)"I","L",000,000,000		; IL


; CPLOOP
U.26:	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC1,U.95			; AC1,SCACOD
	SUBI	AC1,52				; AC1,52
	JRST	L.300(AC1)			; L.300(AC1)
L.300:	JRST	L.301				; L.301
	JRST	L.307				; L.307
	JRST	L.310				; L.310
L.301:	MOVE	AC12,U.86			; TOPADR,NEXTIN
	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPN	AC1,L.302			; AC1,L.302
	MOVEI	AC1,U.59			; AC1,CERM9
	PUSHJ	SP,U.1				; SP,CERROR
L.302:	MOVE	AC1,U.95			; AC1,SCACOD
	CAIN	AC1,53				; AC1,53
	JRST	L.303				; L.303
	CAIE	AC1,54				; AC1,54
	JRST	L.304				; L.304
L.303:	MOVE	AC13,AC1			; SWITCH,AC1
	JRST	L.305				; L.305
L.304:	MOVEI	AC1,P.AGM			; AC1,P.AGM
	PUSHJ	SP,U.1				; SP,CERROR
L.305:	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.46				; SP,CPLEXP
	MOVE	AC14,AC1			; IFADDR,AC1
	CAIE	AC13,53				; SWITCH,53
	JRST	L.306				; L.306
	MOVE	AC1,AC14			; AC1,IFADDR
	ADDI	AC1,3				; AC1,3
	HRRM	AC1,U.76(AC14)			; AC1,CODWRK(IFADDR)
	MOVEI	AC1,32				; AC1,32
	MOVE	AC2,AC12			; AC2,TOPADR
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	JRST	L.313				; L.313
L.306:	HRRM	AC12,U.76(AC14)			; TOPADR,CODWRK(IFADDR)
	JRST	L.313				; L.313
L.307:	MOVE	AC12,U.86			; TOPADR,NEXTIN
	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.46				; SP,CPLEXP
	MOVE	AC14,AC1			; IFADDR,AC1
	MOVEI	AC1,52				; AC1,52
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.308				; L.308
	MOVEI	AC1,P.AGN			; AC1,P.AGN
	PUSHJ	SP,U.1				; SP,CERROR
L.308:	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPN	AC1,L.309			; AC1,L.309
	MOVEI	AC1,U.59			; AC1,CERM9
	PUSHJ	SP,U.1				; SP,CERROR
L.309:	MOVEI	AC1,32				; AC1,32
	MOVE	AC2,AC12			; AC2,TOPADR
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC14)			; AC1,CODWRK(IFADDR)
	JRST	L.313				; L.313
L.310:	MOVE	AC12,U.86			; TOPADR,NEXTIN
	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.46				; SP,CPLEXP
	MOVE	AC14,AC1			; IFADDR,AC1
	MOVEI	AC1,32				; AC1,32
	SETZB	AC2,AC3				; AC2,AC3
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC14)			; AC1,CODWRK(IFADDR)
	MOVEI	AC1,52				; AC1,52
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.311				; L.311
	MOVEI	AC1,P.AGO			; AC1,P.AGO
	PUSHJ	SP,U.1				; SP,CERROR
L.311:	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPN	AC1,L.312			; AC1,L.312
	MOVEI	AC1,U.59			; AC1,CERM9
	PUSHJ	SP,U.1				; SP,CERROR
L.312:	MOVEI	AC1,32				; AC1,32
	MOVE	AC2,AC12			; AC2,TOPADR
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76+2(AC14)		; AC1,CODWRK+2(IFADDR)
L.313:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,

; Routine Size:  90 words


;	  2373	
;	  2374	                                ! [fun45]+ Soup up Select, add selectall
;	  2375	ROUTINE CPSELE (fall_thru) : NOVALUE =	! <Select-statement>
;	  2376	
;	  2377	!++
;	  2378	! Functional description:
;	  2379	!	Called from <Statement> to compile a Select statement.
;	  2380	!
;	  2381	! Input Formals
;	  2382	!       false for select, true for selectall
;	  2383	!
;	  2384	! Output Formals
;	  2385	!       none
;	  2386	!
;	  2387	! Implicit inputs:
;	  2388	!	Source
;	  2389	!
;	  2390	! Implicit outputs:
;	  2391	!	Code
;	  2392	!
;	  2393	! Routine value:
;	  2394	!	None
;	  2395	!
;	  2396	! Side effects:
;	  2397	!	Scans from Select to unrecognized atom
;	  2398	!
;	  2399	! Semantics
;	  2400	! This routine compiles a select or selectall statement, where each case is:
;	  2401	!    [n1 [,n2]...]
;	  2402	! or [OTHERWISE] or [ALWAYS]
;	  2403	! The structure of the code generated is as follows:
;	  2404	!    - instructions to assemble select "target", eventually leaving it on the
;	  2405	! stack. 
;	  2406	!    - if Selectall, code to push a select flag on the stack, indicating
;	  2407	!       where 1 indicates a previous success, 0 none yet.
;	  2408	!    - for each case:
;	  2409	!      * for each tag within the case:      
;	  2410	!        + ..N1,.. generates:
;	  2411	!          - code to push the target on the stack if needed
;	  2412	!          - code to assemble N1, enventually leaving it on the stack,
;	  2413	!          - code doing: if target eql n1, jump to "code_body"
;	  2414	!        + ..N1] generates:
;	  2415	!          - code to push the target on the stack if needed
;	  2416	!          - code to asemble N1, eventually leaving it on the stack,
;	  2417	!          - code doing: if target neq N1, jump to "next_case"
;	  2418	!        + ..N1 to N2,... generates:
;	  2419	!          - code to push target, code to assemble N1
;	  2420	!          - code doing: if n1 lss target, jump to test for next tag
;	  2421	!            in this case
;	  2422	!          - code to push target, code to assemble N2
;	  2423	!          - code doing: if n1 leq target, jump to "code_body"
;	  2424	!        + ..N1 to N2] generates:
;	  2425	!          - code to push target, code to assemble N1
;	  2426	!          - if n1 lss target then jump to "next_case"
;	  2427	!          - code to push target, code to assemble N2
;	  2428	!          - code doing: if n1 gtr target, jump to "next_case"
;	  2429	!      * For the body:
;	  2430	!        + if tag is [otherwise] and test is selectall:
;	  2431	!          code doing: if top of stack is > 0, jump to "next_case"
;	  2432	!        + Pop select flag from top of stack, and push 1 to indicate a match
;	  2433	!        + body proper
;	  2434	!        + if Select, jump to "case_exit"
;	  2435	!    - At the end of the case:
;	  2436	!      + code to pop the target if needed, and the select flag.
;	  2437	!
;	  2438	! During the execution of the case, the stack holds usually:
;	  2439	!     stkp -> case target     for select
;	  2440	! or
;	  2441	!             case target
;	  2442	!     stkp -> case flag       for SelectAll
;	  2443	!--
;	  2444	
;	  2445	    BEGIN
;	  2446	    EXTERNAL REGISTER Z=0;
;	  2447	    LOCAL
;	  2448		SDESC,			! Select-expression operand descriptor
;	  2449		TDESC,			! First Test-expression operand descriptor
;	  2450	        tdesc1,                 ! Second test-expression in N1 TO N2
;	  2451	        toffset,                ! Offset of select target below stack ptr
;	  2452	        token,                  ! Temporarily holds a scan result.
;	  2453	        next_test_adr,          ! Link for jumps to next test
;	  2454	        body_adr,               ! Link for jumps to body
;	  2455	        exit_adr,               ! Link for jumps to exit of select
;	  2456	        temp_adr,               ! Temporary address
;	  2457	        gotone,                 ! Say if we had a tag in a case already
;	  2458		TYPE,			! Data type of test
;	  2459	        brkhak,                 ! Hack flag to handle omission of ['s
;	  2460		oprne,			! Comparison operation code for last
;	  2461	                                ! tag within a case
;	  2462	        opreq,                  ! Comparison operation code for all
;	  2463	                                ! tags within a case except the last one
;	  2464	        oprlt,
;	  2465	        oprgt,
;	  2466	        oprle;
;	  2467	
;	  2468	    SCAN();
;	  2469	    TYPE = CPCLSE();
;	  2470	    IF .TYPE LSS 0 THEN CERROR(CERM18);
;	  2471	    IF .TYPE EQL STE_TYP_INT THEN beGIN
;	  2472	        SDESC = CPIEXP(OPN_TMP_INT);
;	  2473		oprne = opr_bne;
;	  2474	        opreq = opr_beq;      
;	  2475	        oprlt = opr_blt;
;	  2476	        oprgt = opr_bgt;
;	  2477	        oprle = opr_ble;
;	  2478		END
;	  2479	    ELSE begin
;	  2480		SDESC = CPSEXP(OPN_TMP_STR);
;	  2481		oprne = opr_cne;
;	  2482	        opreq = opr_ceq;      
;	  2483	        oprlt = opr_clt;
;	  2484	        oprgt = opr_cgt;
;	  2485	        oprle = opr_cle;
;	  2486		END;
;	  2487	    IF .SCACOD NEQ SCN_OF THEN CERROR(CERM20);
;	  2488	    IF SCAN() NEQ SCN_BEGIN THEN CERROR(CERM21);
;	  2489	    EXIT_ADR = %O'777777';      ! link for jumps to exit
;	  2490	
;	  2491	                                ! Push flag for "otherwise"
;	  2492	    if .fall_thru then begin
;	  2493	        genins (opr_psh,0,0,0); ! No match yet
;	  2494	        toffset = 1;
;	  2495	        end
;	  2496	    else
;	  2497	        toffset = 0;
;	  2498	
;	  2499	                                ! LOOP ON ALL CASES
;	  2500	    do begin
;	  2501		if scan() eql scn_end then exitloop;
;	  2502	        body_adr =  %o'777777';  ! link address of body
;	  2503	        next_test_adr = %o'777777';     ! link address of next test
;	  2504		brkhak = 0;		! assume no square brackets around labels
;	  2505		if .scacod eql scn_lbrkt then
;	  2506		    begin
;	  2507		    brkhak = -1;	! we do have square brackets on this one
;	  2508		    scan()		! read next token (skip over bracket)
;	  2509		    end;
;	  2510	
;	  2511	                                ! LOOP ON ALL TAGS WITHIN A CASE
;	  2512	        gotone = 0;             ! got no tag yet
;	  2513	        while true do begin
;	  2514	           token = .scacod;
;	  2515	           if .token eql scn_always or .token eql scn_otherwise then begin
;	  2516	               if .gotone neq 0 then
;	  2517	                  cerror (cerm101);
;	  2518	               if .token eql scn_otherwise and .fall_thru then
;	  2519	                  next_test_adr = genins(opr_jsp,.next_test_adr,0,0);
;	  2520	               scan();          ! make ready for exit
;	  2521	               if .scacod eql scn_comma then
;	  2522	                  cerror (cerm101);
;	  2523	               exitloop;        ! Must be last tag of a test
;	  2524	               end
;	  2525	           else begin
;	  2526	                                ! If target is on stack, push a copy of it
;	M 2527	               MACRO push_sdesc = 
;	M 2528	                if .sdesc eql opn_tmp_int or .sdesc eql opn_tmp_str then
;	  2529	                   genins(opr_pst,.sdesc,.toffset,0) %;
;	  2530	               push_sdesc;
;	  2531	               if .type eql ste_typ_int then tdesc = cpiexp(opn_tmp_int)
;	  2532	                                        else tdesc = cpsexp(opn_tmp_str);
;	  2533	
;	  2534	                                ! N1 TO N2,   or   N1 TO N2]
;	  2535	               if .scacod eql scn_to then begin
;	  2536	                  scan();
;	  2537			  if .type eql ste_typ_int then tdesc1 = cpiexp(opn_tmp_int)
;	  2538	                                           else tdesc1 = cpsexp(opn_tmp_str);
;	  2539	                  if .scacod eql scn_comma then begin
;	  2540	                     temp_adr = genins(.oprlt,0,.sdesc,.tdesc);
;	  2541	                     push_sdesc;
;	  2542	                     body_adr = genins(.oprle,.body_adr,.sdesc,.tdesc1);
;	  2543	                     codwrk[.temp_adr,cod_opa] = .nextin;
;	  2544	                     end
;	  2545	                  else begin    ! If not comma, assume end
;	  2546	                     next_test_adr=genins(.oprlt,.next_test_adr,.sdesc,.tdesc);
;	  2547	                     push_sdesc;
;	  2548	                     next_test_adr = 
;	  2549	                      genins(.oprgt,.next_test_adr,.sdesc,.tdesc1);
;	  2550	                     exitloop;
;	  2551	                     end;
;	  2552	                  end ! (if .token eql scn_to -> N1 TO N, or N1 TO N2] )
;	  2553	
;	  2554	                                ! N1, or N1]
;	  2555	                                ! N1 is in tdesc. The , or ] is already parsed
;	  2556	
;	  2557	               else begin
;	  2558	                  if .scacod eql scn_comma then
;	  2559	                     body_adr = genins (.opreq,.body_adr,.sdesc,.tdesc)
;	  2560	                  else begin    ! If not comma, assume end
;	  2561	                     next_test_adr = 
;	  2562	                     genins(.oprne,.next_test_adr,.sdesc,.tdesc);
;	  2563	                     exitloop;
;	  2564	                     end;
;	  2565	                  end;
;	  2566	               end;
;	  2567	               scan();          ! Loop needs next item on entry
;	  2568	               gotone = -1;     ! Say we had a tag already
;	  2569	
;	  2570	           end;                 ! End loop on all tags within a case
;	  2571	
;	  2572	
;	  2573	                                ! Check for ] if needed
;	  2574	        if .scacod eql scn_rbrkt then begin
;	  2575	           if .brkhak eql 0 then
;	  2576	              error ('Extraneous ] in Select(All)');
;	  2577	           scan();              ! grab next token
;	  2578	           end
;	  2579	        else if .brkhak neq 0 then
;	  2580	           error ('Missing ] in Select(All)');
;	  2581	
;	  2582	                                ! Check colon
;	  2583		if .scacod neq scn_colon then cerror(cerm11);
;	  2584	
;	  2585	                                ! Patch jumps to code body
;	  2586	        while .body_adr neq %o'777777' do begin
;	  2587	           temp_adr = .codwrk[.body_adr,cod_opa];
;	  2588	           codwrk[.body_adr,cod_opa] = .nextin;
;	  2589	           body_adr = .temp_adr;
;	  2590	           end;
;	  2591	                                ! GENERATE CODE BODY, [JUMP TO EXIT]
;	  2592	                                ! Set flag for "otherwise"
;	  2593	        if .fall_thru then begin
;	  2594	           genins(opr_pop,0,0,0);
;	  2595	           genins(opr_psh,1,0,0);       ! We have found a selected case
;	  2596	           end;
;	  2597		scan();
;	  2598		if cpstmt() eql false then cerror(cerm12);
;	  2599	        if not .fall_thru then
;	  2600	           exit_adr = genins(opr_jmp,.exit_adr,0,0);
;	  2601	
;	  2602	                                ! Patch jumps to next test
;	  2603	        while .next_test_adr neq %o'777777' do begin
;	  2604	           temp_adr = .codwrk[.next_test_adr,cod_opa];
;	  2605	           codwrk[.next_test_adr,cod_opa] = .nextin;
;	  2606	           next_test_adr = .temp_adr;
;	  2607	           end;
;	  2608	
;	  2609		end ! (loop on all cases)
;	  2610	    until
;	  2611		.scacod neq scn_semi;
;	  2612	    if .scacod neq scn_end then cerror(cerm7);
;	  2613	    scan();
;	  2614	                                ! Patch jumps to exit address
;	  2615	    while .exit_adr neq %o'777777' do begin
;	  2616	        temp_adr = .codwrk[.exit_adr,cod_opa];
;	  2617	        codwrk[.exit_adr,cod_opa] = .nextin;
;	  2618	        exit_adr = .temp_adr;
;	  2619	        end;
;	  2620	
;	  2621	                                ! Finally, pop select target and flag
;	  2622	    if .sdesc eql opn_tmp_int or .sdesc eql opn_tmp_str
;	  2623	    then
;	  2624		genins(opr_stp,.sdesc,.toffset,0)
;	  2625	
;	  2626	    END;


P.AGP:	BYTE	(7)"E","x","t","r","a"		; Extra
	BYTE	(7)"n","e","o","u","s"		; neous
	BYTE	(7)" ","]"," ","i","n"		;  ] in
	BYTE	(7)" ","S","e","l","e"		;  Sele
	BYTE	(7)"c","t","(","A","l"		; ct(Al
	BYTE	(7)"l",")",000,000,000		; l)
P.AGQ:	BYTE	(7)"M","i","s","s","i"		; Missi
	BYTE	(7)"n","g"," ","]"," "		; ng ]
	BYTE	(7)"i","n"," ","S","e"		; in Se
	BYTE	(7)"l","e","c","t","("		; lect(
	BYTE	(7)"A","l","l",")",000		; All)


; CPSELE
U.27:	PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,20				; SP,20
	MOVEM	AC1,0(SP)			; AC1,0(SP)
	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.50				; SP,CPCLSE
	MOVE	AC10,AC1			; TYPE,AC1
	JUMPGE	AC10,L.314			; TYPE,L.314
	MOVEI	AC1,U.68			; AC1,CERM18
	PUSHJ	SP,U.1				; SP,CERROR
L.314:	SETZM	-14(SP)				; -14(SP)
	JUMPN	AC10,L.315			; TYPE,L.315
	MOVEI	AC1,1				; AC1,1
	MOVEM	AC1,-14(SP)			; AC1,-14(SP)
	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	MOVEM	AC1,-1(SP)			; AC1,SDESC
	MOVEI	AC1,12				; AC1,12
	MOVEM	AC1,-7(SP)			; AC1,OPRNE
	MOVEI	AC1,11				; AC1,11
	MOVEM	AC1,-10(SP)			; AC1,OPREQ
	MOVEI	AC1,10				; AC1,10
	MOVEM	AC1,-11(SP)			; AC1,OPRLT
	MOVEI	AC1,14				; AC1,14
	MOVEM	AC1,-12(SP)			; AC1,OPRGT
	MOVEI	AC1,7				; AC1,7
	JRST	L.316				; L.316
L.315:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
	MOVEM	AC1,-1(SP)			; AC1,SDESC
	MOVEI	AC1,20				; AC1,20
	MOVEM	AC1,-7(SP)			; AC1,OPRNE
	MOVEI	AC1,17				; AC1,17
	MOVEM	AC1,-10(SP)			; AC1,OPREQ
	MOVEI	AC1,16				; AC1,16
	MOVEM	AC1,-11(SP)			; AC1,OPRLT
	MOVEI	AC1,22				; AC1,22
	MOVEM	AC1,-12(SP)			; AC1,OPRGT
	MOVEI	AC1,15				; AC1,15
L.316:	MOVEM	AC1,-13(SP)			; AC1,OPRLE
	MOVEI	AC1,47				; AC1,47
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.317				; L.317
	MOVEI	AC1,U.70			; AC1,CERM20
	PUSHJ	SP,U.1				; SP,CERROR
L.317:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,31				; AC1,31
	JRST	L.318				; L.318
	MOVEI	AC1,U.71			; AC1,CERM21
	PUSHJ	SP,U.1				; SP,CERROR
L.318:	MOVEI	AC12,-1				; EXIT_ADR,-1
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,0(SP)			; AC1,0(SP)
	JRST	L.319				; L.319
	MOVEI	AC1,47				; AC1,47
	SETZB	AC2,AC3				; AC2,AC3
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEI	AC1,1				; AC1,1
	MOVEM	AC1,-6(SP)			; AC1,TOFFSET
	JRST	L.320				; L.320
L.319:	SETZM	-6(SP)				; TOFFSET
L.320:	MOVE	AC1,0(SP)			; AC1,0(SP)
	SETCAM	AC1,-15(SP)			; AC1,-15(SP)
L.321:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,32				; AC1,32
	JRST	L.354				; L.354
	MOVEI	AC11,-1				; BODY_ADR,-1
	MOVEI	AC10,-1				; NEXT_TEST_ADR,-1
	SETZM	-4(SP)				; BRKHAK
	MOVEI	AC1,23				; AC1,23
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.322				; L.322
	SETOM	-4(SP)				; BRKHAK
	PUSHJ	SP,U.3				; SP,SCAN
L.322:	SETZM	-5(SP)				; GOTONE
L.323:	MOVE	AC1,U.95			; AC1,SCACOD
	MOVEM	AC1,-3(SP)			; AC1,TOKEN
	MOVEI	AC1,132				; AC1,132
	CAMN	AC1,-3(SP)			; AC1,TOKEN
	JRST	L.324				; L.324
	MOVEI	AC1,62				; AC1,62
	CAME	AC1,-3(SP)			; AC1,TOKEN
	JRST	L.327				; L.327
L.324:	SKIPN	-5(SP)				; GOTONE
	JRST	L.325				; L.325
	MOVEI	AC1,U.75			; AC1,CERM101
	PUSHJ	SP,U.1				; SP,CERROR
L.325:	MOVEI	AC1,62				; AC1,62
	CAME	AC1,-3(SP)			; AC1,TOKEN
	JRST	L.326				; L.326
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,0(SP)			; AC1,0(SP)
	JRST	L.326				; L.326
	MOVEI	AC1,57				; AC1,57
	MOVE	AC2,AC10			; AC2,NEXT_TEST_ADR
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC10,AC1			; NEXT_TEST_ADR,AC1
L.326:	PUSHJ	SP,U.3				; SP,SCAN
	MOVEI	AC1,21				; AC1,21
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.344				; L.344
	MOVEI	AC1,U.75			; AC1,CERM101
	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.344				; L.344
L.327:	SETZM	-2(SP)				; -2(SP)
	MOVEI	AC1,-200000			; AC1,-200000
	CAME	AC1,-1(SP)			; AC1,SDESC
	JRST	L.328				; L.328
	MOVEI	AC1,1				; AC1,1
	MOVEM	AC1,-2(SP)			; AC1,-2(SP)
	JRST	L.329				; L.329
L.328:	MOVEI	AC1,-100000			; AC1,-100000
	CAME	AC1,-1(SP)			; AC1,SDESC
	JRST	L.330				; L.330
L.329:	MOVEI	AC1,30				; AC1,30
	MOVE	AC2,-1(SP)			; AC2,SDESC
	MOVE	AC3,-6(SP)			; AC3,TOFFSET
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
L.330:	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,-14(SP)			; AC1,-14(SP)
	JRST	L.331				; L.331
	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	JRST	L.332				; L.332
L.331:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
L.332:	MOVEM	AC1,-16(SP)			; AC1,TDESC
	MOVE	AC13,U.95			; AC13,SCACOD
	CAIE	AC13,46				; AC13,46
	JRST	L.340				; L.340
	PUSHJ	SP,U.3				; SP,SCAN
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,-14(SP)			; AC1,-14(SP)
	JRST	L.333				; L.333
	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	JRST	L.334				; L.334
L.333:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
L.334:	MOVEM	AC1,-17(SP)			; AC1,TDESC1
	MOVEI	AC1,21				; AC1,21
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.337				; L.337
	MOVE	AC1,-11(SP)			; AC1,OPRLT
	SETZ	AC2,				; AC2,
	MOVE	AC3,-1(SP)			; AC3,SDESC
	MOVE	AC4,-16(SP)			; AC4,TDESC
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC14,AC1			; TEMP_ADR,AC1
	MOVEI	AC1,1				; AC1,1
	TDNE	AC1,-2(SP)			; AC1,-2(SP)
	JRST	L.335				; L.335
	MOVEI	AC1,-100000			; AC1,-100000
	CAME	AC1,-1(SP)			; AC1,SDESC
	JRST	L.336				; L.336
L.335:	MOVEI	AC1,30				; AC1,30
	MOVE	AC2,-1(SP)			; AC2,SDESC
	MOVE	AC3,-6(SP)			; AC3,TOFFSET
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
L.336:	MOVE	AC1,-13(SP)			; AC1,OPRLE
	MOVE	AC2,AC11			; AC2,BODY_ADR
	MOVE	AC3,-1(SP)			; AC3,SDESC
	MOVE	AC4,-17(SP)			; AC4,TDESC1
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC11,AC1			; BODY_ADR,AC1
	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC14)			; AC1,CODWRK(TEMP_ADR)
	JRST	L.343				; L.343
L.337:	MOVE	AC1,-11(SP)			; AC1,OPRLT
	MOVE	AC2,AC10			; AC2,NEXT_TEST_ADR
	MOVE	AC3,-1(SP)			; AC3,SDESC
	MOVE	AC4,-16(SP)			; AC4,TDESC
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC10,AC1			; NEXT_TEST_ADR,AC1
	MOVEI	AC1,1				; AC1,1
	TDNE	AC1,-2(SP)			; AC1,-2(SP)
	JRST	L.338				; L.338
	MOVEI	AC1,-100000			; AC1,-100000
	CAME	AC1,-1(SP)			; AC1,SDESC
	JRST	L.339				; L.339
L.338:	MOVEI	AC1,30				; AC1,30
	MOVE	AC2,-1(SP)			; AC2,SDESC
	MOVE	AC3,-6(SP)			; AC3,TOFFSET
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
L.339:	MOVE	AC1,-12(SP)			; AC1,OPRGT
	MOVE	AC2,AC10			; AC2,NEXT_TEST_ADR
	MOVE	AC3,-1(SP)			; AC3,SDESC
	MOVE	AC4,-17(SP)			; AC4,TDESC1
	JRST	L.342				; L.342
L.340:	CAIE	AC13,21				; AC13,21
	JRST	L.341				; L.341
	MOVE	AC1,-10(SP)			; AC1,OPREQ
	MOVE	AC2,AC11			; AC2,BODY_ADR
	MOVE	AC3,-1(SP)			; AC3,SDESC
	MOVE	AC4,-16(SP)			; AC4,TDESC
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC11,AC1			; BODY_ADR,AC1
	JRST	L.343				; L.343
L.341:	MOVE	AC1,-7(SP)			; AC1,OPRNE
	MOVE	AC2,AC10			; AC2,NEXT_TEST_ADR
	MOVE	AC3,-1(SP)			; AC3,SDESC
	MOVE	AC4,-16(SP)			; AC4,TDESC
L.342:	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC10,AC1			; NEXT_TEST_ADR,AC1
	JRST	L.344				; L.344
L.343:	PUSHJ	SP,U.3				; SP,SCAN
	SETOM	-5(SP)				; GOTONE
	JRST	L.323				; L.323
L.344:	MOVEI	AC1,24				; AC1,24
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.346				; L.346
	SKIPE	-4(SP)				; BRKHAK
	JRST	L.345				; L.345
	MOVEI	AC1,P.AGP			; AC1,P.AGP
	PUSHJ	SP,U.1				; SP,CERROR
L.345:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.347				; L.347
L.346:	SKIPN	-4(SP)				; BRKHAK
	JRST	L.347				; L.347
	MOVEI	AC1,P.AGQ			; AC1,P.AGQ
	PUSHJ	SP,U.1				; SP,CERROR
L.347:	MOVEI	AC1,22				; AC1,22
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.348				; L.348
	MOVEI	AC1,U.61			; AC1,CERM11
	PUSHJ	SP,U.1				; SP,CERROR
L.348:	CAIN	AC11,-1				; BODY_ADR,-1
	JRST	L.349				; L.349
	HRRZ	AC14,U.76(AC11)			; TEMP_ADR,CODWRK(BODY_ADR)
	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC11)			; AC1,CODWRK(BODY_ADR)
	MOVE	AC11,AC14			; BODY_ADR,TEMP_ADR
	JRST	L.348				; L.348
L.349:	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,0(SP)			; AC1,0(SP)
	JRST	L.350				; L.350
	MOVEI	AC1,50				; AC1,50
	SETZB	AC2,AC3				; AC2,AC3
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEI	AC1,47				; AC1,47
	MOVEI	AC2,1				; AC2,1
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
L.350:	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPN	AC1,L.351			; AC1,L.351
	MOVEI	AC1,U.62			; AC1,CERM12
	PUSHJ	SP,U.1				; SP,CERROR
L.351:	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,-15(SP)			; AC1,-15(SP)
	JRST	L.352				; L.352
	MOVEI	AC1,32				; AC1,32
	MOVE	AC2,AC12			; AC2,EXIT_ADR
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC12,AC1			; EXIT_ADR,AC1
L.352:	CAIN	AC10,-1				; NEXT_TEST_ADR,-1
	JRST	L.353				; L.353
	HRRZ	AC14,U.76(AC10)			; TEMP_ADR,CODWRK(NEXT_TEST_ADR)
	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC10)			; AC1,CODWRK(NEXT_TEST_ADR)
	MOVE	AC10,AC14			; NEXT_TEST_ADR,TEMP_ADR
	JRST	L.352				; L.352
L.353:	MOVEI	AC1,20				; AC1,20
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.321				; L.321
L.354:	MOVEI	AC1,32				; AC1,32
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.355				; L.355
	MOVEI	AC1,U.57			; AC1,CERM7
	PUSHJ	SP,U.1				; SP,CERROR
L.355:	PUSHJ	SP,U.3				; SP,SCAN
L.356:	CAIN	AC12,-1				; EXIT_ADR,-1
	JRST	L.357				; L.357
	HRRZ	AC14,U.76(AC12)			; TEMP_ADR,CODWRK(EXIT_ADR)
	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC12)			; AC1,CODWRK(EXIT_ADR)
	MOVE	AC12,AC14			; EXIT_ADR,TEMP_ADR
	JRST	L.356				; L.356
L.357:	MOVEI	AC1,-200000			; AC1,-200000
	CAMN	AC1,-1(SP)			; AC1,SDESC
	JRST	L.358				; L.358
	MOVEI	AC1,-100000			; AC1,-100000
	CAME	AC1,-1(SP)			; AC1,SDESC
	JRST	L.359				; L.359
L.358:	MOVEI	AC1,31				; AC1,31
	MOVE	AC2,-1(SP)			; AC2,SDESC
	MOVE	AC3,-6(SP)			; AC3,TOFFSET
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
L.359:	ADJSP	SP,-20				; SP,-20
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,

; Routine Size:  306 words


;	  2627	                                ! [fun45]-
;	  2628	
;	  2629	ROUTINE CPCOMS(OPCODE,REQVAR): NOVALUE =	! Common string statement
;	  2630	
;	  2631	!++
;	  2632	! Functional description:
;	  2633	!	Called from <Statement> to compile any sort of statement
;	  2634	!	which is merely an operation code with a string argument.
;	  2635	!	The string may be required to be a string identifier, or
;	  2636	!	be allowed to be a string-expression.
;	  2637	!
;	  2638	! Formal parameters:
;	  2639	!	Operation code of the instruction to be generated
;	  2640	!	Switch: Require variable if 1, otherwise permit any string-expression
;	  2641	!
;	  2642	! Implicit inputs:
;	  2643	!	Source
;	  2644	!
;	  2645	! Implicit outputs:
;	  2646	!	Code
;	  2647	!
;	  2648	! Routine value:
;	  2649	!	None
;	  2650	!
;	  2651	! Side effects:
;	  2652	!	Scans from statement keyword to unrecognized atom
;	  2653	!
;	  2654	!--
;	  2655	
;	  2656	    BEGIN
;	  2657	    EXTERNAL REGISTER Z=0;
;	  2658	    SCAN();
;	  2659	    IF .REQVAR NEQ 0 AND .SCACOD NEQ SCN_IDENT AND .SCACOD NEQ SCN_SYSNAME
;	  2660	    THEN
;	  2661		CERROR(CERM3);
;	  2662	    GENINS(.OPCODE,CPSEXP(OPN_TMP_STR),0,0)
;	  2663	    END;


; CPCOMS
U.28:	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,AC2			; REQVAR,AC2
	MOVE	AC13,AC1			; OPCODE,AC1
	PUSHJ	SP,U.3				; SP,SCAN
	JUMPE	AC14,L.360			; REQVAR,L.360
	MOVEI	AC1,1				; AC1,1
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.360				; L.360
	MOVEI	AC1,112				; AC1,112
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.360				; L.360
	MOVEI	AC1,U.53			; AC1,CERM3
	PUSHJ	SP,U.1				; SP,CERROR
L.360:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
	MOVE	AC2,AC1				; AC2,AC1
	MOVE	AC1,AC13			; AC1,OPCODE
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  23 words


;	  2664	
;	  2665	ROUTINE CPPFRM: NOVALUE =	! <DoCommand-statement>
;	  2666	
;	  2667	!++
;	  2668	! Functional description:
;	  2669	!	Called from <Statement> to compile a DoCommand statement.
;	  2670	!
;	  2671	! Formal parameters:
;	  2672	!	None
;	  2673	!
;	  2674	! Implicit inputs:
;	  2675	!	Source
;	  2676	!
;	  2677	! Implicit outputs:
;	  2678	!	Code
;	  2679	!
;	  2680	! Routine value:
;	  2681	!	None
;	  2682	!
;	  2683	! Side effects:
;	  2684	!	Scans from DOCOMMAND to unrecognized atom
;	  2685	!
;	  2686	!--
;	  2687	
;	  2688	    BEGIN
;	  2689	    EXTERNAL REGISTER Z=0;
;	  2690	    LOCAL
;	  2691		OPA,			! Operand descriptors
;	  2692		OPB,
;	  2693		OPC;
;	  2694	    OPB = -1;
;	  2695	    OPC = -1;
;	  2696	    IF SCAN() EQL SCN_ORIGINAL
;	  2697	    THEN
;	  2698		BEGIN
;	  2699		OPB = 0;
;	  2700		SCAN()
;	  2701		END;
;	  2702	    OPA = CPSEXP(OPN_TMP_STR);
;	  2703	    IF .SCACOD EQL SCN_TO
;	  2704	    THEN
;	  2705		BEGIN
;	  2706	!	IF SCAN() NEQ SCN_IDENT THEN CERROR(CERM3);
;	  2707	!	OPC = CPSEXP(OPN_TMP_STR)
;	  2708		IF SCAN() EQL SCN_IDENT
;	  2709		THEN
;	  2710		    OPC = CPSPRM()
;	  2711		ELSE IF .SCACOD EQL SCN_SYSNAME
;	  2712		THEN
;	  2713		    BEGIN
;	  2714	    	    IF .PSDEFN[.SCATOM,SYN_CLS] NEQ SYN_CLS_VAR
;	  2715		    THEN
;	  2716			ERROR('Cannot store into routine');
;	  2717		    IF NOT .PSDEFN[.SCATOM,SYN_WRT]
;	  2718		    THEN
;	  2719			ERROR('Variable is readonly');
;	  2720		    OPC = CPSPRM()	    
;	  2721		    END
;	  2722		ELSE
;	  2723		    CERROR(CERM3);
;	  2724		IF .SCACOD EQL SCN_PLUS
;	  2725		THEN
;	  2726		    ERROR('Complex string expression illegal after TO')
;	  2727		END;
;	  2728	    GENINS(OPR_DCM,.OPA,.OPB,.OPC)
;	  2729	    END;


P.AGR:	BYTE	(7)"C","a","n","n","o"		; Canno
	BYTE	(7)"t"," ","s","t","o"		; t sto
	BYTE	(7)"r","e"," ","i","n"		; re in
	BYTE	(7)"t","o"," ","r","o"		; to ro
	BYTE	(7)"u","t","i","n","e"		; utine
	BYTE	(7)000,000,000,000,000
P.AGS:	BYTE	(7)"V","a","r","i","a"		; Varia
	BYTE	(7)"b","l","e"," ","i"		; ble i
	BYTE	(7)"s"," ","r","e","a"		; s rea
	BYTE	(7)"d","o","n","l","y"		; donly
	BYTE	(7)000,000,000,000,000
P.AGT:	BYTE	(7)"C","o","m","p","l"		; Compl
	BYTE	(7)"e","x"," ","s","t"		; ex st
	BYTE	(7)"r","i","n","g"," "		; ring
	BYTE	(7)"e","x","p","r","e"		; expre
	BYTE	(7)"s","s","i","o","n"		; ssion
	BYTE	(7)" ","i","l","l","e"		;  ille
	BYTE	(7)"g","a","l"," ","a"		; gal a
	BYTE	(7)"f","t","e","r"," "		; fter
	BYTE	(7)"T","O",000,000,000		; TO


; CPPFRM
U.29:	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	SETOB	AC14,AC13			; OPB,OPC
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,57				; AC1,57
	JRST	L.361				; L.361
	SETZ	AC14,				; OPB,
	PUSHJ	SP,U.3				; SP,SCAN
L.361:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
	MOVE	AC12,AC1			; OPA,AC1
	MOVEI	AC1,46				; AC1,46
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.366				; L.366
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,1				; AC1,1
	JRST	L.363				; L.363
	MOVEI	AC1,112				; AC1,112
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.364				; L.364
	MOVE	AC1,U.92			; AC1,SCATOM
	IMULI	AC1,2				; AC1,2
	LDB	AC2,C.31			; AC2,[POINT 3,PSDEFN(AC1),17]  <18,3>
	CAIN	AC2,2				; AC2,2
	JRST	L.362				; L.362
	MOVEI	AC1,P.AGR			; AC1,P.AGR
	PUSHJ	SP,U.1				; SP,CERROR
L.362:	MOVE	AC1,U.92			; AC1,SCATOM
	IMULI	AC1,2				; AC1,2
	MOVSI	AC2,200000			; AC2,200000
	TDNE	AC2,PSDEFN(AC1)			; AC2,PSDEFN(AC1)
	JRST	L.363				; L.363
	MOVEI	AC1,P.AGS			; AC1,P.AGS
	PUSHJ	SP,U.1				; SP,CERROR
L.363:	PUSHJ	SP,U.49				; SP,CPSPRM
	MOVE	AC13,AC1			; OPC,AC1
	JRST	L.365				; L.365
L.364:	MOVEI	AC1,U.53			; AC1,CERM3
	PUSHJ	SP,U.1				; SP,CERROR
L.365:	MOVEI	AC1,4				; AC1,4
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.366				; L.366
	MOVEI	AC1,P.AGT			; AC1,P.AGT
	PUSHJ	SP,U.1				; SP,CERROR
L.366:	MOVEI	AC1,27				; AC1,27
	MOVE	AC2,AC12			; AC2,OPA
	MOVE	AC3,AC14			; AC3,OPB
	MOVE	AC4,AC13			; AC4,OPC
	PUSHJ	SP,U.7				; SP,GENINS
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,

; Routine Size:  54 words


;	  2730	
;	  2731	ROUTINE CPGUID: NOVALUE =	! <Guide-statement>
;	  2732	
;	  2733	!++
;	  2734	! Functional description:
;	  2735	!	Called from <Statement> to compile a Guide statement.
;	  2736	!	It's just an Parse statement, but the FLDDB takes no work.
;	  2737	!
;	  2738	! Formal parameters:
;	  2739	!	None
;	  2740	!
;	  2741	! Implicit inputs:
;	  2742	!	Source
;	  2743	!
;	  2744	! Implicit outputs:
;	  2745	!	Code
;	  2746	!
;	  2747	! Routine value:
;	  2748	!	None
;	  2749	!
;	  2750	! Side effects:
;	  2751	!	Scans from GUIDE to unrecognized atom
;	  2752	!
;	  2753	!--
;	  2754	
;	  2755	    BEGIN
;	  2756	    EXTERNAL REGISTER Z=0;
;	  2757	    LOCAL
;	  2758		FDB;
;	  2759	    IF .CMDARG EQL -1 THEN CMDARG = -2;
;	  2760	    FDB = .CONSTP;
;	  2761	    CONSTP = .CONSTP + $CMBRK + 1;
;	  2762	    CNSWRK[.FDB+$CMFNP] = 0;
;	  2763	    CNSWRK[.FDB+$CMDAT] = 0;
;	  2764	    CNSWRK[.FDB+$CMDEF] = 0;
;	  2765	    CNSWRK[.FDB+$CMHLP] = 0;
;	  2766	    CNSWRK[.FDB+$CMBRK] = 0;
;	  2767	    POINTR((CNSWRK[.FDB+$CMFNP]),CM_FNC) = $CMNOI;
;	  2768	    IF SCAN() NEQ SCN_QSTRING THEN CERROR(CERM19);
;	  2769	    CNSWRK[.FDB+$CMDAT] = CPSPRM();
;	  2770	    CNSWRK[.FDB+$CMBRK] = .NEXTIN + 2;
;	  2771	    GENINS(OPR_PRS,.FDB,0,-1)
;	  2772	    END;


; CPGUID
U.30:	PUSH	SP,AC14				; SP,AC14
	SETO	AC1,				; AC1,
	CAME	AC1,U.85			; AC1,CMDARG
	JRST	L.367				; L.367
	HRROI	AC1,-2				; AC1,-2
	MOVEM	AC1,U.85			; AC1,CMDARG
L.367:	MOVE	AC14,U.97			; FDB,CONSTP
	MOVEI	AC1,5				; AC1,5
	ADDM	AC1,U.97			; AC1,CONSTP
	SETZM	U.78(AC14)			; CNSWRK(FDB)
	SETZM	U.78+1(AC14)			; CNSWRK+1(FDB)
	SETZM	U.78+3(AC14)			; CNSWRK+3(FDB)
	SETZM	U.78+2(AC14)			; CNSWRK+2(FDB)
	SETZM	U.78+4(AC14)			; CNSWRK+4(FDB)
	MOVEI	AC1,2				; AC1,2
	DPB	AC1,C.34			; AC1,[POINT 9,CNSWRK(FDB),8]  <27,9>
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,3				; AC1,3
	JRST	L.368				; L.368
	MOVEI	AC1,U.69			; AC1,CERM19
	PUSHJ	SP,U.1				; SP,CERROR
L.368:	PUSHJ	SP,U.49				; SP,CPSPRM
	MOVEM	AC1,U.78+1(AC14)		; AC1,CNSWRK+1(FDB)
	MOVE	AC1,U.86			; AC1,NEXTIN
	ADDI	AC1,2				; AC1,2
	MOVEM	AC1,U.78+4(AC14)		; AC1,CNSWRK+4(FDB)
	MOVEI	AC1,25				; AC1,25
	MOVE	AC2,AC14			; AC2,FDB
	SETZ	AC3,				; AC3,
	SETO	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,
C.34:	POINT	9,U.78(AC14),8			; 9,CNSWRK(FDB),8

; Routine Size:  34 words


;	  2773	
;	  2774	ROUTINE CPPMPT: NOVALUE =	! <Prompt-statement>
;	  2775	
;	  2776	!++
;	  2777	! Functional description:
;	  2778	!	Compiles a Prompt statement.
;	  2779	!
;	  2780	! Formal parameters:
;	  2781	!	None
;	  2782	!
;	  2783	! Implicit inputs:
;	  2784	!	Source
;	  2785	!
;	  2786	! Implicit outputs:
;	  2787	!	Instruction
;	  2788	!
;	  2789	! Routine value:
;	  2790	!	None
;	  2791	!
;	  2792	! Side effects:
;	  2793	!	Scans from PROMPT to unrecognized atom
;	  2794	!
;	  2795	!--
;	  2796	
;	  2797	    BEGIN
;	  2798	    EXTERNAL REGISTER Z=0;
;	  2799	    LOCAL OPR;			! Operation code to use
;	  2800	    OPR = OPR_PMT;
;	  2801	    IF SCAN() EQL SCN_NOECHO
;	  2802	    THEN
;	  2803		BEGIN
;	  2804		OPR = OPR_PMN;
;	  2805		SCAN();
;	  2806		END;
;	  2807	    GENINS(.OPR,CPSEXP(OPN_TMP_STR),0,0)
;	  2808	    END;


; CPPMPT
U.31:	PUSH	SP,AC14				; SP,AC14
	MOVEI	AC14,51				; OPR,51
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,111				; AC1,111
	JRST	L.369				; L.369
	MOVEI	AC14,52				; OPR,52
	PUSHJ	SP,U.3				; SP,SCAN
L.369:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
	MOVE	AC2,AC1				; AC2,AC1
	MOVE	AC1,AC14			; AC1,OPR
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  15 words


;	  2809	
;	  2810	ROUTINE CPINVK: NOVALUE =	! <Invoke-statement>
;	  2811	
;	  2812	!++
;	  2813	! Functional description:
;	  2814	!	Compile an Invoke statement.
;	  2815	!
;	  2816	! Formal parameters:
;	  2817	!	None
;	  2818	!
;	  2819	! Implicit inputs:
;	  2820	!	Source
;	  2821	!
;	  2822	! Implicit outputs:
;	  2823	!	Instructions
;	  2824	!
;	  2825	! Routine value:
;	  2826	!	None
;	  2827	!
;	  2828	! Side effects:
;	  2829	!	None
;	  2830	!
;	  2831	!--
;	  2832	
;	  2833	    BEGIN
;	  2834	    EXTERNAL REGISTER Z=0;
;	  2835	    LOCAL OPR;
;	  2836	    OPR = OPR_IVP;
;	  2837	    IF SCAN() EQL SCN_PASSOUTPUT
;	  2838	    THEN
;	  2839		BEGIN
;	  2840		OPR = OPR_IVO;
;	  2841		SCAN()
;	  2842		END;
;	  2843	    GENINS(.OPR,CPSEXP(OPN_TMP_STR),0,0)
;	  2844	    END;


; CPINVK
U.32:	PUSH	SP,AC14				; SP,AC14
	MOVEI	AC14,34				; OPR,34
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,114				; AC1,114
	JRST	L.370				; L.370
	MOVEI	AC14,53				; OPR,53
	PUSHJ	SP,U.3				; SP,SCAN
L.370:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
	MOVE	AC2,AC1				; AC2,AC1
	MOVE	AC1,AC14			; AC1,OPR
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  15 words


;	  2845	
;	  2846	ROUTINE CPPRSE: NOVALUE =	! <Parse-statement>
;	  2847	
;	  2848	!++
;	  2849	! Functional description:
;	  2850	!	Called from <Statement> to compile an Parse statement,
;	  2851	!	generating the corresponding list of Field Descriptor Blocks
;	  2852	!	and the Parse instruction referencing it.
;	  2853	!
;	  2854	! Formal parameters:
;	  2855	!	None
;	  2856	!
;	  2857	! Implicit inputs:
;	  2858	!	Source
;	  2859	!
;	  2860	! Implicit outputs:
;	  2861	!	Code, constants
;	  2862	!
;	  2863	! Routine value:
;	  2864	!	None
;	  2865	!
;	  2866	! Side effects:
;	  2867	!	Scans from PARSE to unrecognized atom
;	  2868	!
;	  2869	!--
;	  2870	
;	  2871	    BEGIN
;	  2872	    EXTERNAL REGISTER Z=0;
;	  2873	    LOCAL
;	  2874		PRSINSTR,		! Location of PRS instruction
;	  2875		FAILADDR,		! Location of failure instruction
;	  2876		FDB;			! Constant index of FLDDB list
;	  2877	    IF .CMDARG EQL -1 THEN CMDARG = -2;
;	  2878	    PRSINSTR = GENINS(OPR_PRS,0,0,0);
;	  2879	    GENINS(OPR_JMP,0,0,0);
;	  2880	    FAILADDR = -1;
;	  2881	    SCAN();
;	  2882	    IF (.SCACOD EQL SCN_LPAREN) OR (.SCACOD EQL SCN_BEGIN)
;	  2883	    THEN
;	  2884		BEGIN
;	  2885		LOCAL
;	  2886		    LFDB,		! Last FLDDB built
;	  2887		    NFDB,		! New FLDDB
;	  2888		    FILOPT,		! Whether a File parse is on the list
;	  2889		    PRNHAK;		! Hack flag for old syntax
;	  2890		IF .SCACOD EQL SCN_LPAREN
;	  2891		THEN
;	  2892		    PRNHAK = -1
;	  2893		ELSE
;	  2894		    PRNHAK = 0;
;	  2895		LFDB = -1;
;	  2896		FILOPT = 0;
;	  2897		SCAN();
;	  2898		DO
;	  2899		    BEGIN
;	  2900		    ! Identify the parse-type
;	  2901		    NFDB = CPPRSI(0,.PRSINSTR+2);
;	  2902		    ! Handle OTHERWISE, which must be last before the ")"
;	  2903		    IF .NFDB LSS 0
;	  2904		    THEN
;	  2905			BEGIN
;	  2906			FAILADDR = -.NFDB;
;	  2907			IF .SCACOD EQL SCN_SEMI THEN SCAN();
;	  2908			EXITLOOP
;	  2909			END;
;	  2910		    IF .POINTR((CNSWRK[.NFDB+$CMFNP]),CM_FNC) EQL $CMFIL
;	  2911		    THEN
;	  2912			IF .FILOPT EQL 0
;	  2913			THEN
;	  2914			    FILOPT = -1
;	  2915			ELSE
;	  2916			    ERROR('Cannot have two File fields in one Parse');
;	  2917		    IF .LFDB LSS 0
;	  2918		    THEN
;	  2919			FDB = .NFDB
;	  2920		    ELSE
;	  2921			BEGIN
;	  2922			IF .POINTR((CNSWRK[.LFDB+$CMFNP]),CM_FNC) EQL $CMNOI
;	  2923			THEN
;	  2924			    ERROR('Cannot chain Noise field-type to another type');
;	  2925	                                ! [fun24]+ add DirectoryList function to pcl
;	  2926			IF .POINTR((CNSWRK[.LFDB+$CMFNP]),CM_FNC) EQL $CMFLS or
;	  2927			   .POINTR((CNSWRK[.LFDB+$CMFNP]),CM_FNC) EQL $CMDLS or
;	  2928			   .POINTR((CNSWRK[.LFDB+$CMFNP]),CM_FNC) EQL $CMULS
;	  2929			THEN
;	  2930			    ERROR('Cannot chain Directory/User/File-List field-type to another type');
;	  2931			IF .POINTR((CNSWRK[.NFDB+$CMFNP]),CM_FNC) EQL $CMFLS or
;	  2932			   .POINTR((CNSWRK[.NFDB+$CMFNP]),CM_FNC) EQL $CMDLS or
;	  2933			   .POINTR((CNSWRK[.NFDB+$CMFNP]),CM_FNC) EQL $CMULS 
;	  2934			THEN
;	  2935			    ERROR('Cannot chain any other field-type to Directory/User/File-List');
;	  2936	                                ! [fun24]- add DirectoryList function to pcl
;	  2937			POINTR((CNSWRK[.LFDB+$CMFNP]),CM_LST) = .NFDB
;	  2938			END;
;	  2939		    LFDB = .NFDB;
;	  2940		    IF .SCACOD NEQ SCN_SEMI AND .SCACOD NEQ SCN_RPAREN
;	  2941							    AND .SCACOD NEQ SCN_END
;	  2942		    THEN
;	  2943			CERROR(CERM14);
;	  2944		    IF .SCACOD EQL SCN_SEMI THEN SCAN();
;	  2945		    IF (.PRNHAK NEQ 0) AND (.SCACOD EQL SCN_END)
;	  2946		    THEN
;	  2947			CERROR(CERM14);
;	  2948		    IF (.PRNHAK EQL 0) AND (.SCACOD EQL SCN_RPAREN)
;	  2949		    THEN
;	  2950			CERROR(CERM7)
;	  2951		    END
;	  2952		UNTIL
;	  2953		    .SCACOD EQL SCN_RPAREN OR .SCACOD EQL SCN_END;
;	  2954		SCAN()
;	  2955		END
;	  2956	    ELSE
;	  2957		BEGIN
;	  2958		FDB = CPPRSI(0,.PRSINSTR+2);
;	  2959		IF .FDB LSS 0 THEN ERROR('OTHERWISE meaningless here');
;	  2960		IF .SCACOD NEQ SCN_SEMI AND .SCACOD NEQ SCN_END
;	  2961		    AND .SCACOD NEQ SCN_RPAREN AND .SCACOD NEQ SCN_ELSE
;	  2962		THEN
;	  2963		    ERROR('Garbage following PARSE')
;	  2964		END;
;	  2965	    CODWRK[.PRSINSTR,COD_OPA] = .FDB;
;	  2966	    CODWRK[.PRSINSTR,COD_OPC] = .FAILADDR;
;	  2967	    CODWRK[.PRSINSTR+2,COD_OPA] = .NEXTIN
;	  2968	    END;


P.AGU:	BYTE	(7)"C","a","n","n","o"		; Canno
	BYTE	(7)"t"," ","h","a","v"		; t hav
	BYTE	(7)"e"," ","t","w","o"		; e two
	BYTE	(7)" ","F","i","l","e"		;  File
	BYTE	(7)" ","f","i","e","l"		;  fiel
	BYTE	(7)"d","s"," ","i","n"		; ds in
	BYTE	(7)" ","o","n","e"," "		;  one
	BYTE	(7)"P","a","r","s","e"		; Parse
	BYTE	(7)000,000,000,000,000
P.AGV:	BYTE	(7)"C","a","n","n","o"		; Canno
	BYTE	(7)"t"," ","c","h","a"		; t cha
	BYTE	(7)"i","n"," ","N","o"		; in No
	BYTE	(7)"i","s","e"," ","f"		; ise f
	BYTE	(7)"i","e","l","d","-"		; ield-
	BYTE	(7)"t","y","p","e"," "		; type
	BYTE	(7)"t","o"," ","a","n"		; to an
	BYTE	(7)"o","t","h","e","r"		; other
	BYTE	(7)" ","t","y","p","e"		;  type
	BYTE	(7)000,000,000,000,000
P.AGW:	BYTE	(7)"C","a","n","n","o"		; Canno
	BYTE	(7)"t"," ","c","h","a"		; t cha
	BYTE	(7)"i","n"," ","D","i"		; in Di
	BYTE	(7)"r","e","c","t","o"		; recto
	BYTE	(7)"r","y","/","U","s"		; ry/Us
	BYTE	(7)"e","r","/","F","i"		; er/Fi
	BYTE	(7)"l","e","-","L","i"		; le-Li
	BYTE	(7)"s","t"," ","f","i"		; st fi
	BYTE	(7)"e","l","d","-","t"		; eld-t
	BYTE	(7)"y","p","e"," ","t"		; ype t
	BYTE	(7)"o"," ","a","n","o"		; o ano
	BYTE	(7)"t","h","e","r"," "		; ther
	BYTE	(7)"t","y","p","e",000		; type
P.AGX:	BYTE	(7)"C","a","n","n","o"		; Canno
	BYTE	(7)"t"," ","c","h","a"		; t cha
	BYTE	(7)"i","n"," ","a","n"		; in an
	BYTE	(7)"y"," ","o","t","h"		; y oth
	BYTE	(7)"e","r"," ","f","i"		; er fi
	BYTE	(7)"e","l","d","-","t"		; eld-t
	BYTE	(7)"y","p","e"," ","t"		; ype t
	BYTE	(7)"o"," ","D","i","r"		; o Dir
	BYTE	(7)"e","c","t","o","r"		; ector
	BYTE	(7)"y","/","U","s","e"		; y/Use
	BYTE	(7)"r","/","F","i","l"		; r/Fil
	BYTE	(7)"e","-","L","i","s"		; e-Lis
	BYTE	(7)"t",000,000,000,000		; t
P.AGY:	BYTE	(7)"O","T","H","E","R"		; OTHER
	BYTE	(7)"W","I","S","E"," "		; WISE
	BYTE	(7)"m","e","a","n","i"		; meani
	BYTE	(7)"n","g","l","e","s"		; ngles
	BYTE	(7)"s"," ","h","e","r"		; s her
	BYTE	(7)"e",000,000,000,000		; e
P.AGZ:	BYTE	(7)"G","a","r","b","a"		; Garba
	BYTE	(7)"g","e"," ","f","o"		; ge fo
	BYTE	(7)"l","l","o","w","i"		; llowi
	BYTE	(7)"n","g"," ","P","A"		; ng PA
	BYTE	(7)"R","S","E",000,000		; RSE


; CPPRSE
U.33:	PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,3				; SP,3
	SETO	AC1,				; AC1,
	CAME	AC1,U.85			; AC1,CMDARG
	JRST	L.371				; L.371
	HRROI	AC1,-2				; AC1,-2
	MOVEM	AC1,U.85			; AC1,CMDARG
L.371:	MOVEI	AC1,25				; AC1,25
	SETZB	AC2,AC3				; AC2,AC3
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC12,AC1			; PRSINSTR,AC1
	MOVEI	AC1,32				; AC1,32
	SETZB	AC2,AC3				; AC2,AC3
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
	SETOM	-2(SP)				; FAILADDR
	PUSHJ	SP,U.3				; SP,SCAN
	MOVE	AC11,AC12			; AC11,PRSINSTR
	ADDI	AC11,2				; AC11,2
	MOVE	AC1,U.95			; AC1,SCACOD
	SETZ	AC2,				; AC2,
	CAIE	AC1,16				; AC1,16
	JRST	L.372				; L.372
	MOVEI	AC2,1				; AC2,1
	JRST	L.373				; L.373
L.372:	CAIE	AC1,31				; AC1,31
	JRST	L.391				; L.391
L.373:	TRNN	AC2,1				; AC2,1
	JRST	L.374				; L.374
	SETO	AC10,				; PRNHAK,
	JRST	L.375				; L.375
L.374:	SETZ	AC10,				; PRNHAK,
L.375:	SETO	AC13,				; LFDB,
	SETZM	-1(SP)				; FILOPT
	PUSHJ	SP,U.3				; SP,SCAN
L.376:	SETZ	AC1,				; AC1,
	MOVE	AC2,AC11			; AC2,AC11
	PUSHJ	SP,U.34				; SP,CPPRSI
	MOVE	AC14,AC1			; NFDB,AC1
	JUMPGE	AC14,L.377			; NFDB,L.377
	MOVNM	AC14,-2(SP)			; NFDB,FAILADDR
	MOVEI	AC1,20				; AC1,20
	CAMN	AC1,U.95			; AC1,SCACOD
	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.390				; L.390
L.377:	LDB	AC1,C.34			; AC1,[POINT 9,CNSWRK(AC14),8]  <27,9>
	CAIE	AC1,6				; AC1,6
	JRST	L.379				; L.379
	SKIPE	-1(SP)				; FILOPT
	JRST	L.378				; L.378
	SETOM	-1(SP)				; FILOPT
	JRST	L.379				; L.379
L.378:	MOVEI	AC1,P.AGU			; AC1,P.AGU
	PUSHJ	SP,U.1				; SP,CERROR
L.379:	JUMPGE	AC13,L.380			; LFDB,L.380
	MOVEM	AC14,0(SP)			; NFDB,FDB
	JRST	L.386				; L.386
L.380:	LDB	AC1,C.35			; AC1,[POINT 9,CNSWRK(LFDB),8]  <27,9>
	CAIE	AC1,2				; AC1,2
	JRST	L.381				; L.381
	MOVEI	AC1,P.AGV			; AC1,P.AGV
	PUSHJ	SP,U.1				; SP,CERROR
L.381:	LDB	AC1,C.35			; AC1,[POINT 9,CNSWRK(LFDB),8]  <27,9>
	CAIE	AC1,27				; AC1,27
	CAIN	AC1,30				; AC1,30
	JRST	L.382				; L.382
	CAIE	AC1,31				; AC1,31
	JRST	L.383				; L.383
L.382:	MOVEI	AC1,P.AGW			; AC1,P.AGW
	PUSHJ	SP,U.1				; SP,CERROR
L.383:	LDB	AC1,C.34			; AC1,[POINT 9,CNSWRK(AC14),8]  <27,9>
	CAIE	AC1,27				; AC1,27
	CAIN	AC1,30				; AC1,30
	JRST	L.384				; L.384
	CAIE	AC1,31				; AC1,31
	JRST	L.385				; L.385
L.384:	MOVEI	AC1,P.AGX			; AC1,P.AGX
	PUSHJ	SP,U.1				; SP,CERROR
L.385:	HRRM	AC14,U.78(AC13)			; NFDB,CNSWRK(LFDB)
L.386:	MOVE	AC13,AC14			; LFDB,NFDB
	MOVE	AC1,U.95			; AC1,SCACOD
	CAIE	AC1,20				; AC1,20
	CAIN	AC1,17				; AC1,17
	JRST	L.387				; L.387
	CAIN	AC1,32				; AC1,32
	JRST	L.387				; L.387
	MOVEI	AC1,U.64			; AC1,CERM14
	PUSHJ	SP,U.1				; SP,CERROR
L.387:	MOVEI	AC1,20				; AC1,20
	CAMN	AC1,U.95			; AC1,SCACOD
	PUSHJ	SP,U.3				; SP,SCAN
	JUMPE	AC10,L.388			; PRNHAK,L.388
	MOVEI	AC1,32				; AC1,32
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.388				; L.388
	MOVEI	AC1,U.64			; AC1,CERM14
	PUSHJ	SP,U.1				; SP,CERROR
L.388:	JUMPN	AC10,L.389			; PRNHAK,L.389
	MOVEI	AC1,17				; AC1,17
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.389				; L.389
	MOVEI	AC1,U.57			; AC1,CERM7
	PUSHJ	SP,U.1				; SP,CERROR
L.389:	MOVE	AC1,U.95			; AC1,SCACOD
	CAIN	AC1,17				; AC1,17
	JRST	L.390				; L.390
	CAIE	AC1,32				; AC1,32
	JRST	L.376				; L.376
L.390:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.393				; L.393
L.391:	SETZ	AC1,				; AC1,
	MOVE	AC2,AC11			; AC2,AC11
	PUSHJ	SP,U.34				; SP,CPPRSI
	MOVEM	AC1,0(SP)			; AC1,FDB
	SKIPL	0(SP)				; FDB
	JRST	L.392				; L.392
	MOVEI	AC1,P.AGY			; AC1,P.AGY
	PUSHJ	SP,U.1				; SP,CERROR
L.392:	MOVE	AC1,U.95			; AC1,SCACOD
	CAIE	AC1,20				; AC1,20
	CAIN	AC1,32				; AC1,32
	JRST	L.393				; L.393
	CAIE	AC1,17				; AC1,17
	CAIN	AC1,41				; AC1,41
	JRST	L.393				; L.393
	MOVEI	AC1,P.AGZ			; AC1,P.AGZ
	PUSHJ	SP,U.1				; SP,CERROR
L.393:	MOVE	AC1,0(SP)			; AC1,FDB
	HRRM	AC1,U.76(AC12)			; AC1,CODWRK(PRSINSTR)
	MOVE	AC1,-2(SP)			; AC1,FAILADDR
	HRRM	AC1,U.76+1(AC12)		; AC1,CODWRK+1(PRSINSTR)
	MOVE	AC1,U.86			; AC1,NEXTIN
	HRRM	AC1,U.76(AC11)			; AC1,CODWRK(AC11)
	ADJSP	SP,-3				; SP,-3
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,
C.35:	POINT	9,U.78(AC13),8			; 9,CNSWRK(LFDB),8

; Routine Size:  146 words


;	  2969	
;	  2970	ROUTINE CPPRSI(FLG,DONEAD) =	! <Parse-item>
;	  2971	
;	  2972	!++
;	  2973	! Functional description:
;	  2974	!	  Compiles one item of a Parse list, whether for Command arguments
;	  2975	!	or for a Parse statement.  I build an FLDDB in the constants,
;	  2976	!	containing everything necessary for COMND% but in position-
;	  2977	!	independent form.  If compiling a Parse, I compile any success-
;	  2978	!	statement and set the .CMBRK word to it; if none is requested
;	  2979	!	I set .CMBRK to the done-address passed by my caller.  If compiling
;	  2980	!	Command arguments, I declare any destination-variable and put its
;	  2981	!	symbol index in .CMBRK<LH>, or -1 if none is desired.
;	  2982	!	  In the Parse case, there is a complication:  An OTHERWISE Parse-type
;	  2983	!	does not result in an FLDDB, but only the compilation of its
;	  2984	!	success-statement; in this case I return the negative of the address
;	  2985	!	of the code compiled.
;	  2986	!
;	  2987	! Formal parameters:
;	  2988	!	Flag: 0=Parse, 1=Command arguments
;	  2989	!	Location to jump to after completion of success-statement (Parse)
;	  2990	!
;	  2991	! Implicit inputs:
;	  2992	!	Source
;	  2993	!
;	  2994	! Implicit outputs:
;	  2995	!	Code, constants
;	  2996	!
;	  2997	! Routine value:
;	  2998	!	Constants index of FLDDB, or negative of jump address if
;	  2999	!	    OTHERWISE requested
;	  3000	!
;	  3001	! Side effects:
;	  3002	!	Scans from Parse-type to unrecognized atom
;	  3003	!
;	  3004	!--
;	  3005	
;	  3006	    BEGIN
;	  3007	    EXTERNAL REGISTER Z=0;
;	  3008	    LOCAL
;	  3009		FDB,			! Index of FLDDB being constructed
;	  3010		FNC;			! Function code
;	  3011	%( This should be built symbolically )%
;	  3012	    BIND
;	  3013		TYPTBL = UPLIT(%B'000011110110001111100111000000000000');
;	  3014	    IF .FLG EQL 0
;	  3015	    THEN
;	  3016		IF .SCACOD EQL SCN_OTHERWISE
;	  3017		THEN
;	  3018		    BEGIN
;	  3019		    IF SCAN() NEQ SCN_COLON THEN CERROR(CERM11);
;	  3020		    SCAN();
;	  3021		    FDB = -.NEXTIN;
;	  3022		    IF CPSTMT() EQL FALSE THEN CERROR(CERM12);
;	  3023		    RETURN .FDB
;	  3024		    END;
;	  3025	    ! Identify the field type
;	  3026	    IF .SCACOD NEQ SCN_IDENT THEN CERROR(CERM2);
;	  3027	    FNC =
;	  3028	    (DECR I FROM FNMCNT-1 DO
;	  3029		IF .SCALEN EQL .FNMTBL[.I,RSNLEN] THEN
;	  3030		    IF CH$EQL(	.SCALEN, CH$PTR(SCATOM),
;	  3031				.SCALEN, BYTPTR(.FNMTBL[.I,RSNSTR]))
;	  3032		    THEN
;	  3033			EXITLOOP .I);
;	  3034	    IF .FNC LSS 0 THEN CERROR(CERM2);
;	  3035	    FNC = .FNMTBL[.FNC,RSNSCN];
;	  3036	    IF .FLG NEQ 0
;	  3037	    THEN
;	  3038		IF .FNC EQL $CMCFM THEN ERROR('EOL parse-type invalid');
;	  3039	    ! Allocate the FLDDB
;	  3040	    FDB = .CONSTP;
;	  3041	    CONSTP = .CONSTP + $CMBRK + 1;
;	  3042	    IF .CONSTP GEQ CNSWKL THEN CERROR(CERM1);
;	  3043	    CNSWRK[.FDB+$CMFNP] = 0;
;	  3044	    CNSWRK[.FDB+$CMDAT] = 0;
;	  3045	    CNSWRK[.FDB+$CMHLP] = 0;
;	  3046	    CNSWRK[.FDB+$CMDEF] = 0;
;	  3047	    IF .FLG EQL 0
;	  3048	    THEN
;	  3049		CNSWRK[.FDB+$CMBRK] = .DONEAD
;	  3050	    ELSE
;	  3051		CNSWRK[.FDB+$CMBRK] = -1;
;	  3052	    POINTR((CNSWRK[.FDB+$CMFNP]),CM_FNC) = .FNC;
;	  3053	    IF .FNC EQL $CMTOK OR .FNC EQL $CMNOI
;	  3054	    THEN
;	  3055		BEGIN
;	  3056		IF SCAN() NEQ SCN_QSTRING THEN CERROR(CERM19);
;	  3057		CNSWRK[.FDB+$CMDAT] = CPSPRM()
;	  3058		END
;	  3059	    ELSE
;	  3060		SCAN();
;	  3061	    ! Process options
;	  3062	    IF .SCACOD EQL SCN_LPAREN THEN CPPRSO(.FNC,.FDB,.FLG);
;	  3063	    ! Do some defaulting
;	  3064	    SELECTONE .FNC OF
;	  3065		SET
;	  3066	!
;	  3067	! Mind : if the parsing puts values in word .cmdat,
;	  3068	! YOU MUST PUT SOME CODE IN routine COPFDB to deal with it !!!
;	  3069	! ditto for other words of the fdb.
;	  3070	
;	  3071	[$CMKEY,
;	  3072	 $CMSWI]:   IF .CNSWRK[.FDB+$CMDAT] EQL 0 THEN ERROR('Must provide word list');
;	  3073	[$CMNUM]:   IF .CNSWRK[.FDB+$CMDAT] EQL 0 THEN CNSWRK[.FDB+$CMDAT] = 10;
;	  3074	[$CMTAD]:   IF .CNSWRK[.FDB+$CMDAT] EQL 0
;	  3075		    THEN
;	  3076			CNSWRK[.FDB+$CMDAT] = CM_IDA + CM_ITM;
;	  3077	[$CMFLS]:   begin               ! [fun24]+ add directory list
;	  3078	                pointr((cnswrk[.fdb+$cmfnp]),cm_wld) = 1;
;	  3079	                CPPRSF(.FDB,-1,GJ_IFG)
;	  3080	                end;
;	  3081	[$cmdls,
;	  3082	 $cmuls]:   POINTR((CNSWRK[.FDB+$CMDAT]),CM_DWC) = 1
;	  3083	                                ! [fun24]- Turn wild on
;	  3084		TES;
;	  3085	    IF .SCACOD EQL SCN_COLON
;	  3086	    THEN
;	  3087		IF .FLG EQL 0
;	  3088		THEN
;	  3089		    BEGIN
;	  3090		    ! Compile success-statement
;	  3091		    SCAN();
;	  3092		    CNSWRK[.FDB+$CMBRK] = .NEXTIN;
;	  3093		    IF CPSTMT() EQL FALSE THEN CERROR(CERM9);
;	  3094		    GENINS(OPR_JMP,.DONEAD,0,0)
;	  3095		    END
;	  3096		ELSE
;	  3097		    BEGIN
;	  3098		    ! Define destination identifier
;	  3099		    LOCAL
;	  3100			HLFTMP: HLF_WRD,
;	  3101			STE;		! Symbol table index
;	  3102		    IF SCAN() NEQ SCN_IDENT THEN CERROR(CERM3);
;	  3103		    STE = ADDSMB();
;	  3104		    IF .STE LSS 0 THEN CERROR(CERM4);
;	  3105		    IF .NUMVRS GEQ MAXVRC THEN CERROR(CERM15);
;	  3106		    SYMWRK[.STE,STE_CLS] = STE_CLS_VAR;
;	  3107		    SYMWRK[.STE,STE_LOC] = .NUMVRS + FRM_LOC;
;	  3108		    NUMVRS = .NUMVRS + 1;
;	  3109		    SYMWRK[.STE,STE_TYP] = CH$RCHAR(CH$PTR(TYPTBL,.FNC,1));
;	  3110		    HLFTMP = .CNSWRK[.FDB+$CMBRK];
;	  3111		    HLFTMP[HLF_LFT] = .STE;
;	  3112		    CNSWRK[.FDB+$CMBRK] = .HLFTMP;
;	  3113		    SCAN()
;	  3114		    END;
;	  3115	    .FDB
;	  3116	    END;


P.AHA:	EXP	36617470000
P.AHB:	BYTE	(7)"E","O","L"," ","p"		; EOL p
	BYTE	(7)"a","r","s","e","-"		; arse-
	BYTE	(7)"t","y","p","e"," "		; type
	BYTE	(7)"i","n","v","a","l"		; inval
	BYTE	(7)"i","d",000,000,000		; id
P.AHC:	BYTE	(7)"M","u","s","t"," "		; Must
	BYTE	(7)"p","r","o","v","i"		; provi
	BYTE	(7)"d","e"," ","w","o"		; de wo
	BYTE	(7)"r","d"," ","l","i"		; rd li
	BYTE	(7)"s","t",000,000,000		; st


; TYPTBL
U.110=		    P.AHA


; CPPRSI
U.34:	PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,1				; SP,1
	MOVE	AC10,AC2			; DONEAD,AC2
	MOVE	AC11,AC1			; FLG,AC1
	SETZM	0(SP)				; 0(SP)
	JUMPN	AC11,L.395			; FLG,L.395
	MOVEI	AC1,1				; AC1,1
	MOVEM	AC1,0(SP)			; AC1,0(SP)
	MOVEI	AC1,62				; AC1,62
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.395				; L.395
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,22				; AC1,22
	JRST	L.394				; L.394
	MOVEI	AC1,U.61			; AC1,CERM11
	PUSHJ	SP,U.1				; SP,CERROR
L.394:	PUSHJ	SP,U.3				; SP,SCAN
	MOVN	AC14,U.86			; FDB,NEXTIN
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPN	AC1,L.422			; AC1,L.422
	MOVEI	AC1,U.62			; AC1,CERM12
	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.422				; L.422
L.395:	MOVEI	AC1,1				; AC1,1
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.396				; L.396
	MOVEI	AC1,U.52			; AC1,CERM2
	PUSHJ	SP,U.1				; SP,CERROR
L.396:	MOVEI	AC3,24				; I,24
L.397:	LDB	AC1,C.36			; AC1,[POINT 9,FNMTBL(I),17]  <18,9>
	CAME	AC1,U.93			; AC1,SCALEN
	JRST	L.398				; L.398
	HRRZ	AC5,U.105(AC3)			; HLF,FNMTBL(I)
	HRLI	AC5,-337100			; HLF,-337100
	MOVE	AC1,U.93			; AC1,SCALEN
	MOVE	AC2,C.2				; AC2,[POINT 7,BUF0+11062,34]  <1,7>
	MOVE	AC4,U.93			; AC4,SCALEN
	EXTEND	AC1,C.5				; AC1,[CMPSE ]
	JRST	L.398				; L.398
	MOVE	AC13,AC3			; FNC,I
	JRST	L.399				; L.399
L.398:	SOJGE	AC3,L.397			; I,L.397
	SETO	AC13,				; FNC,
L.399:	JUMPGE	AC13,L.400			; FNC,L.400
	MOVEI	AC1,U.52			; AC1,CERM2
	PUSHJ	SP,U.1				; SP,CERROR
L.400:	LDB	AC13,C.37			; FNC,[POINT 9,FNMTBL(FNC),8]  <27,9>
	JUMPE	AC11,L.401			; FLG,L.401
	CAIE	AC13,10				; FNC,10
	JRST	L.401				; L.401
	MOVEI	AC1,P.AHB			; AC1,P.AHB
	PUSHJ	SP,U.1				; SP,CERROR
L.401:	MOVE	AC14,U.97			; FDB,CONSTP
	MOVEI	AC1,5				; AC1,5
	ADDM	AC1,U.97			; AC1,CONSTP
	MOVEI	AC1,6000			; AC1,6000
	CAMLE	AC1,U.97			; AC1,CONSTP
	JRST	L.402				; L.402
	MOVEI	AC1,U.51			; AC1,CERM1
	PUSHJ	SP,U.1				; SP,CERROR
L.402:	SETZM	U.78(AC14)			; CNSWRK(FDB)
	SETZM	U.78+1(AC14)			; CNSWRK+1(FDB)
	SETZM	U.78+2(AC14)			; CNSWRK+2(FDB)
	SETZM	U.78+3(AC14)			; CNSWRK+3(FDB)
	MOVE	AC2,AC14			; AC2,FDB
	ADD	AC2,C.9				; AC2,[CNSWRK]
	MOVE	AC12,AC2			; AC12,AC2
	ADDI	AC12,4				; AC12,4
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,0(SP)			; AC1,0(SP)
	JRST	L.403				; L.403
	MOVEM	AC10,0(AC12)			; DONEAD,0(AC12)
	JRST	L.404				; L.404
L.403:	SETOM	0(AC12)				; 0(AC12)
L.404:	DPB	AC13,C.34			; FNC,[POINT 9,CNSWRK(AC14),8]  <27,9>
	CAIN	AC13,23				; FNC,23
	JRST	L.405				; L.405
	CAIE	AC13,2				; FNC,2
	JRST	L.407				; L.407
L.405:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,3				; AC1,3
	JRST	L.406				; L.406
	MOVEI	AC1,U.69			; AC1,CERM19
	PUSHJ	SP,U.1				; SP,CERROR
L.406:	PUSHJ	SP,U.49				; SP,CPSPRM
	MOVEM	AC1,U.78+1(AC14)		; AC1,CNSWRK+1(FDB)
	JRST	L.408				; L.408
L.407:	PUSHJ	SP,U.3				; SP,SCAN
L.408:	MOVEI	AC1,16				; AC1,16
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.409				; L.409
	MOVE	AC1,AC13			; AC1,FNC
	MOVE	AC2,AC14			; AC2,FDB
	MOVE	AC3,AC11			; AC3,FLG
	PUSHJ	SP,U.35				; SP,CPPRSO
L.409:	JUMPE	AC13,L.410			; FNC,L.410
	CAIE	AC13,3				; FNC,3
	JRST	L.411				; L.411
L.410:	SKIPE	U.78+1(AC14)			; CNSWRK+1(FDB)
	JRST	L.416				; L.416
	MOVEI	AC1,P.AHC			; AC1,P.AHC
	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.416				; L.416
L.411:	CAIE	AC13,1				; FNC,1
	JRST	L.412				; L.412
	SKIPE	U.78+1(AC14)			; CNSWRK+1(FDB)
	JRST	L.416				; L.416
	MOVEI	AC1,12				; AC1,12
	JRST	L.413				; L.413
L.412:	CAIE	AC13,20				; FNC,20
	JRST	L.414				; L.414
	SKIPE	U.78+1(AC14)			; CNSWRK+1(FDB)
	JRST	L.416				; L.416
	MOVSI	AC1,-200000			; AC1,-200000
L.413:	MOVEM	AC1,U.78+1(AC14)		; AC1,CNSWRK+1(FDB)
	JRST	L.416				; L.416
L.414:	CAIE	AC13,27				; FNC,27
	JRST	L.415				; L.415
	MOVSI	AC1,100				; AC1,100
	IORM	AC1,U.78(AC14)			; AC1,CNSWRK(FDB)
	MOVE	AC1,AC14			; AC1,FDB
	SETO	AC2,				; AC2,
	MOVSI	AC3,100				; AC3,100
	PUSHJ	SP,U.37				; SP,CPPRSF
	JRST	L.416				; L.416
L.415:	CAIL	AC13,30				; FNC,30
	CAILE	AC13,31				; FNC,31
	JRST	L.416				; L.416
	MOVSI	AC1,400000			; AC1,400000
	IORM	AC1,U.78+1(AC14)		; AC1,CNSWRK+1(FDB)
L.416:	MOVEI	AC1,22				; AC1,22
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.422				; L.422
	MOVEI	AC1,1				; AC1,1
	TDNN	AC1,0(SP)			; AC1,0(SP)
	JRST	L.418				; L.418
	PUSHJ	SP,U.3				; SP,SCAN
	MOVE	AC1,U.86			; AC1,NEXTIN
	MOVEM	AC1,0(AC12)			; AC1,0(AC12)
	PUSHJ	SP,U.20				; SP,CPSTMT
	JUMPN	AC1,L.417			; AC1,L.417
	MOVEI	AC1,U.59			; AC1,CERM9
	PUSHJ	SP,U.1				; SP,CERROR
L.417:	MOVEI	AC1,32				; AC1,32
	MOVE	AC2,AC10			; AC2,DONEAD
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	JRST	L.422				; L.422
L.418:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,1				; AC1,1
	JRST	L.419				; L.419
	MOVEI	AC1,U.53			; AC1,CERM3
	PUSHJ	SP,U.1				; SP,CERROR
L.419:	PUSHJ	SP,U.4				; SP,ADDSMB
	MOVE	AC11,AC1			; STE,AC1
	JUMPGE	AC11,L.420			; STE,L.420
	MOVEI	AC1,U.54			; AC1,CERM4
	PUSHJ	SP,U.1				; SP,CERROR
L.420:	MOVEI	AC1,200				; AC1,200
	CAMLE	AC1,U.96			; AC1,NUMVRS
	JRST	L.421				; L.421
	MOVEI	AC1,U.65			; AC1,CERM15
	PUSHJ	SP,U.1				; SP,CERROR
L.421:	MOVE	AC1,AC11			; AC1,STE
	IMULI	AC1,2				; AC1,2
	MOVSI	AC2,70000			; AC2,70000
	ANDCAM	AC2,U.77(AC1)			; AC2,SYMWRK(AC1)
	MOVE	AC2,U.96			; AC2,NUMVRS
	ADDI	AC2,2				; AC2,2
	HRRM	AC2,U.77(AC1)			; AC2,SYMWRK(AC1)
	AOS	U.96				; NUMVRS
	MOVE	AC3,C.38			; AC3,[POINT 1,TYPTBL,-1]  <36,1>
	MOVE	AC2,AC13			; AC2,FNC
	ADJBP	AC2,AC3				; AC2,AC3
	ILDB	AC2,AC2				; AC2,AC2
	DPB	AC2,C.28			; AC2,[POINT 1,SYMWRK(AC1),6]  <29,1>
	MOVE	AC1,0(AC12)			; HLFTMP,0(AC12)
	HRL	AC1,AC11			; HLFTMP,STE
	MOVEM	AC1,0(AC12)			; HLFTMP,0(AC12)
	PUSHJ	SP,U.3				; SP,SCAN
L.422:	MOVE	AC1,AC14			; AC1,FDB
	ADJSP	SP,-1				; SP,-1
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,
C.36:	POINT	9,U.105(AC3),17			; 9,FNMTBL(I),17
C.37:	POINT	9,U.105(AC13),8			; 9,FNMTBL(FNC),8
C.38:	POINT	1,U.110,-1			; 1,TYPTBL,-1

; Routine Size:  195 words


;	  3117	
;	  3118	ROUTINE CPPRSO(FNC,FDB,FLG): NOVALUE =	! <Parse-options>
;	  3119	
;	  3120	!++
;	  3121	! Functional description:
;	  3122	!	Compile Parse options.
;	  3123	!
;	  3124	! Formal parameters:
;	  3125	!	Function code of field being described
;	  3126	!	Constant index of FLDDB being constructed
;	  3127	!	0 if compiling PARSE, 1 if compiling Command arguments
;	  3128	!
;	  3129	! Implicit inputs:
;	  3130	!	Source
;	  3131	!
;	  3132	! Implicit outputs:
;	  3133	!	Constants
;	  3134	!
;	  3135	! Routine value:
;	  3136	!	None
;	  3137	!
;	  3138	! Side effects:
;	  3139	!	Scans from ( to unrecognized atom
;	  3140	!
;	  3141	!--
;	  3142	
;	  3143	    BEGIN
;	  3144	    EXTERNAL REGISTER Z=0;
;	  3145	    DO
;	  3146		BEGIN
;	  3147		SELECTONE SCAN() OF
;	  3148		    SET
;	  3149	[SCN_NOINDIRECT]:
;	  3150			BEGIN
;	  3151			SCAN();
;	  3152			POINTR((CNSWRK[.FDB+$CMFNP]),CM_NIN) = 1
;	  3153			END;
;	  3154	[SCN_DEFAULT]:	BEGIN
;	  3155			SCAN();
;	  3156			CNSWRK[.FDB+$CMDEF] = CPSPRM();
;	  3157			POINTR((CNSWRK[.FDB+$CMFNP]),CM_DPP) = 1
;	  3158			END;
;	  3159	[SCN_HELP]:	BEGIN
;	  3160			SCAN();
;	  3161			CNSWRK[.FDB+$CMHLP] = CPSPRM();
;	  3162			POINTR((CNSWRK[.FDB+$CMFNP]),CM_HPP) = 1;
;	  3163			IF .POINTR((CNSWRK[.FDB+$CMFNP]),CM_SHR) EQL 0
;	  3164			THEN
;	  3165			    POINTR((CNSWRK[.FDB+$CMFNP]),CM_SDH) = 1
;	  3166			END;
;	  3167	[SCN_NOHELP]:	BEGIN
;	  3168			SCAN();
;	  3169			POINTR((CNSWRK[.FDB+$CMFNP]),CM_SDH) = 1
;	  3170			END;
;	  3171	[SCN_WORDS]:	CNSWRK[.FDB+$CMDAT] = CPPRSW(.FNC);
;	  3172	[SCN_RADIX]:	BEGIN
;	  3173			IF .FNC NEQ $CMNUM THEN ERROR('RADIX only for CMNUM fields');
;	  3174			IF SCAN() NEQ SCN_NUMB THEN ERROR('Radix missing');
;	  3175			IF .SCANUM LSS 2 OR .SCANUM GTR 10 THEN ERROR('Illegal radix');
;	  3176			CNSWRK[.FDB+$CMDAT] = .SCANUM;
;	  3177			SCAN()
;	  3178			END;
;	  3179	[SCN_PARSEONLY]:BEGIN
;	  3180			SELECTONE .FNC OF
;	  3181			    SET
;	  3182		[$CMFIL]:   CPPRSF(.FDB,-1,GJ_OFG);
;	  3183		[$CMDEV,
;	  3184		 $CMNOD,
;	  3185		 $CMDIR,
;	  3186		 $CMUSR]:   POINTR((CNSWRK[.FDB+$CMFNP]),CM_PO) = 1;
;	  3187		[OTHERWISE]:ERROR('PARSEONLY meaningless for this field type')
;	  3188			    TES;
;	  3189			SCAN()
;	  3190			END;
;	  3191	[SCN_STDHELP]:	BEGIN
;	  3192			POINTR((CNSWRK[.FDB+$CMFNP]),CM_SDH) = 0;
;	  3193			POINTR((CNSWRK[.FDB+$CMFNP]),CM_SHR) = 1;
;	  3194			SCAN()
;	  3195			END;
;	  3196	[SCN_TIME]:	BEGIN
;	  3197			POINTR((CNSWRK[.FDB+$CMDAT]),CM_ITM) = 1;
;	  3198			SCAN()
;	  3199			END;
;	  3200	[SCN_DATE]:	BEGIN
;	  3201			POINTR((CNSWRK[.FDB+$CMDAT]),CM_IDA) = 1;
;	  3202			SCAN()
;	  3203			END;
;	  3204	[SCN_INPUT]:	BEGIN
;	  3205			IF .FNC NEQ $CMFIL AND .FNC NEQ $CMFLS
;	  3206			THEN
;	  3207			    ERROR('INPUT only for FILE or FILELIST fields');
;	  3208			CPPRSF(.FDB,-1,GJ_OLD);
;	  3209			SCAN()
;	  3210			END;
;	  3211	[SCN_OUTPUT]:	BEGIN
;	  3212			IF .FNC NEQ $CMFIL AND .FNC NEQ $CMFLS
;	  3213			THEN
;	  3214			    ERROR('OUTPUT only for FILE or FILELIST fields');
;	  3215			CPPRSF(.FDB,-1,GJ_FOU);
;	  3216			SCAN()
;	  3217			END;
;	  3218	[SCN_WILD]:	BEGIN
;	  3219	                                ! [fun24]+ add DirectoryList function to pcl
;	  3220	                if .fnc eql $cmdls or .fnc eql $cmuls or
;	  3221	                   .fnc eql $cmdir or .fnc eql $cmusr then
;	  3222	                   pointr((cnswrk[.fdb+$cmdat]),cm_dwc) = 1
;	  3223	                else if .fnc eql $cmfil or .fnc eql $cmfls then begin
;	  3224	                   pointr((cnswrk[.fdb+$cmfnp]),cm_wld) = 1;
;	  3225	                   cpprsf(.fdb,-1,gj_ifg)
;	  3226	                   end
;	  3227	                else
;	  3228			    error('Wild only for File, Directory/User/File-list fields');
;	  3229	
;	  3230	                                ! [fun24]- add DirectoryList function to pcl
;	  3231			SCAN()
;	  3232			END;
;	  3233	[SCN_INVISIBLE]:BEGIN
;	  3234			IF .FNC NEQ $CMFIL AND .FNC NEQ $CMFLS
;	  3235			THEN
;	  3236			    ERROR('INVISIBLE only for FILE and FILELIST fields');
;	  3237			CPPRSF(.FDB,-2,G1_IIN);
;	  3238			SCAN()
;	  3239			END;
;	  3240	[SCN_DELETED]:	BEGIN
;	  3241			IF .FNC NEQ $CMFIL AND .FNC NEQ $CMFLS
;	  3242			THEN
;	  3243			    ERROR('DELETED only for FILE and FILELIST fields');
;	  3244			CPPRSF(.FDB,-1,GJ_DEL);
;	  3245			SCAN()
;	  3246			END;
;	  3247	[SCN_DEFAULT_DEV,
;	  3248	 SCN_DEFAULT_DIR,
;	  3249	 SCN_DEFAULT_NAM,
;	  3250	 SCN_DEFAULT_EXT]:  BEGIN
;	  3251			    LOCAL
;	  3252				COD,	! Scan code
;	  3253				STR;	! String location
;	  3254			    BIND DEF_LST = UPLIT($GJDEV,$GJDIR,$GJNAM,$GJEXT): VECTOR;
;	  3255			    IF .FNC NEQ $CMFIL AND .FNC NEQ $CMFLS
;	  3256			    THEN
;	  3257				ERROR('Only for FILE and FILELIST fields');
;	  3258			    COD = .DEF_LST[.SCACOD-SCN_DEFAULT_DEV];
;	  3259			    SCAN();
;	  3260			    STR = CPSPRM();
;	  3261			    CPPRSF(.FDB,.COD,.STR)
;	  3262			    END;
;	  3263	[SCN_DEFAULT_GEN]:  BEGIN
;	  3264			    LOCAL
;	  3265				CODE;
;	  3266			    IF .FNC NEQ $CMFIL AND .FNC NEQ $CMFLS
;	  3267			    THEN
;	  3268				ERROR('Only for FILE and FILELIST fields');
;	  3269			    SELECTONE SCAN() OF
;	  3270				SET
;	  3271			    [SCN_NUMB]:	CODE = .SCANUM;
;	  3272			    [SCN_PLUS]: CODE = $GJNHG;
;	  3273			    [SCN_MINUS]: CODE = $GJLEG;
;	  3274			    [SCN_TIMES]: CODE = $GJALL;
;	  3275			    [OTHERWISE]: ERROR('Invalid code')
;	  3276				TES;
;	  3277			    CPPRSF(.FDB,$GJGEN,.CODE);
;	  3278			    SCAN()
;	  3279			    END;
;	  3280	[SCN_ERROR]:	IF .FLG EQL 0
;	  3281			THEN
;	  3282			    ERROR('ERROR not permitted here')
;	  3283			ELSE
;	  3284			    BEGIN
;	  3285			    LOCAL
;	  3286				HLFTMP: HLF_WRD,
;	  3287				PTR;
;	  3288			    IF SCAN() NEQ SCN_IDENT THEN CERROR(CERM3);
;	  3289			    PTR =
;	  3290				(DECR I FROM .LBLCNT-1 DO
;	  3291				    IF CH$EQL(	.SCALEN+1,BYTPTR(SCATOM),
;	  3292						.SCALEN+1,.LBLNAM[.I])
;	  3293				    THEN
;	  3294					EXITLOOP .I);
;	  3295			    IF .PTR LSS 0
;	  3296			    THEN
;	  3297				BEGIN
;	  3298				IF .LBLCNT GEQ MAXLBL THEN CERROR(CERM10);
;	  3299				LBLNAM[.LBLCNT] = BYTPTR(PCMGMM((.SCALEN+5)/5, DICT));
;	  3300				CH$MOVE(.SCALEN+1, BYTPTR(SCATOM), .LBLNAM[.LBLCNT]);
;	  3301				LBLADR[.LBLCNT] = - ((2^17) + .FDB + $CMBRK);
;	  3302				LBLCNT = .LBLCNT + 1;
;	  3303				PTR = 0
;	  3304				END
;	  3305			    ELSE
;	  3306			    IF .LBLADR[.PTR] LSS 0
;	  3307			    THEN
;	  3308				BEGIN
;	  3309				LOCAL
;	  3310				    EPTR;
;	  3311				EPTR = -.LBLADR[.PTR];
;	  3312				LBLADR[.PTR] = - ((2^17) + .FDB + $CMBRK);
;	  3313				PTR = .EPTR
;	  3314				END
;	  3315			    ELSE
;	  3316				PTR = .LBLADR[.PTR];
;	  3317			    HLFTMP = .CNSWRK[.FDB+$CMBRK];
;	  3318			    HLFTMP[HLF_RGT] = .PTR;
;	  3319			    CNSWRK[.FDB+$CMBRK] = .HLFTMP;
;	  3320			    SCAN()
;	  3321			    END;
;	  3322	[OTHERWISE]:	ERROR('Parse option not found where required')
;	  3323		    TES
;	  3324		END
;	  3325	    UNTIL
;	  3326		.SCACOD NEQ SCN_COMMA;
;	  3327	    POINTR((CNSWRK[.FDB+$CMFNP]),CM_SHR) = 0;
;	  3328	    IF .SCACOD NEQ SCN_RPAREN
;	  3329	    THEN
;	  3330		ERROR('Garbage found after parse option');
;	  3331	    SCAN()
;	  3332	    END;


P.AHD:	BYTE	(7)"R","A","D","I","X"		; RADIX
	BYTE	(7)" ","o","n","l","y"		;  only
	BYTE	(7)" ","f","o","r"," "		;  for
	BYTE	(7)"C","M","N","U","M"		; CMNUM
	BYTE	(7)" ","f","i","e","l"		;  fiel
	BYTE	(7)"d","s",000,000,000		; ds
P.AHE:	BYTE	(7)"R","a","d","i","x"		; Radix
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g",000,000		; ing
P.AHF:	BYTE	(7)"I","l","l","e","g"		; Illeg
	BYTE	(7)"a","l"," ","r","a"		; al ra
	BYTE	(7)"d","i","x",000,000		; dix
P.AHG:	BYTE	(7)"P","A","R","S","E"		; PARSE
	BYTE	(7)"O","N","L","Y"," "		; ONLY
	BYTE	(7)"m","e","a","n","i"		; meani
	BYTE	(7)"n","g","l","e","s"		; ngles
	BYTE	(7)"s"," ","f","o","r"		; s for
	BYTE	(7)" ","t","h","i","s"		;  this
	BYTE	(7)" ","f","i","e","l"		;  fiel
	BYTE	(7)"d"," ","t","y","p"		; d typ
	BYTE	(7)"e",000,000,000,000		; e
P.AHH:	BYTE	(7)"I","N","P","U","T"		; INPUT
	BYTE	(7)" ","o","n","l","y"		;  only
	BYTE	(7)" ","f","o","r"," "		;  for
	BYTE	(7)"F","I","L","E"," "		; FILE
	BYTE	(7)"o","r"," ","F","I"		; or FI
	BYTE	(7)"L","E","L","I","S"		; LELIS
	BYTE	(7)"T"," ","f","i","e"		; T fie
	BYTE	(7)"l","d","s",000,000		; lds
P.AHI:	BYTE	(7)"O","U","T","P","U"		; OUTPU
	BYTE	(7)"T"," ","o","n","l"		; T onl
	BYTE	(7)"y"," ","f","o","r"		; y for
	BYTE	(7)" ","F","I","L","E"		;  FILE
	BYTE	(7)" ","o","r"," ","F"		;  or F
	BYTE	(7)"I","L","E","L","I"		; ILELI
	BYTE	(7)"S","T"," ","f","i"		; ST fi
	BYTE	(7)"e","l","d","s",000		; elds
P.AHJ:	BYTE	(7)"W","i","l","d"," "		; Wild
	BYTE	(7)"o","n","l","y"," "		; only
	BYTE	(7)"f","o","r"," ","F"		; for F
	BYTE	(7)"i","l","e",","," "		; ile,
	BYTE	(7)"D","i","r","e","c"		; Direc
	BYTE	(7)"t","o","r","y","/"		; tory/
	BYTE	(7)"U","s","e","r","/"		; User/
	BYTE	(7)"F","i","l","e","-"		; File-
	BYTE	(7)"l","i","s","t"," "		; list
	BYTE	(7)"f","i","e","l","d"		; field
	BYTE	(7)"s",000,000,000,000		; s
P.AHK:	BYTE	(7)"I","N","V","I","S"		; INVIS
	BYTE	(7)"I","B","L","E"," "		; IBLE
	BYTE	(7)"o","n","l","y"," "		; only
	BYTE	(7)"f","o","r"," ","F"		; for F
	BYTE	(7)"I","L","E"," ","a"		; ILE a
	BYTE	(7)"n","d"," ","F","I"		; nd FI
	BYTE	(7)"L","E","L","I","S"		; LELIS
	BYTE	(7)"T"," ","f","i","e"		; T fie
	BYTE	(7)"l","d","s",000,000		; lds
P.AHL:	BYTE	(7)"D","E","L","E","T"		; DELET
	BYTE	(7)"E","D"," ","o","n"		; ED on
	BYTE	(7)"l","y"," ","f","o"		; ly fo
	BYTE	(7)"r"," ","F","I","L"		; r FIL
	BYTE	(7)"E"," ","a","n","d"		; E and
	BYTE	(7)" ","F","I","L","E"		;  FILE
	BYTE	(7)"L","I","S","T"," "		; LIST
	BYTE	(7)"f","i","e","l","d"		; field
	BYTE	(7)"s",000,000,000,000		; s
P.AHM:	EXP	2
	EXP	3
	EXP	4
	EXP	5
P.AHN:	BYTE	(7)"O","n","l","y"," "		; Only
	BYTE	(7)"f","o","r"," ","F"		; for F
	BYTE	(7)"I","L","E"," ","a"		; ILE a
	BYTE	(7)"n","d"," ","F","I"		; nd FI
	BYTE	(7)"L","E","L","I","S"		; LELIS
	BYTE	(7)"T"," ","f","i","e"		; T fie
	BYTE	(7)"l","d","s",000,000		; lds
P.AHO:	BYTE	(7)"O","n","l","y"," "		; Only
	BYTE	(7)"f","o","r"," ","F"		; for F
	BYTE	(7)"I","L","E"," ","a"		; ILE a
	BYTE	(7)"n","d"," ","F","I"		; nd FI
	BYTE	(7)"L","E","L","I","S"		; LELIS
	BYTE	(7)"T"," ","f","i","e"		; T fie
	BYTE	(7)"l","d","s",000,000		; lds
P.AHP:	BYTE	(7)"I","n","v","a","l"		; Inval
	BYTE	(7)"i","d"," ","c","o"		; id co
	BYTE	(7)"d","e",000,000,000		; de
P.AHQ:	BYTE	(7)"E","R","R","O","R"		; ERROR
	BYTE	(7)" ","n","o","t"," "		;  not
	BYTE	(7)"p","e","r","m","i"		; permi
	BYTE	(7)"t","t","e","d"," "		; tted
	BYTE	(7)"h","e","r","e",000		; here
P.AHR:	BYTE	(7)"P","a","r","s","e"		; Parse
	BYTE	(7)" ","o","p","t","i"		;  opti
	BYTE	(7)"o","n"," ","n","o"		; on no
	BYTE	(7)"t"," ","f","o","u"		; t fou
	BYTE	(7)"n","d"," ","w","h"		; nd wh
	BYTE	(7)"e","r","e"," ","r"		; ere r
	BYTE	(7)"e","q","u","i","r"		; equir
	BYTE	(7)"e","d",000,000,000		; ed
P.AHS:	BYTE	(7)"G","a","r","b","a"		; Garba
	BYTE	(7)"g","e"," ","f","o"		; ge fo
	BYTE	(7)"u","n","d"," ","a"		; und a
	BYTE	(7)"f","t","e","r"," "		; fter
	BYTE	(7)"p","a","r","s","e"		; parse
	BYTE	(7)" ","o","p","t","i"		;  opti
	BYTE	(7)"o","n",000,000,000		; on


; DEF_LST
U.111=		    P.AHM


; CPPRSO
U.35:	PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC10,AC3			; FLG,AC3
	MOVE	AC14,AC2			; FDB,AC2
	MOVE	AC11,AC1			; FNC,AC1
L.423:	PUSHJ	SP,U.3				; SP,SCAN
	MOVE	AC13,AC1			; AC13,AC1
	CAIE	AC13,63				; AC13,63
	JRST	L.424				; L.424
	PUSHJ	SP,U.3				; SP,SCAN
	MOVSI	AC1,400				; AC1,400
	JRST	L.428				; L.428
L.424:	CAIE	AC13,64				; AC13,64
	JRST	L.425				; L.425
	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.49				; SP,CPSPRM
	MOVEM	AC1,U.78+3(AC14)		; AC1,CNSWRK+3(FDB)
	MOVSI	AC1,2				; AC1,2
	JRST	L.428				; L.428
L.425:	CAIE	AC13,65				; AC13,65
	JRST	L.426				; L.426
	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.49				; SP,CPSPRM
	MOVEM	AC1,U.78+2(AC14)		; AC1,CNSWRK+2(FDB)
	MOVSI	AC1,4				; AC1,4
	IORM	AC1,U.78(AC14)			; AC1,CNSWRK(FDB)
	LDB	AC1,C.39			; AC1,[POINT 1,CNSWRK(FDB),10]  <25,1>
	JUMPN	AC1,L.481			; AC1,L.481
	JRST	L.427				; L.427
L.426:	CAIE	AC13,66				; AC13,66
	JRST	L.429				; L.429
	PUSHJ	SP,U.3				; SP,SCAN
L.427:	MOVSI	AC1,1				; AC1,1
L.428:	IORM	AC1,U.78(AC14)			; AC1,CNSWRK(FDB)
	JRST	L.481				; L.481
L.429:	CAIE	AC13,67				; AC13,67
	JRST	L.430				; L.430
	MOVE	AC1,AC11			; AC1,FNC
	PUSHJ	SP,U.36				; SP,CPPRSW
	MOVEM	AC1,U.78+1(AC14)		; AC1,CNSWRK+1(FDB)
	JRST	L.481				; L.481
L.430:	CAIE	AC13,70				; AC13,70
	JRST	L.435				; L.435
	CAIN	AC11,1				; FNC,1
	JRST	L.431				; L.431
	MOVEI	AC1,P.AHD			; AC1,P.AHD
	PUSHJ	SP,U.1				; SP,CERROR
L.431:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,2				; AC1,2
	JRST	L.432				; L.432
	MOVEI	AC1,P.AHE			; AC1,P.AHE
	PUSHJ	SP,U.1				; SP,CERROR
L.432:	MOVE	AC1,U.94			; AC1,SCANUM
	CAIGE	AC1,2				; AC1,2
	JRST	L.433				; L.433
	CAIG	AC1,12				; AC1,12
	JRST	L.434				; L.434
L.433:	MOVEI	AC1,P.AHF			; AC1,P.AHF
	PUSHJ	SP,U.1				; SP,CERROR
L.434:	MOVE	AC1,U.94			; AC1,SCANUM
	MOVEM	AC1,U.78+1(AC14)		; AC1,CNSWRK+1(FDB)
	JRST	L.478				; L.478
L.435:	CAIE	AC13,71				; AC13,71
	JRST	L.440				; L.440
	CAIE	AC11,6				; FNC,6
	JRST	L.436				; L.436
	MOVE	AC1,AC14			; AC1,FDB
	SETO	AC2,				; AC2,
	MOVSI	AC3,40				; AC3,40
	JRST	L.467				; L.467
L.436:	CAIGE	AC11,11				; FNC,11
	JRST	L.437				; L.437
	CAIG	AC11,12				; FNC,12
	JRST	L.438				; L.438
L.437:	CAIE	AC11,16				; FNC,16
	CAIN	AC11,26				; FNC,26
	JRST	L.438				; L.438
	JRST	L.439				; L.439
L.438:	MOVSI	AC1,10				; AC1,10
	JRST	L.441				; L.441
L.439:	MOVEI	AC1,P.AHG			; AC1,P.AHG
	JRST	L.453				; L.453
L.440:	CAIE	AC13,72				; AC13,72
	JRST	L.442				; L.442
	MOVSI	AC1,1				; AC1,1
	ANDCAM	AC1,U.78(AC14)			; AC1,CNSWRK(FDB)
	MOVSI	AC1,200				; AC1,200
L.441:	IORM	AC1,U.78(AC14)			; AC1,CNSWRK(FDB)
	JRST	L.478				; L.478
L.442:	CAIE	AC13,73				; AC13,73
	JRST	L.443				; L.443
	MOVSI	AC1,200000			; AC1,200000
	JRST	L.449				; L.449
L.443:	CAIN	AC13,74				; AC13,74
	JRST	L.448				; L.448
	CAIE	AC13,102			; AC13,102
	JRST	L.445				; L.445
	CAIE	AC11,6				; FNC,6
	CAIN	AC11,27				; FNC,27
	JRST	L.444				; L.444
	MOVEI	AC1,P.AHH			; AC1,P.AHH
	PUSHJ	SP,U.1				; SP,CERROR
L.444:	MOVE	AC1,AC14			; AC1,FDB
	SETO	AC2,				; AC2,
	MOVSI	AC3,100000			; AC3,100000
	JRST	L.467				; L.467
L.445:	CAIE	AC13,103			; AC13,103
	JRST	L.447				; L.447
	CAIE	AC11,6				; FNC,6
	CAIN	AC11,27				; FNC,27
	JRST	L.446				; L.446
	MOVEI	AC1,P.AHI			; AC1,P.AHI
	PUSHJ	SP,U.1				; SP,CERROR
L.446:	MOVE	AC1,AC14			; AC1,FDB
	SETO	AC2,				; AC2,
	MOVSI	AC3,400000			; AC3,400000
	JRST	L.467				; L.467
L.447:	CAIE	AC13,104			; AC13,104
	JRST	L.454				; L.454
	CAIE	AC11,30				; FNC,30
	CAIN	AC11,31				; FNC,31
	JRST	L.448				; L.448
	CAIN	AC11,11				; FNC,11
	JRST	L.448				; L.448
	CAIE	AC11,12				; FNC,12
	JRST	L.450				; L.450
L.448:	MOVSI	AC1,400000			; AC1,400000
L.449:	IORM	AC1,U.78+1(AC14)		; AC1,CNSWRK+1(FDB)
	JRST	L.478				; L.478
L.450:	CAIN	AC11,6				; FNC,6
	JRST	L.451				; L.451
	CAIE	AC11,27				; FNC,27
	JRST	L.452				; L.452
L.451:	MOVSI	AC1,100				; AC1,100
	IORM	AC1,U.78(AC14)			; AC1,CNSWRK(FDB)
	MOVE	AC1,AC14			; AC1,FDB
	SETO	AC2,				; AC2,
	MOVSI	AC3,100				; AC3,100
	JRST	L.467				; L.467
L.452:	MOVEI	AC1,P.AHJ			; AC1,P.AHJ
L.453:	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.478				; L.478
L.454:	CAIE	AC13,105			; AC13,105
	JRST	L.456				; L.456
	CAIE	AC11,6				; FNC,6
	CAIN	AC11,27				; FNC,27
	JRST	L.455				; L.455
	MOVEI	AC1,P.AHK			; AC1,P.AHK
	PUSHJ	SP,U.1				; SP,CERROR
L.455:	MOVE	AC1,AC14			; AC1,FDB
	HRROI	AC2,-2				; AC2,-2
	MOVSI	AC3,10000			; AC3,10000
	JRST	L.467				; L.467
L.456:	CAIE	AC13,106			; AC13,106
	JRST	L.458				; L.458
	CAIE	AC11,6				; FNC,6
	CAIN	AC11,27				; FNC,27
	JRST	L.457				; L.457
	MOVEI	AC1,P.AHL			; AC1,P.AHL
	PUSHJ	SP,U.1				; SP,CERROR
L.457:	MOVE	AC1,AC14			; AC1,FDB
	SETO	AC2,				; AC2,
	MOVSI	AC3,1000			; AC3,1000
	JRST	L.467				; L.467
L.458:	CAIL	AC13,75				; AC13,75
	CAILE	AC13,100			; AC13,100
	JRST	L.460				; L.460
	CAIE	AC11,6				; FNC,6
	CAIN	AC11,27				; FNC,27
	JRST	L.459				; L.459
	MOVEI	AC1,P.AHN			; AC1,P.AHN
	PUSHJ	SP,U.1				; SP,CERROR
L.459:	MOVE	AC1,U.95			; AC1,SCACOD
	MOVE	AC12,U.111-75(AC1)		; COD,DEF_LST-75(AC1)
	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.49				; SP,CPSPRM
	MOVE	AC3,AC1				; STR,AC1
	MOVE	AC1,AC14			; AC1,FDB
	MOVE	AC2,AC12			; AC2,COD
	PUSHJ	SP,U.37				; SP,CPPRSF
	JRST	L.481				; L.481
L.460:	CAIE	AC13,101			; AC13,101
	JRST	L.468				; L.468
	CAIE	AC11,6				; FNC,6
	CAIN	AC11,27				; FNC,27
	JRST	L.461				; L.461
	MOVEI	AC1,P.AHO			; AC1,P.AHO
	PUSHJ	SP,U.1				; SP,CERROR
L.461:	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,2				; AC1,2
	JRST	L.462				; L.462
	MOVE	AC12,U.94			; CODE,SCANUM
	JRST	L.466				; L.466
L.462:	CAIE	AC1,4				; AC1,4
	JRST	L.463				; L.463
	MOVEI	AC12,-1				; CODE,-1
	JRST	L.466				; L.466
L.463:	CAIE	AC1,5				; AC1,5
	JRST	L.464				; L.464
	MOVEI	AC12,-2				; CODE,-2
	JRST	L.466				; L.466
L.464:	CAIE	AC1,6				; AC1,6
	JRST	L.465				; L.465
	MOVEI	AC12,-3				; CODE,-3
	JRST	L.466				; L.466
L.465:	MOVEI	AC1,P.AHP			; AC1,P.AHP
	PUSHJ	SP,U.1				; SP,CERROR
L.466:	MOVE	AC1,AC14			; AC1,FDB
	SETZ	AC2,				; AC2,
	MOVE	AC3,AC12			; AC3,CODE
L.467:	PUSHJ	SP,U.37				; SP,CPPRSF
	JRST	L.478				; L.478
L.468:	CAIE	AC13,107			; AC13,107
	JRST	L.479				; L.479
	JUMPN	AC10,L.469			; FLG,L.469
	MOVEI	AC1,P.AHQ			; AC1,P.AHQ
	JRST	L.480				; L.480
L.469:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,1				; AC1,1
	JRST	L.470				; L.470
	MOVEI	AC1,U.53			; AC1,CERM3
	PUSHJ	SP,U.1				; SP,CERROR
L.470:	MOVE	AC12,U.101			; AC12,LBLCNT
	MOVE	AC3,U.93			; AC3,SCALEN
	ADDI	AC3,1				; AC3,1
	MOVE	AC13,AC12			; I,AC12
	JRST	L.472				; L.472
L.471:	MOVE	AC2,C.3				; HLF,[SCATOM]
	HRLI	AC2,-337100			; HLF,-337100
	MOVE	AC1,AC3				; AC1,AC3
	MOVE	AC4,AC3				; AC4,AC3
	MOVE	AC5,U.99(AC13)			; AC5,LBLNAM(I)
	EXTEND	AC1,C.5				; AC1,[CMPSE ]
	JRST	L.472				; L.472
	JRST	L.473				; L.473
L.472:	SOJGE	AC13,L.471			; I,L.471
	SETO	AC13,				; PTR,
L.473:	JUMPGE	AC13,L.475			; PTR,L.475
	CAIGE	AC12,24				; AC12,24
	JRST	L.474				; L.474
	MOVEI	AC1,U.60			; AC1,CERM10
	PUSHJ	SP,U.1				; SP,CERROR
L.474:	MOVE	AC12,U.101			; AC12,LBLCNT
	MOVE	AC1,U.93			; AC1,SCALEN
	ADDI	AC1,5				; AC1,5
	IDIVI	AC1,5				; AC1,5
	MOVEI	AC2,DICT			; AC2,DICT
	PUSHJ	SP,PCMGMM			; SP,PCMGMM
	HRLI	AC1,-337100			; HLF,-337100
	MOVEM	AC1,U.99(AC12)			; HLF,LBLNAM(AC12)
	MOVE	AC1,U.93			; AC1,SCALEN
	ADDI	AC1,1				; AC1,1
	MOVE	AC2,C.3				; HLF,[SCATOM]
	HRLI	AC2,-337100			; HLF,-337100
	MOVE	AC3,U.101			; AC3,LBLCNT
	MOVE	AC4,AC1				; AC4,AC1
	MOVE	AC5,U.99(AC3)			; AC5,LBLNAM(AC3)
	EXTEND	AC1,C.12			; AC1,[MOVSLJ ]
	JFCL					; 
	MOVE	AC2,AC14			; AC2,FDB
	ADD	AC2,C.40			; AC2,[1000004]
	MOVNM	AC2,U.100(AC3)			; AC2,LBLADR(AC3)
	AOS	U.101				; LBLCNT
	SETZ	AC13,				; PTR,
	JRST	L.477				; L.477
L.475:	MOVE	AC1,U.100(AC13)			; AC1,LBLADR(PTR)
	JUMPGE	AC1,L.476			; AC1,L.476
	MOVN	AC1,AC1				; EPTR,AC1
	MOVE	AC2,AC14			; AC2,FDB
	ADD	AC2,C.40			; AC2,[1000004]
	MOVNM	AC2,U.100(AC13)			; AC2,LBLADR(PTR)
L.476:	MOVE	AC13,AC1			; PTR,AC1
L.477:	MOVE	AC1,U.78+4(AC14)		; HLFTMP,CNSWRK+4(FDB)
	HRR	AC1,AC13			; HLFTMP,PTR
	MOVEM	AC1,U.78+4(AC14)		; HLFTMP,CNSWRK+4(FDB)
L.478:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.481				; L.481
L.479:	MOVEI	AC1,P.AHR			; AC1,P.AHR
L.480:	PUSHJ	SP,U.1				; SP,CERROR
L.481:	MOVEI	AC1,21				; AC1,21
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.423				; L.423
	MOVSI	AC1,200				; AC1,200
	ANDCAM	AC1,U.78(AC14)			; AC1,CNSWRK(FDB)
	MOVEI	AC1,17				; AC1,17
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.482				; L.482
	MOVEI	AC1,P.AHS			; AC1,P.AHS
	PUSHJ	SP,U.1				; SP,CERROR
L.482:	PUSHJ	SP,U.3				; SP,SCAN
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,
C.39:	POINT	1,U.78(AC14),10			; 1,CNSWRK(FDB),10
C.40:	EXP	1000004				; 1000004

; Routine Size:  301 words


;	  3333	
;	  3334	ROUTINE CPPRSW(FNC) =	! <Parse-option> WORDS
;	  3335	
;	  3336	!++
;	  3337	! Functional description:
;	  3338	!	Defines keyword table for Words option.
;	  3339	!
;	  3340	! Formal parameters:
;	  3341	!	Function code for field descriptor block being generated
;	  3342	!
;	  3343	! Implicit inputs:
;	  3344	!	Source
;	  3345	!
;	  3346	! Implicit outputs:
;	  3347	!	Constants
;	  3348	!
;	  3349	! Routine value:
;	  3350	!	Constant index of keyword table
;	  3351	!
;	  3352	! Side effects:
;	  3353	!	Scans from WORDS past final right parenthesis
;	  3354	!
;	  3355	!--
;	  3356	
;	  3357	    BEGIN
;	  3358	    EXTERNAL REGISTER Z=0;
;	  3359	    LOCAL
;	  3360	        PTR,			! Word index
;	  3361		IPTR,			! Byte pointers
;	  3362		OPTR,
;	  3363		CHR,
;	  3364		HLFTMP: HLF_WRD,	! Temporary
;	  3365		TBL,			! Table pointer
;	  3366		WTBL: VECTOR[100],	! Word pointers
;	  3367		VTBL: VECTOR[100];	! Word values
;	  3368	    IF .FNC NEQ $CMKEY AND .FNC NEQ $CMSWI
;	  3369	    THEN
;	  3370		ERROR('Word list only for keywords and switches');
;	  3371	    IF SCAN() NEQ SCN_LPAREN THEN CERROR(CERM16);
;	  3372		
;	  3373	    PTR = -1;		
;	  3374	    DO
;	  3375		BEGIN
;	  3376		SCATRP = -1;
;	  3377		IF SCAN() NEQ SCN_IDENT AND .SCACOD NEQ SCN_NUMB
;	  3378	           and .scacod neq scn_qstring  ! [fun47] Allow quoted string in 
;	  3379		THEN
;	  3380		    ERROR('Word missing');
;	  3381		SCATRP = 0;
;	  3382		IF .SCACOD EQL SCN_NUMB
;	  3383		THEN
;	  3384		    CH$WCHAR($CHNUL, PCMITS(.SCANUM,BYTPTR(SCATOM)));
;	  3385		IF SCAN() NEQ SCN_COLON THEN CERROR(CERM11);
;	  3386		IPTR = CH$PTR(SCATOM);
;	  3387		OPTR = .IPTR;
;	  3388		DO
;	  3389		    BEGIN
;	  3390		    CHR = CH$RCHAR_A(IPTR);
;	  3391		    IF .CHR EQL %C'_' THEN CHR = %C'-';
;	  3392		    CH$WCHAR_A(.CHR,OPTR)
;	  3393		    END
;	  3394		UNTIL
;	  3395		    .CHR EQL $CHNUL;
;	  3396		IF SCAN() EQL SCN_COLON
;	  3397		THEN
;	  3398		    BEGIN
;	  3399		    CH$WCHAR(%C':',CH$PTR(SCATOM,.SCALEN));
;	  3400		    SCALEN = .SCALEN + 1;
;	  3401		    SCAN();
;	  3402		    END;
;	  3403		PTR = .PTR + 1;
;	  3404		IF .PTR GTR 100 THEN ERROR('Too many keywords');
;	  3405		IF .CONSTP + (.SCALEN+5)/5 GTR CNSWKL
;	  3406		THEN
;	  3407		    CERROR(CERM1);
;	  3408		CH$COPY(.SCALEN,CH$PTR(SCATOM),
;	  3409		        0,.SCALEN+1,CH$PTR(CNSWRK[.CONSTP]));
;	  3410		WTBL[.PTR] = .CONSTP;
;	  3411		CONSTP = .CONSTP + (.SCALEN+5)/5;
;	  3412		IF .SCACOD EQL SCN_MINUS
;	  3413		THEN
;	  3414		    BEGIN
;	  3415		    IF SCAN() NEQ SCN_NUMB THEN ERROR('Word value missing');
;	  3416		    IF .SCANUM GEQ %O'1000000'
;	  3417		    THEN
;	  3418			ERROR('Word value must be greater than -262144');
;	  3419		    SCANUM = -.SCANUM
;	  3420		    END
;	  3421		ELSE
;	  3422		    BEGIN
;	  3423		    IF .SCACOD NEQ SCN_NUMB THEN ERROR('Word value missing');
;	  3424		    IF .SCANUM GEQ %O'777777'
;	  3425		    THEN
;	  3426			ERROR('Word value must be less than 262143')
;	  3427		    END;
;	  3428		VTBL[.PTR] = .SCANUM AND %O'777777' ! Make halfword even if negative
;	  3429		END
;	  3430	    UNTIL
;	  3431		SCAN() NEQ SCN_COMMA;
;	  3432	    IF .SCACOD NEQ SCN_RPAREN THEN CERROR(CERM14);
;	  3433	    SCAN();
;	  3434	    IF .CONSTP + .PTR +2 GEQ CNSWKL
;	  3435	    THEN
;	  3436		CERROR(CERM1);
;	  3437	    TBL = .CONSTP;
;	  3438	    CONSTP = .CONSTP + .PTR + 2;
;	  3439	    CNSWRK[.TBL] = .PTR + 1;
;	  3440	%( Must be a better way to alphabetize the table )%
;	  3441	    DECR I FROM .PTR DO
;	  3442		BEGIN
;	  3443		REGISTER R1=1,R2=2;
;	  3444		BUILTIN JSYS;
;	  3445		R1 = CNSWRK[.TBL];
;	  3446		R2 = CNSWRK[.WTBL[.I]]^18 + .VTBL[.I];
;	  3447		JSYS(-1,TBADD,R1,R2)
;	  3448		END;
;	  3449	    DECR I FROM .PTR DO
;	  3450		BEGIN
;	  3451		HLFTMP = .CNSWRK[.TBL+.I+1];
;	  3452		HLFTMP[HLF_LFT] = .HLFTMP[HLF_LFT] - CNSWRK;
;	  3453		CNSWRK[.TBL+.I+1] = .HLFTMP
;	  3454		END;
;	  3455	    .TBL
;	  3456	    END;


P.AHT:	BYTE	(7)"W","o","r","d"," "		; Word
	BYTE	(7)"l","i","s","t"," "		; list
	BYTE	(7)"o","n","l","y"," "		; only
	BYTE	(7)"f","o","r"," ","k"		; for k
	BYTE	(7)"e","y","w","o","r"		; eywor
	BYTE	(7)"d","s"," ","a","n"		; ds an
	BYTE	(7)"d"," ","s","w","i"		; d swi
	BYTE	(7)"t","c","h","e","s"		; tches
	BYTE	(7)000,000,000,000,000
P.AHU:	BYTE	(7)"W","o","r","d"," "		; Word
	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g",000,000,000		; ng
P.AHV:	BYTE	(7)"T","o","o"," ","m"		; Too m
	BYTE	(7)"a","n","y"," ","k"		; any k
	BYTE	(7)"e","y","w","o","r"		; eywor
	BYTE	(7)"d","s",000,000,000		; ds
P.AHW:	BYTE	(7)"W","o","r","d"," "		; Word
	BYTE	(7)"v","a","l","u","e"		; value
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g",000,000		; ing
P.AHX:	BYTE	(7)"W","o","r","d"," "		; Word
	BYTE	(7)"v","a","l","u","e"		; value
	BYTE	(7)" ","m","u","s","t"		;  must
	BYTE	(7)" ","b","e"," ","g"		;  be g
	BYTE	(7)"r","e","a","t","e"		; reate
	BYTE	(7)"r"," ","t","h","a"		; r tha
	BYTE	(7)"n"," ","-","2","6"		; n -26
	BYTE	(7)"2","1","4","4",000		; 2144
P.AHY:	BYTE	(7)"W","o","r","d"," "		; Word
	BYTE	(7)"v","a","l","u","e"		; value
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g",000,000		; ing
P.AHZ:	BYTE	(7)"W","o","r","d"," "		; Word
	BYTE	(7)"v","a","l","u","e"		; value
	BYTE	(7)" ","m","u","s","t"		;  must
	BYTE	(7)" ","b","e"," ","l"		;  be l
	BYTE	(7)"e","s","s"," ","t"		; ess t
	BYTE	(7)"h","a","n"," ","2"		; han 2
	BYTE	(7)"6","2","1","4","3"		; 62143
	BYTE	(7)000,000,000,000,000


; CPPRSW
U.36:	PUSH	SP,AC10				; SP,AC10
	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,310				; SP,310
	JUMPE	AC1,L.483			; FNC,L.483
	CAIN	AC1,3				; FNC,3
	JRST	L.483				; L.483
	MOVEI	AC1,P.AHT			; AC1,P.AHT
	PUSHJ	SP,U.1				; SP,CERROR
L.483:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,16				; AC1,16
	JRST	L.484				; L.484
	MOVEI	AC1,U.66			; AC1,CERM16
	PUSHJ	SP,U.1				; SP,CERROR
L.484:	SETO	AC13,				; PTR,
L.485:	SETOM	U.90				; SCATRP
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,1				; AC1,1
	JRST	L.486				; L.486
	MOVEI	AC1,2				; AC1,2
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.486				; L.486
	MOVEI	AC1,3				; AC1,3
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.486				; L.486
	MOVEI	AC1,P.AHU			; AC1,P.AHU
	PUSHJ	SP,U.1				; SP,CERROR
L.486:	SETZM	U.90				; SCATRP
	MOVEI	AC1,2				; AC1,2
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.487				; L.487
	SETZ	AC14,				; AC14,
	MOVE	AC2,C.3				; HLF,[SCATOM]
	HRLI	AC2,-337100			; HLF,-337100
	MOVE	AC1,U.94			; AC1,SCANUM
	PUSHJ	SP,PCMITS			; SP,PCMITS
	IDPB	AC14,AC1			; AC14,AC1
L.487:	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,22				; AC1,22
	JRST	L.488				; L.488
	MOVEI	AC1,U.61			; AC1,CERM11
	PUSHJ	SP,U.1				; SP,CERROR
L.488:	MOVE	AC11,C.2			; IPTR,[POINT 7,BUF0+11062,34]  <1,7>
	MOVE	AC10,AC11			; OPTR,IPTR
L.489:	ILDB	AC12,AC11			; CHR,IPTR
	CAIN	AC12,137			; CHR,137
	MOVEI	AC12,55				; CHR,55
	IDPB	AC12,AC10			; CHR,OPTR
	JUMPN	AC12,L.489			; CHR,L.489
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,22				; AC1,22
	JRST	L.490				; L.490
	MOVEI	AC2,72				; AC2,72
	MOVE	AC3,C.41			; AC3,[POINT 7,SCATOM,-1]  <36,7>
	MOVE	AC1,U.93			; AC1,SCALEN
	ADJBP	AC1,AC3				; AC1,AC3
	IDPB	AC2,AC1				; AC2,AC1
	AOS	U.93				; SCALEN
	PUSHJ	SP,U.3				; SP,SCAN
L.490:	ADDI	AC13,1				; PTR,1
	CAIG	AC13,144			; PTR,144
	JRST	L.491				; L.491
	MOVEI	AC1,P.AHV			; AC1,P.AHV
	PUSHJ	SP,U.1				; SP,CERROR
L.491:	MOVE	AC1,U.93			; AC1,SCALEN
	ADDI	AC1,5				; AC1,5
	IDIVI	AC1,5				; AC1,5
	ADD	AC1,U.97			; AC1,CONSTP
	CAIG	AC1,6000			; AC1,6000
	JRST	L.492				; L.492
	MOVEI	AC1,U.51			; AC1,CERM1
	PUSHJ	SP,U.1				; SP,CERROR
L.492:	MOVE	AC4,U.93			; AC4,SCALEN
	ADDI	AC4,1				; AC4,1
	MOVE	AC3,U.97			; AC3,CONSTP
	MOVEI	AC5,U.78-1(AC3)			; AC5,CNSWRK-1(AC3)
	HRLI	AC5,10700			; AC5,10700
	MOVE	AC1,U.93			; AC1,SCALEN
	MOVE	AC2,C.2				; AC2,[POINT 7,BUF0+11062,34]  <1,7>
	EXTEND	AC1,C.8				; AC1,C.8
	JFCL					; 
	MOVEI	AC1,-307(SP)			; AC1,WTBL
	ADD	AC1,AC13			; AC1,PTR
	MOVEM	AC3,0(AC1)			; AC3,0(AC1)
	MOVE	AC1,U.93			; AC1,SCALEN
	ADDI	AC1,5				; AC1,5
	IDIVI	AC1,5				; AC1,5
	ADDM	AC1,U.97			; AC1,CONSTP
	MOVE	AC14,U.95			; AC14,SCACOD
	CAIE	AC14,5				; AC14,5
	JRST	L.495				; L.495
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,2				; AC1,2
	JRST	L.493				; L.493
	MOVEI	AC1,P.AHW			; AC1,P.AHW
	PUSHJ	SP,U.1				; SP,CERROR
L.493:	MOVSI	AC1,1				; AC1,1
	CAMLE	AC1,U.94			; AC1,SCANUM
	JRST	L.494				; L.494
	MOVEI	AC1,P.AHX			; AC1,P.AHX
	PUSHJ	SP,U.1				; SP,CERROR
L.494:	MOVNS	U.94				; SCANUM
	JRST	L.497				; L.497
L.495:	CAIN	AC14,2				; AC14,2
	JRST	L.496				; L.496
	MOVEI	AC1,P.AHY			; AC1,P.AHY
	PUSHJ	SP,U.1				; SP,CERROR
L.496:	MOVEI	AC1,-1				; AC1,-1
	CAMLE	AC1,U.94			; AC1,SCANUM
	JRST	L.497				; L.497
	MOVEI	AC1,P.AHZ			; AC1,P.AHZ
	PUSHJ	SP,U.1				; SP,CERROR
L.497:	MOVEI	AC1,-143(SP)			; AC1,VTBL
	ADD	AC1,AC13			; AC1,PTR
	HRRZ	AC2,U.94			; AC2,SCANUM
	MOVEM	AC2,0(AC1)			; AC2,0(AC1)
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,21				; AC1,21
	JRST	L.485				; L.485
	MOVEI	AC1,17				; AC1,17
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.498				; L.498
	MOVEI	AC1,U.64			; AC1,CERM14
	PUSHJ	SP,U.1				; SP,CERROR
L.498:	PUSHJ	SP,U.3				; SP,SCAN
	MOVE	AC1,U.97			; AC1,CONSTP
	ADD	AC1,AC13			; AC1,PTR
	ADDI	AC1,2				; AC1,2
	CAIGE	AC1,6000			; AC1,6000
	JRST	L.499				; L.499
	MOVEI	AC1,U.51			; AC1,CERM1
	PUSHJ	SP,U.1				; SP,CERROR
L.499:	MOVE	AC3,U.97			; TBL,CONSTP
	MOVE	AC1,U.97			; AC1,CONSTP
	ADD	AC1,AC13			; AC1,PTR
	ADDI	AC1,2				; AC1,2
	MOVEM	AC1,U.97			; AC1,CONSTP
	MOVE	AC1,AC13			; AC1,PTR
	ADDI	AC1,1				; AC1,1
	MOVEM	AC1,U.78(AC3)			; AC1,CNSWRK(TBL)
	MOVE	AC5,AC13			; I,PTR
	AOJA	AC5,L.501			; I,L.501
L.500:	MOVE	AC1,AC3				; R1,TBL
	ADD	AC1,C.9				; R1,[CNSWRK]
	MOVEI	AC2,-307(SP)			; AC2,WTBL
	ADD	AC2,AC5				; AC2,I
	MOVE	AC2,0(AC2)			; AC2,0(AC2)
	ADD	AC2,C.9				; AC2,[CNSWRK]
	MOVSI	AC2,0(AC2)			; AC2,0(AC2)
	MOVEI	AC4,-143(SP)			; AC4,VTBL
	ADD	AC4,AC5				; AC4,I
	ADD	AC2,0(AC4)			; AC2,0(AC4)
	JSYS	536				; 536
	JUMP	16,L.501			; 16,L.501
L.501:	SOJGE	AC5,L.500			; I,L.500
	MOVE	AC5,AC13			; I,PTR
	AOJA	AC5,L.503			; I,L.503
L.502:	MOVE	AC1,AC3				; AC1,TBL
	ADD	AC1,AC5				; AC1,I
	MOVE	AC2,U.78+1(AC1)			; HLFTMP,CNSWRK+1(AC1)
	HLRZ	AC4,AC2				; AC4,HLFTMP
	SUB	AC4,C.9				; AC4,[CNSWRK]
	HRL	AC2,AC4				; HLFTMP,AC4
	MOVEM	AC2,U.78+1(AC1)			; HLFTMP,CNSWRK+1(AC1)
L.503:	SOJGE	AC5,L.502			; I,L.502
	MOVE	AC1,AC3				; AC1,TBL
	ADJSP	SP,-310				; SP,-310
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POP	SP,AC10				; SP,AC10
	POPJ	SP,				; SP,
C.41:	POINT	7,U.92,-1			; 7,SCATOM,-1

; Routine Size:  176 words


;	  3457	
;	  3458	ROUTINE CPPRSF(FDB,COD,VAL): NOVALUE =	! File parse options
;	  3459	
;	  3460	!++
;	  3461	! Functional description:
;	  3462	!	Fill in words of GTJFN block, creating it if it does not
;	  3463	!	yet exist.
;	  3464	!
;	  3465	! Formal parameters:
;	  3466	!	Constant index of FLDDB
;	  3467	!	Index into GTJFN block of word to define, -1 for flags,
;	  3468	!	    -2 for secondary flags
;	  3469	!	Value to place in word (or to OR into word if index is negative)
;	  3470	!
;	  3471	! Implicit inputs:
;	  3472	!	Pointer in .CMDAT
;	  3473	!
;	  3474	! Implicit outputs:
;	  3475	!	None
;	  3476	!
;	  3477	! Routine value:
;	  3478	!	None
;	  3479	!
;	  3480	! Side effects:
;	  3481	!	None
;	  3482	!
;	  3483	!--
;	  3484	
;	  3485	    BEGIN
;	  3486	    EXTERNAL REGISTER Z=0;
;	  3487	    LOCAL
;	  3488		PTR;			! Location of option list
;	  3489	    PTR = .CNSWRK[.FDB+$CMDAT];
;	  3490	    IF .PTR EQL 0
;	  3491	    THEN
;	  3492		BEGIN
;	  3493		PTR = CNSWRK[.FDB+$CMDAT] = .CONSTP;
;	  3494		CONSTP = .CONSTP + 6;
;	  3495		IF .CONSTP GEQ CNSWKL THEN CERROR(CERM1);
;	  3496		CNSWRK[.PTR] = 0;		! Flags and generation
;	  3497		CNSWRK[.PTR+1] = 0;		! Secondary flags
;	  3498		CNSWRK[.PTR+$GJDEV] = -1;	! Device
;	  3499		CNSWRK[.PTR+$GJDIR] = -1;	! Directory
;	  3500		CNSWRK[.PTR+$GJNAM] = -1;	! Name
;	  3501		CNSWRK[.PTR+$GJEXT] = -1	! Type
;	  3502		END;
;	  3503	    IF .COD LSS 0
;	  3504	    THEN
;	  3505		BEGIN
;	  3506		CNSWRK[.PTR-(.COD+1)] = .CNSWRK[.PTR-(.COD+1)] OR .VAL;
;	  3507		!GJ%IFG and GJ%OFG together give strange results which the user
;	  3508		!probably doesn't want.  Therefore, If the user has specified
;	  3509		!both WILD and PARSEONLY clear GJ%IFG:
;	  3510		IF .POINTR((CNSWRK[.PTR-(.COD+1)]),GJ_OFG) NEQ 0
;	  3511		THEN
;	  3512		    POINTR((CNSWRK[.PTR-(.COD+1)]),GJ_IFG) = 0;
;	  3513		END
;	  3514	    ELSE
;	  3515	    IF .COD EQL $GJGEN
;	  3516	    THEN
;	  3517		BEGIN
;	  3518		LOCAL
;	  3519		    HLF: HLF_WRD;
;	  3520		HLF = .CNSWRK[.PTR+$GJGEN];
;	  3521		HLF[HLF_RGT] = .VAL;
;	  3522		CNSWRK[.PTR+$GJGEN] = .HLF
;	  3523		END
;	  3524	    ELSE
;	  3525		CNSWRK[.PTR+.COD] = .VAL
;	  3526	    END;


; CPPRSF
U.37:	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC12,AC3			; VAL,AC3
	MOVE	AC13,AC2			; COD,AC2
	MOVE	AC14,U.78+1(AC1)		; PTR,CNSWRK+1(FDB)
	JUMPN	AC14,L.505			; PTR,L.505
	MOVE	AC2,U.97			; AC2,CONSTP
	MOVEM	AC2,U.78+1(AC1)			; AC2,CNSWRK+1(FDB)
	MOVE	AC14,AC2			; PTR,AC2
	MOVEI	AC1,6				; AC1,6
	ADDM	AC1,U.97			; AC1,CONSTP
	MOVEI	AC1,6000			; AC1,6000
	CAMLE	AC1,U.97			; AC1,CONSTP
	JRST	L.504				; L.504
	MOVEI	AC1,U.51			; AC1,CERM1
	PUSHJ	SP,U.1				; SP,CERROR
L.504:	SETZM	U.78(AC14)			; CNSWRK(PTR)
	SETZM	U.78+1(AC14)			; CNSWRK+1(PTR)
	SETOM	U.78+2(AC14)			; CNSWRK+2(PTR)
	SETOM	U.78+3(AC14)			; CNSWRK+3(PTR)
	SETOM	U.78+4(AC14)			; CNSWRK+4(PTR)
	SETOM	U.78+5(AC14)			; CNSWRK+5(PTR)
L.505:	JUMPGE	AC13,L.506			; COD,L.506
	MOVE	AC1,AC14			; AC1,PTR
	SUB	AC1,AC13			; AC1,COD
	IORM	AC12,U.78-1(AC1)		; VAL,CNSWRK-1(AC1)
	LDB	AC2,C.42			; AC2,[POINT 1,CNSWRK-1(AC1),12]  <23,1>
	JUMPE	AC2,L.508			; AC2,L.508
	MOVSI	AC2,100				; AC2,100
	ANDCAM	AC2,U.78-1(AC1)			; AC2,CNSWRK-1(AC1)
	JRST	L.508				; L.508
L.506:	JUMPN	AC13,L.507			; COD,L.507
	MOVE	AC1,U.78(AC14)			; HLF,CNSWRK(PTR)
	HRR	AC1,AC12			; HLF,VAL
	MOVEM	AC1,U.78(AC14)			; HLF,CNSWRK(PTR)
	JRST	L.508				; L.508
L.507:	ADD	AC14,AC13			; PTR,COD
	MOVEM	AC12,U.78(AC14)			; VAL,CNSWRK(AC14)
L.508:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,
C.42:	POINT	1,U.78-1(AC1),12		; 1,CNSWRK-1(AC1),12

; Routine Size:  44 words


;	  3527	
;	  3528	ROUTINE CPTYIN: NOVALUE =	! Typein statement
;	  3529	
;	  3530	!++
;	  3531	! Functional description:
;	  3532	!	Compiles a Typein statement.
;	  3533	!
;	  3534	! Formal parameters:
;	  3535	!	None
;	  3536	!
;	  3537	! Implicit inputs:
;	  3538	!	Source
;	  3539	!
;	  3540	! Implicit outputs:
;	  3541	!	Code
;	  3542	!
;	  3543	! Routine value:
;	  3544	!	None
;	  3545	!
;	  3546	! Side effects:
;	  3547	!	Scans from TYPEIN to atom after argument
;	  3548	!
;	  3549	!--
;	  3550	
;	  3551	    BEGIN
;	  3552	    EXTERNAL REGISTER Z=0;
;	  3553	    LOCAL
;	  3554		OPR;			! Operation code to use
;	  3555	    OPR = OPR_TIN;
;	  3556	    IF SCAN() EQL SCN_NORETURN
;	  3557	    THEN
;	  3558		BEGIN
;	  3559		OPR = OPR_TIX;
;	  3560		SCAN()
;	  3561		END;
;	  3562	    GENINS(.OPR,CPSEXP(OPN_TMP_STR),0,0)
;	  3563	    END;


; CPTYIN
U.38:	PUSH	SP,AC14				; SP,AC14
	MOVEI	AC14,35				; OPR,35
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,116				; AC1,116
	JRST	L.509				; L.509
	MOVEI	AC14,36				; OPR,36
	PUSHJ	SP,U.3				; SP,SCAN
L.509:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
	MOVE	AC2,AC1				; AC2,AC1
	MOVE	AC1,AC14			; AC1,OPR
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  15 words


;	  3564	
;	  3565	ROUTINE CPDPLY: NOVALUE =	! Display statement
;	  3566	
;	  3567	!++
;	  3568	! Functional description:
;	  3569	!	Compiles a Display statement.
;	  3570	!
;	  3571	! Formal parameters:
;	  3572	!	None
;	  3573	!
;	  3574	! Implicit inputs:
;	  3575	!	Source
;	  3576	!
;	  3577	! Implicit outputs:
;	  3578	!	Code
;	  3579	!
;	  3580	! Routine value:
;	  3581	!	None
;	  3582	!
;	  3583	! Side effects:
;	  3584	!	Scans from DISPLAY to unrecognized atom
;	  3585	!
;	  3586	!--
;	  3587	
;	  3588	    BEGIN
;	  3589	    EXTERNAL REGISTER Z=0;
;	  3590	    LOCAL
;	  3591		TYP,			! Operand type (STE_TYP_INT or STE_TYP_STR)
;	  3592		OPR;			! Operation code to use
;	  3593	    OPR = OPR_DPY;
;	  3594	    IF SCAN() EQL SCN_BINARY
;	  3595	    THEN
;	  3596		BEGIN
;	  3597		OPR = OPR_DPB;
;	  3598		SCAN()
;	  3599		END
;	  3600	    ELSE
;	  3601	    IF .SCACOD EQL SCN_NORETURN
;	  3602	    THEN
;	  3603		BEGIN
;	  3604		OPR = OPR_DPN;
;	  3605		SCAN()
;	  3606		END;
;	  3607	    TYP = CPCLSE();		! Get type of expression
;	  3608	    IF .TYP EQL STE_TYP_INT	! Integer?
;	  3609	    THEN			! Yes
;	  3610		BEGIN
;	  3611		OPR = (SELECTONE .OPR OF
;	  3612		    SET
;	  3613		    [OPR_DPY]: OPR_DIY;
;	  3614		    [OPR_DPB]: OPR_DIB;
;	  3615		    [OPR_DPN]: OPR_DIN;
;	  3616		    TES);
;	  3617	        GENINS(.OPR,CPIEXP(OPN_TMP_INT),0,0)
;	  3618		END
;	  3619	    ELSE			! No, so had better be a string...
;	  3620	        GENINS(.OPR,CPSEXP(OPN_TMP_STR),0,0)
;	  3621	    END;


; CPDPLY
U.39:	PUSH	SP,AC14				; SP,AC14
	MOVEI	AC14,41				; OPR,41
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,123				; AC1,123
	JRST	L.510				; L.510
	MOVEI	AC14,42				; OPR,42
	JRST	L.511				; L.511
L.510:	MOVEI	AC1,116				; AC1,116
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.512				; L.512
	MOVEI	AC14,43				; OPR,43
L.511:	PUSHJ	SP,U.3				; SP,SCAN
L.512:	PUSHJ	SP,U.50				; SP,CPCLSE
	JUMPN	AC1,L.517			; TYP,L.517
	CAIE	AC14,41				; OPR,41
	JRST	L.513				; L.513
	MOVEI	AC14,54				; OPR,54
	JRST	L.516				; L.516
L.513:	CAIE	AC14,42				; OPR,42
	JRST	L.514				; L.514
	MOVEI	AC14,55				; OPR,55
	JRST	L.516				; L.516
L.514:	CAIN	AC14,43				; OPR,43
	JRST	L.515				; L.515
	SETO	AC14,				; OPR,
	JRST	L.516				; L.516
L.515:	MOVEI	AC14,56				; OPR,56
L.516:	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	JRST	L.518				; L.518
L.517:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
L.518:	MOVE	AC2,AC1				; AC2,AC1
	MOVE	AC1,AC14			; AC1,OPR
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  38 words


;	  3622	
;	  3623	ROUTINE CPEXIT: NOVALUE =	! Exit statement
;	  3624	
;	  3625	!++
;	  3626	! Functional description:
;	  3627	!	Compiles an Exit statement.
;	  3628	!
;	  3629	! Formal parameters:
;	  3630	!	None
;	  3631	!
;	  3632	! Implicit inputs:
;	  3633	!	Source
;	  3634	!
;	  3635	! Implicit outputs:
;	  3636	!	Code
;	  3637	!
;	  3638	! Routine value:
;	  3639	!	None
;	  3640	!
;	  3641	! Side effects:
;	  3642	!	Scans from keyword to unrecognized atom
;	  3643	!
;	  3644	!--
;	  3645	
;	  3646	    BEGIN
;	  3647	    EXTERNAL REGISTER Z=0;
;	  3648	    LOCAL
;	  3649		OPT;			! Options
;	  3650	    OPT = 0;
;	  3651	    IF SCAN() EQL SCN_SAVE
;	  3652	    THEN
;	  3653		OPT = 1
;	  3654	    ELSE
;	  3655	    IF .SCACOD EQL SCN_TOPROGRAM
;	  3656	    THEN
;	  3657		OPT = 2;
;	  3658	    IF .OPT NEQ 0 THEN SCAN();
;	  3659	    GENINS(OPR_XIT, .OPT, 0, 0)
;	  3660	    END;


; CPEXIT
U.40:	PUSH	SP,AC14				; SP,AC14
	SETZ	AC14,				; OPT,
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,125				; AC1,125
	JRST	L.519				; L.519
	MOVEI	AC14,1				; OPT,1
	JRST	L.520				; L.520
L.519:	MOVEI	AC1,126				; AC1,126
	CAMN	AC1,U.95			; AC1,SCACOD
	MOVEI	AC14,2				; OPT,2
L.520:	JUMPE	AC14,L.521			; OPT,L.521
	PUSHJ	SP,U.3				; SP,SCAN
L.521:	MOVEI	AC1,44				; AC1,44
	MOVE	AC2,AC14			; AC2,OPT
	SETZB	AC3,AC4				; AC3,AC4
	PUSHJ	SP,U.7				; SP,GENINS
	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  18 words


;	  3661	
;	  3662	ROUTINE CPCALL: NOVALUE =	! <Call-statement>
;	  3663	
;	  3664	!++
;	  3665	! Functional description:
;	  3666	!	Called from <Statement> to compile a CALL statement,
;	  3667	!	generating a CAL instruction with the appropriate operands;
;	  3668	!	generate actual parameter list in constant table.
;	  3669	!
;	  3670	! Formal parameters:
;	  3671	!	None
;	  3672	!
;	  3673	! Implicit inputs:
;	  3674	!	Source
;	  3675	!
;	  3676	! Implicit outputs:
;	  3677	!	Code, constants
;	  3678	!
;	  3679	! Routine value:
;	  3680	!	None
;	  3681	!
;	  3682	! Side effects:
;	  3683	!	Scans from CALL to unrecognized atom
;	  3684	!
;	  3685	!--
;	  3686	
;	  3687	    BEGIN
;	  3688	    EXTERNAL REGISTER Z=0;
;	  3689	    LOCAL
;	  3690		PDESIG,			! Procedure designator
;	  3691		PLIST,			! Actual parameter list constant index
;	  3692		LINE,			! Line number of CALL
;	  3693		SAVELINE;		! Save for real line number
;	  3694	    LINE = .SCALIN;
;	  3695	    IF SCAN() EQL SCN_IDENT
;	  3696	    THEN
;	  3697		BEGIN
;	  3698		PDESIG = FNDSMB(STE_CLS_PRC,-1);
;	  3699		IF .PDESIG LSS 0 THEN ERROR('Procedure not defined')
;	  3700		END
;	  3701	    ELSE
;	  3702	    IF .SCACOD EQL SCN_SYSNAME
;	  3703	    THEN
;	  3704		BEGIN
;	  3705		MAP PDESIG: OPRAND;
;	  3706		IF .PSDEFN[.SCATOM,SYN_CLS] NEQ SYN_CLS_PRC
;	  3707		THEN
;	  3708		    ERROR('Typed routine cannot be CALLed');
;	  3709		PDESIG[OPN_ADR] = .SCATOM;
;	  3710		PDESIG[OPN_CLS] = OPN_CLS_SYN
;	  3711		END
;	  3712	    ELSE
;	  3713		ERROR('Procedure name missing');
;	  3714	    PLIST = -1;
;	  3715	    IF SCAN() EQL SCN_LPAREN THEN CPACTL(PLIST);
;	  3716	    SAVELINE = .SCALIN;
;	  3717	    SCALIN = .LINE;
;	  3718	    GENINS(OPR_CAL,.PDESIG,.PLIST,0);
;	  3719	    SCALIN = .SAVELINE
;	  3720	    END;


P.AIA:	BYTE	(7)"P","r","o","c","e"		; Proce
	BYTE	(7)"d","u","r","e"," "		; dure
	BYTE	(7)"n","o","t"," ","d"		; not d
	BYTE	(7)"e","f","i","n","e"		; efine
	BYTE	(7)"d",000,000,000,000		; d
P.AIB:	BYTE	(7)"T","y","p","e","d"		; Typed
	BYTE	(7)" ","r","o","u","t"		;  rout
	BYTE	(7)"i","n","e"," ","c"		; ine c
	BYTE	(7)"a","n","n","o","t"		; annot
	BYTE	(7)" ","b","e"," ","C"		;  be C
	BYTE	(7)"A","L","L","e","d"		; ALLed
	BYTE	(7)000,000,000,000,000
P.AIC:	BYTE	(7)"P","r","o","c","e"		; Proce
	BYTE	(7)"d","u","r","e"," "		; dure
	BYTE	(7)"n","a","m","e"," "		; name
	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g",000,000,000		; ng


; CPCALL
U.41:	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,1				; SP,1
	MOVE	AC12,U.88			; LINE,SCALIN
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,1				; AC1,1
	JRST	L.522				; L.522
	MOVEI	AC1,3				; AC1,3
	SETO	AC2,				; AC2,
	PUSHJ	SP,U.5				; SP,FNDSMB
	MOVE	AC13,AC1			; PDESIG,AC1
	JUMPGE	AC13,L.526			; PDESIG,L.526
	MOVEI	AC1,P.AIA			; AC1,P.AIA
	JRST	L.525				; L.525
L.522:	MOVEI	AC1,112				; AC1,112
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.524				; L.524
	MOVE	AC1,U.92			; AC1,SCATOM
	IMULI	AC1,2				; AC1,2
	LDB	AC2,C.31			; AC2,[POINT 3,PSDEFN(AC1),17]  <18,3>
	JUMPE	AC2,L.523			; AC2,L.523
	MOVEI	AC1,P.AIB			; AC1,P.AIB
	PUSHJ	SP,U.1				; SP,CERROR
L.523:	MOVE	AC1,U.92			; AC1,SCATOM
	DPB	AC1,C.32			; AC1,[POINT 15,AC13,35]  <0,15>
	TRZ	AC13,-200000			; PDESIG,-200000
	TRO	AC13,200000			; PDESIG,200000
	JRST	L.526				; L.526
L.524:	MOVEI	AC1,P.AIC			; AC1,P.AIC
L.525:	PUSHJ	SP,U.1				; SP,CERROR
L.526:	SETOM	0(SP)				; PLIST
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,16				; AC1,16
	JRST	L.527				; L.527
	MOVEI	AC1,0(SP)			; AC1,PLIST
	PUSHJ	SP,U.42				; SP,CPACTL
L.527:	MOVE	AC14,U.88			; SAVELINE,SCALIN
	MOVEM	AC12,U.88			; LINE,SCALIN
	MOVEI	AC1,23				; AC1,23
	MOVE	AC2,AC13			; AC2,PDESIG
	MOVE	AC3,0(SP)			; AC3,PLIST
	SETZ	AC4,				; AC4,
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEM	AC14,U.88			; SAVELINE,SCALIN
	ADJSP	SP,-1				; SP,-1
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,

; Routine Size:  50 words


;	  3721	
;	  3722	ROUTINE CPACTL(LIST): NOVALUE =	! <Actual-parameter-list>
;	  3723	
;	  3724	!++
;	  3725	! Functional description:
;	  3726	!	Processes actual parameter list in source, generating in the
;	  3727	!	constants area the corresponding list of operand descriptors.
;	  3728	!
;	  3729	! Formal parameters:
;	  3730	!	Address of word in which to store constant index of argument list
;	  3731	!
;	  3732	! Implicit inputs:
;	  3733	!	Symbol table, source
;	  3734	!
;	  3735	! Implicit outputs:
;	  3736	!	Constants
;	  3737	!
;	  3738	! Routine value:
;	  3739	!	None
;	  3740	!
;	  3741	! Side effects:
;	  3742	!	Scans from ( past )
;	  3743	!
;	  3744	!--
;	  3745	
;	  3746	    BEGIN
;	  3747	    EXTERNAL REGISTER Z=0;
;	  3748	    LOCAL
;	  3749		PCNT,			! Argument count
;	  3750		IPTR,			! Temporary pointers
;	  3751		OPTR,
;	  3752		TBL: VECTOR[MAXPRM];	! Argument list being created
;	  3753	    OPTR = TBL[0];
;	  3754	    PCNT = 0;
;	  3755	    DO
;	  3756		BEGIN
;	  3757		LOCAL
;	  3758		    TYPE;		! Data type
;	  3759		SCAN();
;	  3760		TYPE = CPCLSE();
;	  3761		IF .TYPE LSS 0 THEN CERROR(CERM18);
;	  3762		IF .TYPE EQL STE_TYP_INT
;	  3763		THEN
;	  3764		    .OPTR = CPIEXP(OPN_TMP_INT)
;	  3765		ELSE
;	  3766		    .OPTR = CPSEXP(OPN_TMP_STR);
;	  3767		OPTR = .OPTR + 1;
;	  3768		PCNT = .PCNT + 1;
;	  3769		IF .SCACOD NEQ SCN_COMMA AND .SCACOD NEQ SCN_RPAREN
;	  3770		THEN
;	  3771		    ERROR('Comma or parenthesis missing after actual argument')
;	  3772		END
;	  3773	    UNTIL
;	  3774		.SCACOD EQL SCN_RPAREN;
;	  3775	    SCAN();
;	  3776	    .LIST = .CONSTP;
;	  3777	    OPTR = CNSWRK[.CONSTP];
;	  3778	    .OPTR = .PCNT;
;	  3779	    CONSTP = .CONSTP + .PCNT + 1;
;	  3780	    IPTR = TBL[0];
;	  3781	    DO
;	  3782		(OPTR=.OPTR+1; .OPTR=..IPTR; IPTR=.IPTR+1)
;	  3783	    UNTIL
;	  3784		(PCNT=.PCNT-1) LEQ 0
;	  3785	    END;


P.AID:	BYTE	(7)"C","o","m","m","a"		; Comma
	BYTE	(7)" ","o","r"," ","p"		;  or p
	BYTE	(7)"a","r","e","n","t"		; arent
	BYTE	(7)"h","e","s","i","s"		; hesis
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g"," ","a"		; ing a
	BYTE	(7)"f","t","e","r"," "		; fter
	BYTE	(7)"a","c","t","u","a"		; actua
	BYTE	(7)"l"," ","a","r","g"		; l arg
	BYTE	(7)"u","m","e","n","t"		; ument
	BYTE	(7)000,000,000,000,000


; CPACTL
U.42:	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,10				; SP,10
	MOVE	AC11,AC1			; LIST,AC1
	MOVEI	AC14,-7(SP)			; OPTR,TBL
	SETZ	AC12,				; PCNT,
L.528:	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.50				; SP,CPCLSE
	MOVE	AC13,AC1			; TYPE,AC1
	JUMPGE	AC13,L.529			; TYPE,L.529
	MOVEI	AC1,U.68			; AC1,CERM18
	PUSHJ	SP,U.1				; SP,CERROR
L.529:	JUMPN	AC13,L.530			; TYPE,L.530
	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	JRST	L.531				; L.531
L.530:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
L.531:	MOVEM	AC1,0(AC14)			; AC1,0(OPTR)
	ADDI	AC14,1				; OPTR,1
	ADDI	AC12,1				; PCNT,1
	MOVE	AC1,U.95			; AC1,SCACOD
	CAIE	AC1,21				; AC1,21
	CAIN	AC1,17				; AC1,17
	JRST	L.532				; L.532
	MOVEI	AC1,P.AID			; AC1,P.AID
	PUSHJ	SP,U.1				; SP,CERROR
L.532:	MOVEI	AC1,17				; AC1,17
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.528				; L.528
	PUSHJ	SP,U.3				; SP,SCAN
	MOVE	AC1,U.97			; AC1,CONSTP
	MOVEM	AC1,0(AC11)			; AC1,0(LIST)
	MOVE	AC14,U.97			; OPTR,CONSTP
	ADD	AC14,C.9			; OPTR,[CNSWRK]
	MOVEM	AC12,0(AC14)			; PCNT,0(OPTR)
	MOVE	AC1,U.97			; AC1,CONSTP
	ADD	AC1,AC12			; AC1,PCNT
	ADDI	AC1,1				; AC1,1
	MOVEM	AC1,U.97			; AC1,CONSTP
	MOVEI	AC1,-7(SP)			; IPTR,TBL
L.533:	ADDI	AC14,1				; OPTR,1
	MOVE	AC2,0(AC1)			; AC2,0(IPTR)
	MOVEM	AC2,0(AC14)			; AC2,0(OPTR)
	ADDI	AC1,1				; IPTR,1
	SOJG	AC12,L.533			; PCNT,L.533
	ADJSP	SP,-10				; SP,-10
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,

; Routine Size:  54 words


;	  3786	
;	  3787	ROUTINE CPRETN: NOVALUE =	! <Return-statement>
;	  3788	
;	  3789	!++
;	  3790	! Functional description:
;	  3791	!	Called from <Statement> to compile a Return statement.
;	  3792	!
;	  3793	! Formal parameters:
;	  3794	!	None
;	  3795	!
;	  3796	! Implicit inputs:
;	  3797	!	Source
;	  3798	!
;	  3799	! Implicit outputs:
;	  3800	!	Code
;	  3801	!
;	  3802	! Routine value:
;	  3803	!	None
;	  3804	!
;	  3805	! Side effects:
;	  3806	!	Scans from RETURN to unrecognized atom
;	  3807	!
;	  3808	!--
;	  3809	
;	  3810	    BEGIN
;	  3811	    EXTERNAL REGISTER Z=0;
;	  3812	    LOCAL
;	  3813		DESC;
;	  3814	    SCAN();
;	  3815	    IF .CURCLS EQL GST_CLS_FCN
;	  3816	    THEN
;	  3817		IF .CURTYP EQL GST_TYP_INT
;	  3818		THEN
;	  3819		    DESC = CPIEXP(OPN_TMP_INT)
;	  3820		ELSE
;	  3821		    DESC = CPSEXP(OPN_TMP_STR);
;	  3822	    GENINS(OPR_RET,.DESC,0,0)
;	  3823	    END;


; CPRETN
U.43:	PUSHJ	SP,U.3				; SP,SCAN
	MOVEI	AC1,3				; AC1,3
	CAME	AC1,U.81			; AC1,CURCLS
	JRST	L.536				; L.536
	SKIPE	U.82				; CURTYP
	JRST	L.534				; L.534
	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	JRST	L.535				; L.535
L.534:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
L.535:	MOVE	AC2,AC1				; DESC,AC1
L.536:	MOVEI	AC1,33				; AC1,33
	SETZB	AC3,AC4				; AC3,AC4
	JRST	U.7				; GENINS

; Routine Size:  15 words


;	  3824	
;	  3825	ROUTINE CPIEXP(DSTN) =	! <Integer-expression>
;	  3826	
;	  3827	!++
;	  3828	! Functional description:
;	  3829	!	Compiles integer expression, and generates necessary instructions
;	  3830	!	to place value of expression into destination provided.  Caller
;	  3831	!	may require that result be placed in a particular variable; if
;	  3832	!	he requires only OPN_TMP_INT then I can put it anyplace and
;	  3833	!	return a read designator.
;	  3834	!
;	  3835	! Formal parameters:
;	  3836	!	Operand descriptor into which expression should	be stored.
;	  3837	!
;	  3838	! Implicit inputs:
;	  3839	!	Source
;	  3840	!
;	  3841	! Implicit outputs:
;	  3842	!	Code
;	  3843	!
;	  3844	! Routine value:
;	  3845	!	Operand descriptor into which expression was stored
;	  3846	!
;	  3847	! Side effects:
;	  3848	!	Scans from first atom of expression past last atom
;	  3849	!
;	  3850	!--
;	  3851	
;	  3852	    BEGIN
;	  3853	    EXTERNAL REGISTER Z=0;
;	  3854	    LOCAL
;	  3855		OPR,			! Operator
;	  3856		BDESC,			! Source designator
;	  3857		CDESC;			! Source designator
;	  3858	    CDESC = CPITRM();
;	  3859	    IF .CDESC LSS 0 THEN CERROR(CERM13);
;	  3860	    OPR = OPR_STO;
;	  3861	    WHILE
;	  3862		.SCACOD EQL SCN_PLUS OR .SCACOD EQL SCN_MINUS
;	  3863	    DO
;	  3864		BEGIN
;	  3865		IF .OPR EQL OPR_STO
;	  3866		THEN
;	  3867		    BDESC = .CDESC
;	  3868		ELSE
;	  3869		    BEGIN
;	  3870		    GENINS(.OPR,OPN_TMP_INT,.BDESC,.CDESC);
;	  3871		    BDESC = OPN_TMP_INT
;	  3872		    END;
;	  3873		OPR = (IF .SCACOD EQL SCN_PLUS THEN OPR_ADD ELSE OPR_SUB);
;	  3874		SCAN();
;	  3875		IF (CDESC = CPITRM()) LSS 0 THEN CERROR(CERM13)
;	  3876		END;
;	  3877	    IF .DSTN EQL OPN_TMP_INT AND .OPR EQL OPR_STO THEN RETURN .CDESC;
;	  3878	    GENINS(.OPR,.DSTN,.BDESC,.CDESC);
;	  3879	    .DSTN
;	  3880	    END;


; CPIEXP
U.44:	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC12,AC1			; DSTN,AC1
	PUSHJ	SP,U.47				; SP,CPITRM
	MOVE	AC13,AC1			; CDESC,AC1
	JUMPGE	AC13,L.537			; CDESC,L.537
	MOVEI	AC1,U.63			; AC1,CERM13
	PUSHJ	SP,U.1				; SP,CERROR
L.537:	MOVEI	AC14,5				; OPR,5
L.538:	MOVE	AC1,U.95			; AC1,SCACOD
	CAIN	AC1,4				; AC1,4
	JRST	L.539				; L.539
	CAIE	AC1,5				; AC1,5
	JRST	L.542				; L.542
L.539:	CAIE	AC14,5				; OPR,5
	JRST	L.540				; L.540
	MOVE	AC11,AC13			; BDESC,CDESC
	JRST	L.541				; L.541
L.540:	MOVE	AC1,AC14			; AC1,OPR
	MOVEI	AC2,-200000			; AC2,-200000
	MOVE	AC3,AC11			; AC3,BDESC
	MOVE	AC4,AC13			; AC4,CDESC
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEI	AC11,-200000			; BDESC,-200000
L.541:	MOVEI	AC1,4				; AC1,4
	CAMN	AC1,U.95			; AC1,SCACOD
	TDZA	AC14,AC14			; OPR,OPR
	MOVEI	AC14,1				; OPR,1
	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.47				; SP,CPITRM
	MOVE	AC13,AC1			; CDESC,AC1
	JUMPGE	AC13,L.538			; CDESC,L.538
	MOVEI	AC1,U.63			; AC1,CERM13
	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.538				; L.538
L.542:	CAIN	AC12,-200000			; DSTN,-200000
	CAIE	AC14,5				; OPR,5
	JRST	L.543				; L.543
	MOVE	AC1,AC13			; AC1,CDESC
	JRST	L.544				; L.544
L.543:	MOVE	AC1,AC14			; AC1,OPR
	MOVE	AC2,AC12			; AC2,DSTN
	MOVE	AC3,AC11			; AC3,BDESC
	MOVE	AC4,AC13			; AC4,CDESC
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC1,AC12			; AC1,DSTN
L.544:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,

; Routine Size:  53 words


;	  3881	
;	  3882	ROUTINE CPSEXP(DSTN) =	! <String-expression>
;	  3883	
;	  3884	!++
;	  3885	! Functional description:
;	  3886	!	Compiles string expression, and generates necessary instructions
;	  3887	!	to place value of expression into destination provided.  Caller
;	  3888	!	may require that result be placed in a particular variable; if
;	  3889	!	he requires only OPN_TMP_STR then I can put it anyplace and
;	  3890	!	return a real designator.
;	  3891	!
;	  3892	! Formal parameters:
;	  3893	!	Operand descriptor into which expression should be stored.
;	  3894	!
;	  3895	! Implicit inputs:
;	  3896	!	Source
;	  3897	!
;	  3898	! Implicit outputs:
;	  3899	!	Code
;	  3900	!
;	  3901	! Routine value:
;	  3902	!	Operand descriptor into which expression was stored
;	  3903	!
;	  3904	! Side effects:
;	  3905	!	Scans from first atom of expression past last atom
;	  3906	!
;	  3907	!--
;	  3908	
;	  3909	    BEGIN
;	  3910	    EXTERNAL REGISTER Z=0;
;	  3911	    LOCAL
;	  3912		OPR,			! Operation code to be used
;	  3913		BDESC,			! Designators
;	  3914		CDESC;
;	  3915	    OPR = OPR_STS;
;	  3916	    CDESC = CPSPRM();
;	  3917	    WHILE
;	  3918		.SCACOD EQL SCN_PLUS
;	  3919	    DO
;	  3920		BEGIN
;	  3921		IF .OPR EQL OPR_STS
;	  3922		THEN
;	  3923		    BEGIN
;	  3924		    OPR = OPR_CNS;
;	  3925		    BDESC = .CDESC
;	  3926		    END
;	  3927		ELSE
;	  3928		    BEGIN
;	  3929		    GENINS(OPR_CNS,OPN_TMP_STR,.BDESC,.CDESC);
;	  3930		    BDESC = OPN_TMP_STR
;	  3931		    END;
;	  3932		SCAN();
;	  3933		CDESC = CPSPRM()
;	  3934		END;
;	  3935	    IF .DSTN EQL OPN_TMP_STR AND .OPR EQL OPR_STS THEN RETURN .CDESC;
;	  3936	    GENINS(.OPR,.DSTN,.BDESC,.CDESC);
;	  3937	    .DSTN
;	  3938	    END;


; CPSEXP
U.45:	PUSH	SP,AC11				; SP,AC11
	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	MOVE	AC12,AC1			; DSTN,AC1
	MOVEI	AC14,6				; OPR,6
L.545:	PUSHJ	SP,U.49				; SP,CPSPRM
	MOVE	AC11,AC1			; CDESC,AC1
	MOVEI	AC1,4				; AC1,4
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.548				; L.548
	CAIE	AC14,6				; OPR,6
	JRST	L.546				; L.546
	MOVEI	AC14,4				; OPR,4
	MOVE	AC13,AC11			; BDESC,CDESC
	JRST	L.547				; L.547
L.546:	MOVEI	AC1,4				; AC1,4
	MOVEI	AC2,-100000			; AC2,-100000
	MOVE	AC3,AC13			; AC3,BDESC
	MOVE	AC4,AC11			; AC4,CDESC
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEI	AC13,-100000			; BDESC,-100000
L.547:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.545				; L.545
L.548:	CAIN	AC12,-100000			; DSTN,-100000
	CAIE	AC14,6				; OPR,6
	JRST	L.549				; L.549
	MOVE	AC1,AC11			; AC1,CDESC
	JRST	L.550				; L.550
L.549:	MOVE	AC1,AC14			; AC1,OPR
	MOVE	AC2,AC12			; AC2,DSTN
	MOVE	AC3,AC13			; AC3,BDESC
	MOVE	AC4,AC11			; AC4,CDESC
	PUSHJ	SP,U.7				; SP,GENINS
	MOVE	AC1,AC12			; AC1,DSTN
L.550:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POP	SP,AC11				; SP,AC11
	POPJ	SP,				; SP,

; Routine Size:  40 words
;	  3939	
;	  3940	ROUTINE CPLEXP =			! <Logical-expression>
;	  3941	
;	  3942	!++
;	  3943	! Functional description:
;	  3944	!	Compiles logical expression, generating appropriate Compare
;	  3945	!	instruction to apply test to the primaries (actually, generates
;	  3946	!	opposite Compare instruction, so that true-statement can
;	  3947	!	immediately follow the Compare).  Returns index
;	  3948	!	of Compare instruction.
;	  3949	!
;	  3950	! Formal parameters:
;	  3951	!	None
;	  3952	!
;	  3953	! Implicit inputs:
;	  3954	!	Source, symbol table
;	  3955	!
;	  3956	! Implicit outputs:
;	  3957	!	Code
;	  3958	!
;	  3959	! Routine value:
;	  3960	!	Index of Compare instruction
;	  3961	!
;	  3962	! Side effects:
;	  3963	!	Scans from first atom of expression past last atom
;	  3964	!
;	  3965	!--
;	  3966	
;	  3967	    BEGIN
;	  3968	    EXTERNAL REGISTER Z=0;
;	  3969	    LOCAL
;	  3970		TYPE,			! Data type of comparison
;	  3971		OPR,			! Operation code
;	  3972		BDESC,			! B operand descriptor
;	  3973		CDESC;			! C operand descriptor
;	  3974	    ! Must be in the same order as the relational scan codes
;	  3975	    BIND
;	  3976		CMP_TBL_INT =
;	  3977			UPLIT(OPR_BGE,OPR_BGT,OPR_BEQ,OPR_BNE,OPR_BLE,OPR_BLT): VECTOR,
;	  3978		CMP_TBL_STR =
;	  3979			UPLIT(OPR_CGE,OPR_CGT,OPR_CEQ,OPR_CNE,OPR_CLE,OPR_CLT): VECTOR;
;	  3980	    TYPE = CPCLSE();
;	  3981	    IF .TYPE LSS 0 THEN CERROR(CERM18);
;	  3982	    IF .TYPE EQL STE_TYP_INT
;	  3983	    THEN
;	  3984		BDESC = CPIEXP(OPN_TMP_INT)
;	  3985	    ELSE
;	  3986		BDESC = CPSEXP(OPN_TMP_STR);
;	  3987	    IF .SCACOD LSS SCN_1RL OR .SCACOD GTR SCN_LRL
;	  3988	    THEN
;	  3989		ERROR('Relational missing');
;	  3990	    OPR = (CASE .TYPE FROM STE_TYP_INT TO STE_TYP_STR OF
;	  3991		SET
;	  3992	[STE_TYP_INT]:	.CMP_TBL_INT[.SCACOD-SCN_LSS];
;	  3993	[STE_TYP_STR]:	.CMP_TBL_STR[.SCACOD-SCN_LSS]
;	  3994		TES);
;	  3995	    SCAN();
;	  3996	    CDESC = (CASE .TYPE FROM STE_TYP_INT TO STE_TYP_STR OF
;	  3997		SET
;	  3998	[STE_TYP_INT]:	CPIEXP(OPN_TMP_INT);
;	  3999	[STE_TYP_STR]:	CPSEXP(OPN_TMP_STR);
;	  4000		TES);
;	  4001	    GENINS(.OPR,0,.BDESC,.CDESC)
;	  4002	    END;


P.AIE:	EXP	13
	EXP	14
	EXP	11
	EXP	12
	EXP	7
	EXP	10
P.AIF:	EXP	21
	EXP	22
	EXP	17
	EXP	20
	EXP	15
	EXP	16
P.AIG:	BYTE	(7)"R","e","l","a","t"		; Relat
	BYTE	(7)"i","o","n","a","l"		; ional
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g",000,000		; ing


; CMP_TBL_INT
U.113=		    P.AIE
; CMP_TBL_STR
U.114=		    P.AIF


; CPLEXP
U.46:	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	PUSHJ	SP,U.50				; SP,CPCLSE
	MOVE	AC14,AC1			; TYPE,AC1
	JUMPGE	AC14,L.551			; TYPE,L.551
	MOVEI	AC1,U.68			; AC1,CERM18
	PUSHJ	SP,U.1				; SP,CERROR
L.551:	JUMPN	AC14,L.552			; TYPE,L.552
	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	JRST	L.553				; L.553
L.552:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
L.553:	MOVE	AC12,AC1			; BDESC,AC1
	MOVE	AC1,U.95			; AC1,SCACOD
	CAIGE	AC1,10				; AC1,10
	JRST	L.554				; L.554
	CAIG	AC1,15				; AC1,15
	JRST	L.555				; L.555
L.554:	MOVEI	AC1,P.AIG			; AC1,P.AIG
	PUSHJ	SP,U.1				; SP,CERROR
L.555:	MOVE	AC1,U.95			; AC1,SCACOD
	SUBI	AC1,10				; AC1,10
	JRST	L.556(AC14)			; L.556(TYPE)
L.556:	JRST	L.557				; L.557
	JRST	L.558				; L.558
L.557:	SKIPA	AC13,U.113(AC1)			; OPR,CMP_TBL_INT(AC1)
L.558:	MOVE	AC13,U.114(AC1)			; OPR,CMP_TBL_STR(AC1)
	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.559(AC14)			; L.559(TYPE)
L.559:	JRST	L.560				; L.560
	JRST	L.561				; L.561
L.560:	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	JRST	L.562				; L.562
L.561:	MOVEI	AC1,-100000			; AC1,-100000
	PUSHJ	SP,U.45				; SP,CPSEXP
L.562:	MOVE	AC4,AC1				; CDESC,AC1
	MOVE	AC1,AC13			; AC1,OPR
	SETZ	AC2,				; AC2,
	MOVE	AC3,AC12			; AC3,BDESC
	PUSHJ	SP,U.7				; SP,GENINS
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,

; Routine Size:  47 words


;	  4003	
;	  4004	ROUTINE CPITRM =		! <Integer-term>
;	  4005	
;	  4006	!++
;	  4007	! Functional description:
;	  4008	!	Compile an integer term, returning a source operand descriptor.
;	  4009	!
;	  4010	! Formal parameters:
;	  4011	!	None
;	  4012	!
;	  4013	! Implicit inputs:
;	  4014	!	Source
;	  4015	!
;	  4016	! Implicit outputs:
;	  4017	!	Code
;	  4018	!
;	  4019	! Routine value:
;	  4020	!	Operand descriptor, or -1 if not an integer
;	  4021	!
;	  4022	! Side effects:
;	  4023	!	Scans past term
;	  4024	!
;	  4025	!--
;	  4026	
;	  4027	    BEGIN
;	  4028	    EXTERNAL REGISTER Z=0;
;	  4029	    LOCAL
;	  4030		OPR,			! Operator
;	  4031		BDESC,			! Source designators
;	  4032		CDESC;
;	  4033	    IF (BDESC = CPIPRM()) LSS 0 THEN RETURN -1;
;	  4034	    OPR = OPR_STO;
;	  4035	    WHILE
;	  4036		.SCACOD EQL SCN_TIMES OR .SCACOD EQL SCN_DIV
;	  4037	    DO
;	  4038		BEGIN
;	  4039		OPR = (IF .SCACOD EQL SCN_TIMES THEN OPR_MUL ELSE OPR_DIV);
;	  4040		SCAN();
;	  4041		IF (CDESC = CPIPRM()) LSS 0 THEN CERROR(CERM13);
;	  4042		GENINS(.OPR,OPN_TMP_INT,.BDESC,.CDESC);
;	  4043		BDESC = OPN_TMP_INT
;	  4044		END;
;	  4045	    .BDESC
;	  4046	    END;


; CPITRM
U.47:	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	PUSHJ	SP,U.48				; SP,CPIPRM
	MOVE	AC13,AC1			; BDESC,AC1
	JUMPGE	AC13,L.563			; BDESC,L.563
	SETO	AC1,				; AC1,
	JRST	L.571				; L.571
L.563:	MOVEI	AC14,5				; OPR,5
L.564:	MOVE	AC1,U.95			; AC1,SCACOD
	SETZ	AC2,				; AC2,
	CAIE	AC1,6				; AC1,6
	JRST	L.565				; L.565
	MOVEI	AC2,1				; AC2,1
	JRST	L.566				; L.566
L.565:	CAIE	AC1,7				; AC1,7
	JRST	L.570				; L.570
L.566:	TRNN	AC2,1				; AC2,1
	JRST	L.567				; L.567
	MOVEI	AC14,2				; OPR,2
	JRST	L.568				; L.568
L.567:	MOVEI	AC14,3				; OPR,3
L.568:	PUSHJ	SP,U.3				; SP,SCAN
	PUSHJ	SP,U.48				; SP,CPIPRM
	MOVE	AC12,AC1			; CDESC,AC1
	JUMPGE	AC12,L.569			; CDESC,L.569
	MOVEI	AC1,U.63			; AC1,CERM13
	PUSHJ	SP,U.1				; SP,CERROR
L.569:	MOVE	AC1,AC14			; AC1,OPR
	MOVEI	AC2,-200000			; AC2,-200000
	MOVE	AC3,AC13			; AC3,BDESC
	MOVE	AC4,AC12			; AC4,CDESC
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEI	AC13,-200000			; BDESC,-200000
	JRST	L.564				; L.564
L.570:	MOVE	AC1,AC13			; AC1,BDESC
L.571:	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,

; Routine Size:  40 words


;	  4047	
;	  4048	ROUTINE CPIPRM =		! <Integer-primary>
;	  4049	
;	  4050	!++
;	  4051	! Functional description:
;	  4052	!	Processes an integer primary from the source stream, either
;	  4053	!	an integer identifier, an integer system variable, an integer
;	  4054	!	constant, or a temporary designator for the results of a function
;	  4055	!	invocation.  Returns a suitable source operand descriptor.
;	  4056	!
;	  4057	! Formal parameters:
;	  4058	!	None
;	  4059	!
;	  4060	! Implicit inputs:
;	  4061	!	Source, symbols
;	  4062	!
;	  4063	! Implicit outputs:
;	  4064	!	Constants
;	  4065	!
;	  4066	! Routine value:
;	  4067	!	Operand descriptor, or -1 if not recognized
;	  4068	!
;	  4069	! Side effects:
;	  4070	!	Scans past end of primary
;	  4071	!
;	  4072	!--
;	  4073	
;	  4074	    BEGIN
;	  4075	    EXTERNAL REGISTER Z=0;
;	  4076	    LOCAL
;	  4077		DESC;			! Value to be constructed
;	  4078	    IF .SCACOD EQL SCN_IDENT
;	  4079	    THEN
;	  4080		BEGIN
;	  4081		DESC = FNDSMB(-1,STE_TYP_INT);
;	  4082		IF .DESC LSS 0 THEN RETURN -1;
;	  4083		IF .SYMWRK[.DESC,STE_CLS] EQL STE_CLS_PRC THEN RETURN -1;
;	  4084		IF .SYMWRK[.DESC,STE_CLS] EQL STE_CLS_FCN
;	  4085		THEN
;	  4086		    BEGIN
;	  4087		    LOCAL
;	  4088			PLIST;		! Actual argument list pointer
;	  4089		    PLIST = -1;
;	  4090		    IF SCAN() EQL SCN_LPAREN THEN CPACTL(PLIST);
;	  4091		    GENINS(OPR_CAL,.DESC,.PLIST,OPN_TMP_INT);
;	  4092		    DESC = OPN_TMP_INT
;	  4093		    END
;	  4094		ELSE
;	  4095		    SCAN()
;	  4096		END
;	  4097	    ELSE
;	  4098	    IF .SCACOD EQL SCN_SYSNAME
;	  4099	    THEN
;	  4100		BEGIN
;	  4101		IF .PSDEFN[.SCATOM,SYN_CLS] EQL SYN_CLS_VAR
;	  4102		THEN
;	  4103		    IF .PSDEFN[.SCATOM,SYN_TYP] EQL SYN_TYP_INT
;	  4104		    THEN
;	  4105			BEGIN
;	  4106			MAP DESC: OPRAND;
;	  4107			DESC[OPN_ADR] = .SCATOM;
;	  4108			DESC[OPN_CLS] = OPN_CLS_SYN;
;	  4109			SCAN()
;	  4110			END
;	  4111		    ELSE
;	  4112			RETURN -1
;	  4113		ELSE
;	  4114		IF .PSDEFN[.SCATOM,SYN_CLS] NEQ SYN_CLS_FCN
;	  4115		THEN
;	  4116		    RETURN -1
;	  4117		ELSE
;	  4118		    IF .PSDEFN[.SCATOM,SYN_TYP] EQL SYN_TYP_INT
;	  4119		    THEN
;	  4120			BEGIN
;	  4121			LOCAL
;	  4122			    PLIST;	! Actual argument list pointer
;	  4123			    BEGIN
;	  4124			    MAP DESC: OPRAND;
;	  4125			    DESC[OPN_ADR] = .SCATOM;
;	  4126			    DESC[OPN_CLS] = OPN_CLS_SYN
;	  4127			    END;
;	  4128			PLIST = -1;
;	  4129			IF SCAN() EQL SCN_LPAREN THEN CPACTL(PLIST);
;	  4130			GENINS(OPR_CAL,.DESC,.PLIST,OPN_TMP_INT);
;	  4131			DESC = OPN_TMP_INT
;	  4132			END
;	  4133		    ELSE
;	  4134			RETURN -1
;	  4135		END
;	  4136	    ELSE
;	  4137	    IF .SCACOD EQL SCN_LPAREN
;	  4138	    THEN
;	  4139		BEGIN
;	  4140		SCAN();
;	  4141		DESC = CPIEXP(OPN_TMP_INT);
;	  4142		IF .SCACOD NEQ SCN_RPAREN THEN CERROR(CERM14);
;	  4143		SCAN()
;	  4144		END
;	  4145	    ELSE
;	  4146	    IF .SCACOD EQL SCN_MINUS
;	  4147	    THEN
;	  4148		BEGIN
;	  4149		MAP DESC: OPRAND;
;	  4150		IF SCAN() NEQ SCN_NUMB THEN ERROR('Unary minus only for constants');
;	  4151		DESC[OPN_ADR] = GETCNS(-.SCANUM,STE_TYP_INT);
;	  4152		DESC[OPN_CLS] = OPN_CLS_CNS;
;	  4153		DESC[OPN_STR] = 0;
;	  4154		SCAN()
;	  4155		END
;	  4156	    ELSE
;	  4157		BEGIN
;	  4158		MAP DESC: OPRAND;
;	  4159		IF .SCACOD NEQ SCN_NUMB THEN RETURN -1;
;	  4160		DESC[OPN_ADR] = GETCNS(.SCANUM,STE_TYP_INT);
;	  4161		DESC[OPN_CLS] = OPN_CLS_CNS;
;	  4162		DESC[OPN_STR] = 0;
;	  4163		SCAN()
;	  4164		END;
;	  4165	    .DESC
;	  4166	    END;


P.AIH:	BYTE	(7)"U","n","a","r","y"		; Unary
	BYTE	(7)" ","m","i","n","u"		;  minu
	BYTE	(7)"s"," ","o","n","l"		; s onl
	BYTE	(7)"y"," ","f","o","r"		; y for
	BYTE	(7)" ","c","o","n","s"		;  cons
	BYTE	(7)"t","a","n","t","s"		; tants
	BYTE	(7)000,000,000,000,000


; CPIPRM
U.48:	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,2				; SP,2
	MOVE	AC14,U.95			; AC14,SCACOD
	CAIE	AC14,1				; AC14,1
	JRST	L.573				; L.573
	SETO	AC1,				; AC1,
	SETZ	AC2,				; AC2,
	PUSHJ	SP,U.5				; SP,FNDSMB
	MOVE	AC13,AC1			; DESC,AC1
	JUMPL	AC13,L.582			; DESC,L.582
	MOVE	AC1,AC13			; AC1,DESC
	IMULI	AC1,2				; AC1,2
	LDB	AC1,C.27			; AC1,[POINT 3,SYMWRK(AC1),5]  <30,3>
	CAIN	AC1,3				; AC1,3
	JRST	L.582				; L.582
	CAIE	AC1,4				; AC1,4
	JRST	L.578				; L.578
	SETOM	-1(SP)				; PLIST
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,16				; AC1,16
	JRST	L.572				; L.572
	MOVEI	AC1,-1(SP)			; AC1,PLIST
	PUSHJ	SP,U.42				; SP,CPACTL
L.572:	MOVEI	AC1,23				; AC1,23
	MOVE	AC2,AC13			; AC2,DESC
	MOVE	AC3,-1(SP)			; AC3,PLIST
	JRST	L.576				; L.576
L.573:	CAIE	AC14,112			; AC14,112
	JRST	L.577				; L.577
	MOVE	AC1,U.92			; AC1,SCATOM
	IMULI	AC1,2				; AC1,2
	LDB	AC2,C.31			; AC2,[POINT 3,PSDEFN(AC1),17]  <18,3>
	CAIE	AC2,2				; AC2,2
	JRST	L.574				; L.574
	LDB	AC2,C.33			; AC2,[POINT 3,PSDEFN(AC1),14]  <21,3>
	JUMPN	AC2,L.582			; AC2,L.582
	MOVE	AC1,U.92			; AC1,SCATOM
	DPB	AC1,C.32			; AC1,[POINT 15,AC13,35]  <0,15>
	TRZ	AC13,-200000			; DESC,-200000
	TRO	AC13,200000			; DESC,200000
	JRST	L.578				; L.578
L.574:	CAIE	AC2,1				; AC2,1
	JRST	L.582				; L.582
	LDB	AC2,C.33			; AC2,[POINT 3,PSDEFN(AC1),14]  <21,3>
	JUMPN	AC2,L.582			; AC2,L.582
	MOVE	AC1,U.92			; AC1,SCATOM
	DPB	AC1,C.32			; AC1,[POINT 15,AC13,35]  <0,15>
	TRZ	AC13,-200000			; DESC,-200000
	TRO	AC13,200000			; DESC,200000
	SETOM	0(SP)				; PLIST
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,16				; AC1,16
	JRST	L.575				; L.575
	MOVEI	AC1,0(SP)			; AC1,PLIST
	PUSHJ	SP,U.42				; SP,CPACTL
L.575:	MOVEI	AC1,23				; AC1,23
	MOVE	AC2,AC13			; AC2,DESC
	MOVE	AC3,0(SP)			; AC3,PLIST
L.576:	MOVEI	AC4,-200000			; AC4,-200000
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEI	AC13,-200000			; DESC,-200000
	JRST	L.585				; L.585
L.577:	CAIE	AC14,16				; AC14,16
	JRST	L.579				; L.579
	PUSHJ	SP,U.3				; SP,SCAN
	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	MOVE	AC13,AC1			; DESC,AC1
	MOVEI	AC1,17				; AC1,17
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.578				; L.578
	MOVEI	AC1,U.64			; AC1,CERM14
	PUSHJ	SP,U.1				; SP,CERROR
L.578:	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.585				; L.585
L.579:	CAIE	AC14,5				; AC14,5
	JRST	L.581				; L.581
	PUSHJ	SP,U.3				; SP,SCAN
	CAIN	AC1,2				; AC1,2
	JRST	L.580				; L.580
	MOVEI	AC1,P.AIH			; AC1,P.AIH
	PUSHJ	SP,U.1				; SP,CERROR
L.580:	MOVN	AC1,U.94			; AC1,SCANUM
	JRST	L.584				; L.584
L.581:	CAIN	AC14,2				; AC14,2
	JRST	L.583				; L.583
L.582:	SETO	AC1,				; AC1,
	JRST	L.586				; L.586
L.583:	MOVE	AC1,U.94			; AC1,SCANUM
L.584:	SETZ	AC2,				; AC2,
	PUSHJ	SP,U.8				; SP,GETCNS
	DPB	AC1,C.32			; AC1,[POINT 15,AC13,35]  <0,15>
	TRZ	AC13,-200000			; DESC,-200000
	TRO	AC13,400000			; DESC,400000
	PUSHJ	SP,U.3				; SP,SCAN
	TRZ	AC13,100000			; DESC,100000
L.585:	MOVE	AC1,AC13			; AC1,DESC
L.586:	ADJSP	SP,-2				; SP,-2
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POPJ	SP,				; SP,

; Routine Size:  102 words


;	  4167	
;	  4168	ROUTINE CPSPRM =		! <String-primary>
;	  4169	
;	  4170	!++
;	  4171	! Functional description:
;	  4172	!	Processes a string primary from the source stream, either
;	  4173	!	a string identifier, a string system variable, a string
;	  4174	!	constant, or a call to a string-valued function.  If necessary,
;	  4175	!	generates instructions to calculate value, storing it in a
;	  4176	!	stack temporary.  Returns a suitable source operand descriptor.
;	  4177	!
;	  4178	! Formal parameters:
;	  4179	!	None
;	  4180	!
;	  4181	! Implicit inputs:
;	  4182	!	Source, symbols
;	  4183	!
;	  4184	! Implicit outputs:
;	  4185	!	Constants
;	  4186	!
;	  4187	! Routine value:
;	  4188	!	Operand descriptor
;	  4189	!
;	  4190	! Side effects:
;	  4191	!	Scans past end of primary
;	  4192	!
;	  4193	!--
;	  4194	
;	  4195	    BEGIN
;	  4196	    EXTERNAL REGISTER Z=0;
;	  4197	    LOCAL
;	  4198		DESC;			! Value to be constructed
;	  4199	    IF .SCACOD EQL SCN_IDENT
;	  4200	    THEN
;	  4201		BEGIN
;	  4202		DESC = FNDSMB(-1,STE_TYP_STR);
;	  4203		IF .DESC EQL -1 THEN ERROR('Undefined name');
;	  4204		IF .DESC EQL -2 THEN CERROR(CERM24);
;	  4205		IF .SYMWRK[.DESC,STE_CLS] EQL STE_CLS_PRC
;	  4206		THEN
;	  4207		    ERROR('Procedure name illegal');
;	  4208		IF .SYMWRK[.DESC,STE_CLS] EQL STE_CLS_FCN
;	  4209		THEN
;	  4210		    BEGIN
;	  4211		    LOCAL
;	  4212			PLIST;		! Actual argument list pointer
;	  4213		    PLIST = -1;
;	  4214		    IF SCAN() EQL SCN_LPAREN THEN CPACTL(PLIST);
;	  4215		    GENINS(OPR_CAL,.DESC,.PLIST,OPN_TMP_STR);
;	  4216		    DESC = OPN_TMP_STR
;	  4217		    END
;	  4218		ELSE
;	  4219		    SCAN()
;	  4220		END
;	  4221	    ELSE
;	  4222	    IF .SCACOD EQL SCN_SYSNAME
;	  4223	    THEN
;	  4224		BEGIN
;	  4225		IF .PSDEFN[.SCATOM,SYN_CLS] EQL SYN_CLS_VAR
;	  4226		THEN
;	  4227		    IF .PSDEFN[.SCATOM,SYN_TYP] EQL SYN_TYP_STR THEN
;	  4228	                                ! [fun31]+ Fix string system variables
;	  4229	                                ! garbage collection problem 
;	  4230	                                ! [fun55]+
;	  4231	               if (.psdefn[.scatom,syn_rtv]) and (not .psdefn[.scatom,syn_wrt])
;	  4232	               then begin
;	  4233	                                ! [fun55]-
;	  4234	                                   ! Variable implemented by a procedure.
;	  4235	                  local
;	  4236	                      plist;	! actual argument list pointer
;	  4237	                      begin
;	  4238	                      map desc: oprand;
;	  4239	                      desc = .scatom;
;	  4240	                      desc[opn_cls] = opn_cls_syn
;	  4241	                      end;
;	  4242	                  plist = -1;
;	  4243	                  genins(opr_cal,.desc,.plist,opn_tmp_str);
;	  4244	                  desc = opn_tmp_str;
;	  4245	                  scan ()
;	  4246	                  end
;	  4247	               else
;	  4248	                   BEGIN           ! "real" variable
;	  4249	                   MAP DESC: OPRAND;
;	  4250	                   DESC[OPN_ADR] = .SCATOM;
;	  4251	                   DESC[OPN_CLS] = OPN_CLS_SYN;
;	  4252	                   SCAN()
;	  4253	                   END
;	  4254	                                ! [fun31]-
;	  4255		    ELSE
;	  4256			CERROR(CERM24)
;	  4257		ELSE
;	  4258		IF .PSDEFN[.SCATOM,SYN_CLS] EQL SYN_CLS_FCN
;	  4259		THEN
;	  4260		    IF .PSDEFN[.SCATOM,SYN_TYP] EQL SYN_TYP_STR
;	  4261		    THEN
;	  4262			BEGIN
;	  4263			LOCAL
;	  4264			    PLIST;	! Actual argument list pointer
;	  4265			    BEGIN
;	  4266			    MAP DESC: OPRAND;
;	  4267			    DESC = .SCATOM;
;	  4268			    DESC[OPN_CLS] = OPN_CLS_SYN
;	  4269			    END;
;	  4270			PLIST = -1;
;	  4271			IF SCAN() EQL SCN_LPAREN THEN CPACTL(PLIST);
;	  4272			GENINS(OPR_CAL,.DESC,.PLIST,OPN_TMP_STR);
;	  4273			DESC = OPN_TMP_STR
;	  4274			END
;	  4275		    ELSE
;	  4276			ERROR('Not a string procedure or variable')
;	  4277		ELSE
;	  4278		    ERROR('Not a string procedure or variable')
;	  4279		END
;	  4280	    ELSE
;	  4281		BEGIN
;	  4282		LOCAL SPTR:STR_VAL;
;	  4283		MAP DESC: OPRAND;
;	  4284		IF .SCACOD NEQ SCN_QSTRING
;	  4285		THEN
;	  4286		    CERROR(CERM24);
;	  4287		SPTR[STV_LEN] = .SCALEN;
;	  4288		SPTR[STV_ADR] = SCATOM[0];
;	  4289		DESC[OPN_ADR] = GETCNS(.SPTR,STE_TYP_STR);
;	  4290		DESC[OPN_CLS] = OPN_CLS_CNS;
;	  4291		DESC[OPN_STR] = 1;
;	  4292		SCAN()
;	  4293		END;
;	  4294	    IF .SCACOD EQL SCN_LBRKT
;	  4295	    THEN
;	  4296		BEGIN
;	  4297		LOCAL
;	  4298		    ARGL,		! Argument descriptors
;	  4299		    ARGR;
;	  4300		SCAN();
;	  4301		IF (ARGL = CPIEXP(OPN_TMP_INT)) LSS 0
;	  4302		THEN
;	  4303		    ERROR('Start position missing');
;	  4304		IF .SCACOD NEQ SCN_COLON THEN CERROR(CERM11);
;	  4305		IF SCAN() EQL SCN_TIMES
;	  4306		THEN
;	  4307		    BEGIN
;	  4308		    ARGR = -1;
;	  4309		    SCAN()
;	  4310		    END
;	  4311		ELSE
;	  4312		    IF (ARGR = CPIEXP(OPN_TMP_INT)) LSS 0 THEN ERROR('Count missing');
;	  4313		IF .SCACOD NEQ SCN_RBRKT THEN CERROR(CERM23);
;	  4314		SCAN();
;	  4315		IF .CONSTP+2 GEQ CNSWKL THEN CERROR(CERM1);
;	  4316		CNSWRK[.CONSTP] = .ARGL;
;	  4317		CNSWRK[.CONSTP+1] = .ARGR;
;	  4318		GENINS(OPR_SBS,OPN_TMP_STR,.CONSTP,.DESC);
;	  4319		CONSTP = .CONSTP + 2;
;	  4320		DESC = OPN_TMP_STR
;	  4321		END;
;	  4322	    .DESC
;	  4323	    END;


P.AII:	BYTE	(7)"U","n","d","e","f"		; Undef
	BYTE	(7)"i","n","e","d"," "		; ined
	BYTE	(7)"n","a","m","e",000		; name
P.AIJ:	BYTE	(7)"P","r","o","c","e"		; Proce
	BYTE	(7)"d","u","r","e"," "		; dure
	BYTE	(7)"n","a","m","e"," "		; name
	BYTE	(7)"i","l","l","e","g"		; illeg
	BYTE	(7)"a","l",000,000,000		; al
P.AIK:	BYTE	(7)"N","o","t"," ","a"		; Not a
	BYTE	(7)" ","s","t","r","i"		;  stri
	BYTE	(7)"n","g"," ","p","r"		; ng pr
	BYTE	(7)"o","c","e","d","u"		; ocedu
	BYTE	(7)"r","e"," ","o","r"		; re or
	BYTE	(7)" ","v","a","r","i"		;  vari
	BYTE	(7)"a","b","l","e",000		; able
P.AIL:	BYTE	(7)"N","o","t"," ","a"		; Not a
	BYTE	(7)" ","s","t","r","i"		;  stri
	BYTE	(7)"n","g"," ","p","r"		; ng pr
	BYTE	(7)"o","c","e","d","u"		; ocedu
	BYTE	(7)"r","e"," ","o","r"		; re or
	BYTE	(7)" ","v","a","r","i"		;  vari
	BYTE	(7)"a","b","l","e",000		; able
P.AIM:	BYTE	(7)"S","t","a","r","t"		; Start
	BYTE	(7)" ","p","o","s","i"		;  posi
	BYTE	(7)"t","i","o","n"," "		; tion
	BYTE	(7)"m","i","s","s","i"		; missi
	BYTE	(7)"n","g",000,000,000		; ng
P.AIN:	BYTE	(7)"C","o","u","n","t"		; Count
	BYTE	(7)" ","m","i","s","s"		;  miss
	BYTE	(7)"i","n","g",000,000		; ing


; CPSPRM
U.49:	PUSH	SP,AC12				; SP,AC12
	PUSH	SP,AC13				; SP,AC13
	PUSH	SP,AC14				; SP,AC14
	ADJSP	SP,2				; SP,2
	MOVE	AC14,U.95			; AC14,SCACOD
	CAIE	AC14,1				; AC14,1
	JRST	L.591				; L.591
	SETO	AC1,				; AC1,
	MOVEI	AC2,1				; AC2,1
	PUSHJ	SP,U.5				; SP,FNDSMB
	MOVE	AC13,AC1			; DESC,AC1
	CAME	AC13,C.45			; DESC,[-1]
	JRST	L.587				; L.587
	MOVEI	AC1,P.AII			; AC1,P.AII
	PUSHJ	SP,U.1				; SP,CERROR
L.587:	CAME	AC13,C.46			; DESC,[-2]
	JRST	L.588				; L.588
	MOVEI	AC1,U.74			; AC1,CERM24
	PUSHJ	SP,U.1				; SP,CERROR
L.588:	MOVE	AC14,AC13			; AC14,DESC
	IMULI	AC14,2				; AC14,2
	LDB	AC1,C.29			; AC1,[POINT 3,SYMWRK(AC14),5]  <30,3>
	CAIE	AC1,3				; AC1,3
	JRST	L.589				; L.589
	MOVEI	AC1,P.AIJ			; AC1,P.AIJ
	PUSHJ	SP,U.1				; SP,CERROR
L.589:	LDB	AC1,C.29			; AC1,[POINT 3,SYMWRK(AC14),5]  <30,3>
	CAIE	AC1,4				; AC1,4
	JRST	L.602				; L.602
	SETOM	-1(SP)				; PLIST
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,16				; AC1,16
	JRST	L.590				; L.590
	MOVEI	AC1,-1(SP)			; AC1,PLIST
	PUSHJ	SP,U.42				; SP,CPACTL
L.590:	MOVEI	AC1,23				; AC1,23
	MOVE	AC2,AC13			; AC2,DESC
	MOVE	AC3,-1(SP)			; AC3,PLIST
	JRST	L.596				; L.596
L.591:	CAIE	AC14,112			; AC14,112
	JRST	L.600				; L.600
	MOVE	AC12,U.92			; AC12,SCATOM
	MOVE	AC14,AC12			; AC14,AC12
	IMULI	AC14,2				; AC14,2
	LDB	AC1,C.43			; AC1,[POINT 3,PSDEFN(AC14),17]  <18,3>
	CAIE	AC1,2				; AC1,2
	JRST	L.594				; L.594
	LDB	AC1,C.44			; AC1,[POINT 3,PSDEFN(AC14),14]  <21,3>
	CAIE	AC1,1				; AC1,1
	JRST	L.593				; L.593
	SKIPL	PSDEFN(AC14)			; PSDEFN(AC14)
	JRST	L.592				; L.592
	MOVSI	AC1,200000			; AC1,200000
	TDNE	AC1,PSDEFN(AC14)		; AC1,PSDEFN(AC14)
	JRST	L.592				; L.592
	MOVE	AC13,AC12			; DESC,AC12
	TRZ	AC13,-200000			; DESC,-200000
	TRO	AC13,200000			; DESC,200000
	SETO	AC3,				; PLIST,
	MOVEI	AC1,23				; AC1,23
	MOVE	AC2,AC13			; AC2,DESC
	MOVEI	AC4,-100000			; AC4,-100000
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEI	AC13,-100000			; DESC,-100000
	JRST	L.602				; L.602
L.592:	DPB	AC12,C.32			; AC12,[POINT 15,AC13,35]  <0,15>
	TRZ	AC13,-200000			; DESC,-200000
	TRO	AC13,200000			; DESC,200000
	JRST	L.602				; L.602
L.593:	MOVEI	AC1,U.74			; AC1,CERM24
	JRST	L.599				; L.599
L.594:	CAIE	AC1,1				; AC1,1
	JRST	L.598				; L.598
	LDB	AC1,C.44			; AC1,[POINT 3,PSDEFN(AC14),14]  <21,3>
	CAIE	AC1,1				; AC1,1
	JRST	L.597				; L.597
	MOVE	AC13,AC12			; DESC,AC12
	TRZ	AC13,-200000			; DESC,-200000
	TRO	AC13,200000			; DESC,200000
	SETOM	0(SP)				; PLIST
	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,16				; AC1,16
	JRST	L.595				; L.595
	MOVEI	AC1,0(SP)			; AC1,PLIST
	PUSHJ	SP,U.42				; SP,CPACTL
L.595:	MOVEI	AC1,23				; AC1,23
	MOVE	AC2,AC13			; AC2,DESC
	MOVE	AC3,0(SP)			; AC3,PLIST
L.596:	MOVEI	AC4,-100000			; AC4,-100000
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEI	AC13,-100000			; DESC,-100000
	JRST	L.603				; L.603
L.597:	MOVEI	AC1,P.AIK			; AC1,P.AIK
	JRST	L.599				; L.599
L.598:	MOVEI	AC1,P.AIL			; AC1,P.AIL
L.599:	PUSHJ	SP,U.1				; SP,CERROR
	JRST	L.603				; L.603
L.600:	CAIN	AC14,3				; AC14,3
	JRST	L.601				; L.601
	MOVEI	AC1,U.74			; AC1,CERM24
	PUSHJ	SP,U.1				; SP,CERROR
L.601:	HRL	AC1,U.93			; SPTR,SCALEN
	HRR	AC1,C.3				; SPTR,[SCATOM]
	MOVEI	AC2,1				; AC2,1
	PUSHJ	SP,U.8				; SP,GETCNS
	DPB	AC1,C.32			; AC1,[POINT 15,AC13,35]  <0,15>
	TRZ	AC13,-200000			; DESC,-200000
	TRO	AC13,400000			; DESC,400000
	TRO	AC13,100000			; DESC,100000
L.602:	PUSHJ	SP,U.3				; SP,SCAN
L.603:	MOVEI	AC1,23				; AC1,23
	CAME	AC1,U.95			; AC1,SCACOD
	JRST	L.610				; L.610
	PUSHJ	SP,U.3				; SP,SCAN
	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	MOVE	AC14,AC1			; ARGL,AC1
	JUMPGE	AC14,L.604			; ARGL,L.604
	MOVEI	AC1,P.AIM			; AC1,P.AIM
	PUSHJ	SP,U.1				; SP,CERROR
L.604:	MOVEI	AC1,22				; AC1,22
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.605				; L.605
	MOVEI	AC1,U.61			; AC1,CERM11
	PUSHJ	SP,U.1				; SP,CERROR
L.605:	PUSHJ	SP,U.3				; SP,SCAN
	CAIE	AC1,6				; AC1,6
	JRST	L.606				; L.606
	SETO	AC12,				; ARGR,
	PUSHJ	SP,U.3				; SP,SCAN
	JRST	L.607				; L.607
L.606:	MOVEI	AC1,-200000			; AC1,-200000
	PUSHJ	SP,U.44				; SP,CPIEXP
	MOVE	AC12,AC1			; ARGR,AC1
	JUMPGE	AC12,L.607			; ARGR,L.607
	MOVEI	AC1,P.AIN			; AC1,P.AIN
	PUSHJ	SP,U.1				; SP,CERROR
L.607:	MOVEI	AC1,24				; AC1,24
	CAMN	AC1,U.95			; AC1,SCACOD
	JRST	L.608				; L.608
	MOVEI	AC1,U.73			; AC1,CERM23
	PUSHJ	SP,U.1				; SP,CERROR
L.608:	PUSHJ	SP,U.3				; SP,SCAN
	MOVE	AC1,U.97			; AC1,CONSTP
	ADDI	AC1,2				; AC1,2
	CAIGE	AC1,6000			; AC1,6000
	JRST	L.609				; L.609
	MOVEI	AC1,U.51			; AC1,CERM1
	PUSHJ	SP,U.1				; SP,CERROR
L.609:	MOVE	AC1,U.97			; AC1,CONSTP
	MOVEM	AC14,U.78(AC1)			; ARGL,CNSWRK(AC1)
	MOVE	AC1,U.97			; AC1,CONSTP
	MOVEM	AC12,U.78+1(AC1)		; ARGR,CNSWRK+1(AC1)
	MOVEI	AC1,26				; AC1,26
	MOVEI	AC2,-100000			; AC2,-100000
	MOVE	AC3,U.97			; AC3,CONSTP
	MOVE	AC4,AC13			; AC4,DESC
	PUSHJ	SP,U.7				; SP,GENINS
	MOVEI	AC1,2				; AC1,2
	ADDM	AC1,U.97			; AC1,CONSTP
	MOVEI	AC13,-100000			; DESC,-100000
L.610:	MOVE	AC1,AC13			; AC1,DESC
	ADJSP	SP,-2				; SP,-2
	POP	SP,AC14				; SP,AC14
	POP	SP,AC13				; SP,AC13
	POP	SP,AC12				; SP,AC12
	POPJ	SP,				; SP,
C.43:	POINT	3,PSDEFN(AC14),17		; 3,PSDEFN(AC14),17
C.44:	POINT	3,PSDEFN(AC14),14		; 3,PSDEFN(AC14),14
C.45:	EXP	-1				; -1
C.46:	EXP	-2				; -2

; Routine Size:  171 words


;	  4324	
;	  4325	ROUTINE CPCLSE =		! Classify expression
;	  4326	
;	  4327	!++
;	  4328	! Functional description:
;	  4329	!	Examines current atom in an attempt to classify the expression.
;	  4330	!	Returns STE_TYP_INT, STE_TYP_STR, or -1 if it can't tell.
;	  4331	!
;	  4332	! Formal parameters:
;	  4333	!	None
;	  4334	!
;	  4335	! Implicit inputs:
;	  4336	!	Source
;	  4337	!
;	  4338	! Implicit outputs:
;	  4339	!	None
;	  4340	!
;	  4341	! Routine value:
;	  4342	!	STE_TYP_INT, STE_TYP_STR, or -1
;	  4343	!
;	  4344	! Side effects:
;	  4345	!	None
;	  4346	!
;	  4347	!--
;	  4348	
;	  4349	    IF .SCACOD EQL SCN_IDENT
;	  4350	    THEN
;	  4351		BEGIN
;	  4352		EXTERNAL REGISTER Z=0;
;	  4353		LOCAL
;	  4354		    STE;
;	  4355		STE = FNDSMB(-1,-1);
;	  4356		IF .STE LSS 0 THEN RETURN -1;
;	  4357		IF .SYMWRK[.STE,STE_CLS] EQL STE_CLS_PRC THEN RETURN -1;
;	  4358		.SYMWRK[.STE,STE_TYP]
;	  4359		END
;	  4360	    ELSE
;	  4361	    IF .SCACOD EQL SCN_NUMB
;	  4362	    THEN
;	  4363		STE_TYP_INT
;	  4364	    ELSE
;	  4365	    IF .SCACOD EQL SCN_MINUS
;	  4366	    THEN
;	  4367		STE_TYP_INT
;	  4368	    ELSE
;	  4369	    IF .SCACOD EQL SCN_QSTRING
;	  4370	    THEN
;	  4371		STE_TYP_STR
;	  4372	    ELSE
;	  4373	    IF .SCACOD EQL SCN_SYSNAME
;	  4374	    THEN
;	  4375		CASE .PSDEFN[.SCATOM,SYN_CLS] FROM SYN_CLS_PRC TO SYN_CLS_VAR OF
;	  4376		    SET
;	  4377	[SYN_CLS_PRC]:	-1;
;	  4378	[SYN_CLS_FCN,
;	  4379	 SYN_CLS_VAR]:	.PSDEFN[.SCATOM,SYN_TYP]
;	  4380		    TES
;	  4381	    ELSE
;	  4382		-1;


; CPCLSE
U.50:	PUSH	SP,AC14				; SP,AC14
	MOVE	AC14,U.95			; AC14,SCACOD
	CAIE	AC14,1				; AC14,1
	JRST	L.611				; L.611
	SETOB	AC1,AC2				; AC1,AC2
	PUSHJ	SP,U.5				; SP,FNDSMB
	JUMPL	AC1,L.617			; STE,L.617
	IMULI	AC1,2				; STE,2
	LDB	AC2,C.27			; AC2,[POINT 3,SYMWRK(AC1),5]  <30,3>
	CAIN	AC2,3				; AC2,3
	JRST	L.617				; L.617
	LDB	AC1,C.28			; AC1,[POINT 1,SYMWRK(AC1),6]  <29,1>
	JRST	L.618				; L.618
L.611:	CAIN	AC14,2				; AC14,2
	JRST	L.612				; L.612
	CAIE	AC14,5				; AC14,5
	JRST	L.613				; L.613
L.612:	SETZ	AC1,				; AC1,
	JRST	L.618				; L.618
L.613:	CAIE	AC14,3				; AC14,3
	JRST	L.614				; L.614
	MOVEI	AC1,1				; AC1,1
	JRST	L.618				; L.618
L.614:	CAIE	AC14,112			; AC14,112
	JRST	L.617				; L.617
	MOVE	AC1,U.92			; AC1,SCATOM
	IMULI	AC1,2				; AC1,2
	LDB	AC2,C.31			; AC2,[POINT 3,PSDEFN(AC1),17]  <18,3>
	JRST	L.615(AC2)			; L.615(AC2)
L.615:	JRST	L.617				; L.617
	JRST	L.616				; L.616
	JRST	L.616				; L.616
L.616:	LDB	AC1,C.33			; AC1,[POINT 3,PSDEFN(AC1),14]  <21,3>
	JRST	L.618				; L.618
L.617:	SETO	AC1,				; AC1,
L.618:	POP	SP,AC14				; SP,AC14
	POPJ	SP,				; SP,

; Routine Size:  37 words


;	  4383	END
;	  4384	ELUDOM



	END

; Low  segment length:       1 word
; High segment length:    4874 words




;				LIBRARY STATISTICS
;
;					     -------- Symbols --------    Blocks
;	File				     Total    Loaded   Percent      Read
;
;  PS:<PCL5.X-SOURCES>EXECPD.L36.1	       328       247        75         0
;  PS:<SUBSYS>TENDEF.L36.2		        56         6        10         0
;  PS:<SUBSYS>MONSYM.L36.5		      3861        55         1         0




; Information:	0
; Warnings:	3
; Errors:	0

; Compilation Complete

	END
  