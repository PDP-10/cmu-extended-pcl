REDIT 1(103) COMPARE by user PA0B, 22-Nov-82 23:52:05
File 1: PK:<PA0B>EXECSU.MAC.1
File 2: PK:<PA0B>EXECSU.MAC.2
***** CHANGE #1; PAGE 1, LINE 1; PAGE 1, LINE 1
 ---------------------------------
;<5.PCL>EXECSU.MAC.2, 21-Nov-82 05:40:28, Edit by PA0B
;CM156 Make ^T work in a reasonable manner (consistent with what it does.
; with builtin commands) when a PCL command is in progress.
;CM156 Make assignments to $PromptReg and friends cause the prompt to
; change immediately (instead of after the next command or ^C).
;CM156 Remove DEC fix for ORIGINAL <esc> ^U problem, since it is not necessary
; to have both ours and theirs.
;CM156 Don't close PCL PTY in CIOREL.
;CM156 Don't call CMDINI in EOFJER if a PCL is running 'cause it breaks
; DOCOMMAND.
;CM156 Check FK%INV fork flag instead of PCPRGR to determine if a program
; has been INVOKE'd.
;CM156 Don't blow up if user ^C's during PRESERVE EXEC.
;CM156 Attack error handlers to make sure we don't end up in subcommand
; mode if a DOCOMMAND blows up while inputting subcommands.
;CM156 Make a change to DOGET whose raison de etre has long been forgotten.
;CM156 Make NOTIO check if JFN in use by PCL system.

***** CHANGE #2; PAGE 4, LINE 84; PAGE 4, LINE 84
	JRST FIELDF		; "    "
	SOS CLZFFF		;NOT FILESPEC FUNCTION, CLZFF NOT NEEDED
	CAIE A,.CMCFM		;CONFIRMATION?
	 JRST FIELD1		;NO, GO ON
	SETZM CLF		;NOT AT COMMAND LEVEL IF JUST PARSED RETURN
	SKIPE CIPF		;COMMAND ALREADY IN PROGRESS?
	JRST FIELD1		;YES
	MOVE A,COMAND		;GET ADDRESS OF TABLE ENTRY
	HLRZ A,(A)		;GET ADDRESS OF COMMAND NAME INFO
 ---------------------------------
	JRST FIELDF		; "    "
	SOS CLZFFF		;NOT FILESPEC FUNCTION, CLZFF NOT NEEDED
	CAIE A,.CMCFM		;CONFIRMATION?
	 JRST FIELD1		;NO, GO ON
	SETZM CLF		;NOT AT COMMAND LEVEL IF JUST PARSED RETURN
	SKIPLE PCCIPF		;CM156 Just confirmed top-level PCL command?
	SETOM PCCIPF		;CM156 Yes, remember it's in progress for ^T
	SKIPE CIPF		;COMMAND ALREADY IN PROGRESS?
	JRST FIELD1		;YES
	MOVE A,COMAND		;GET ADDRESS OF TABLE ENTRY
	TLNE A,-1		;CM156 Already been byte-pointer-ized?
	 JRST FIELD3		;CM156 Yes, don't trash COMAND
	HLRZ A,(A)		;GET ADDRESS OF COMMAND NAME INFO

***** CHANGE #3; PAGE 4, LINE 94; PAGE 4, LINE 98
	MOVSI B,774000		;SEE IF THIS IS A FLAG WORD
	TDNN B,(A)		;IS IT?
	AOJ A,			;YES, SO COMMAND NAME STARTS IN NEXT WORD
FIELD2:	HRLI A,440700		;MAKE POINTER TO BEGINNING OF COMMAND NAME
	MOVEM A,COMAND		;REMEMBER POINTER TO ASCII
	CALL GETSIX		;GET SIXBIT NAME FOR COMMAND
 ---------------------------------
	MOVSI B,774000		;SEE IF THIS IS A FLAG WORD
	TDNN B,(A)		;IS IT?
	AOJ A,			;YES, SO COMMAND NAME STARTS IN NEXT WORD
FIELD2:	HRLI A,440700		;MAKE POINTER TO BEGINNING OF COMMAND NAME
	MOVEM A,COMAND		;REMEMBER POINTER TO ASCII
FIELD3:	SKIPE PCCURC		;CM156 PCL command in progress?
	 MOVE A,PCLNAM		;CM156 Yes, so use its name
	CALL GETSIX		;GET SIXBIT NAME FOR COMMAND

***** CHANGE #4; PAGE 7, LINE 118; PAGE 7, LINE 118
	RET			;YES, NO SKIP
	RETSKP			;NO,  SO SKIP

;ROUTINE TO INITIALIZE COMMAND LINE JSYS AND PRINT PROMPT FOR NEW COMMAND.

READY:	MOVEM A,CMDACS		;DON'T CLOBBER ANY AC'S
	MOVEI A,2		;PCL Assume enabled batch
	SKIPN BATCHF		;THIS PREVENTS CONFUSION WITH OPERATOR MODE
	MOVEI A,1		;PCL Use a dollar sign
	SKIPN PRVENF		;USE @ IF NOT ENABLED
	SETZ A,			;PCL One prompt for regular command
	JRST READY3		;PCL JOIN COMMON CODE

READY2:	MOVEM A,CMDACS		;DON'T CLOBBER AC1
	MOVEI A,5		;PCL Precede prompt with space if batch
	SKIPN BATCHF		;THIS PREVENTS CONFUSION WITH OPERATOR MODE
	MOVEI A,4		;PCL Use a dollar sign
	SKIPN PRVENF		;USE @ IF NOT ENABLED
	MOVEI A,3		;PCL One prompt for regular command

READY3:	MOVEM B,CMDACS+1	;PCL Get another register
	HRROI B,REDPMT(A)	;PCL Point to the standard prompt
	SKIPE PCLPMT(A)		;PCL Is one provided by PCL?
	HRRO B,PCLPMT(A)	;PCL Yes, point to that one
	MOVE A,B		;PCL
	MOVE B,CMDACS+1		;PCL

 ---------------------------------
	RET			;YES, NO SKIP
	RETSKP			;NO,  SO SKIP

;ROUTINE TO INITIALIZE COMMAND LINE JSYS AND PRINT PROMPT FOR NEW COMMAND.

READY:	CALL SETPMT		;CM156 Get pointer to prompt string
	JRST READ1		;CM156 Join common code

READY2:	MOVEM A,CMDACS		;DON'T CLOBBER AC1
	MOVEI A,5		;CM156 Precede prompt with space if batch
	SKIPN BATCHF		;THIS PREVENTS CONFUSION WITH OPERATOR MODE
	MOVEI A,4		;CM156 Use a dollar sign
	SKIPN PRVENF		;USE @ IF NOT ENABLED
	MOVEI A,3		;CM156 One prompt for regular command
	CALL SETPM2		;CM156 Get pointer to (subcommand) prompt
	JRST READ1		;CM156 Join common code

SETPMT:	MOVEM A,CMDACS		;CM156 DON'T CLOBBER ANY AC'S
	MOVEI A,2		;CM156 Assume enabled batch
	SKIPN BATCHF		;THIS PREVENTS CONFUSION WITH OPERATOR MODE
	MOVEI A,1		;CM156 Use a dollar sign
	SKIPN PRVENF		;USE @ IF NOT ENABLED
	SETZ A,			;CM156 One prompt for regular command
SETPM2:	MOVEM B,CMDACS+1	;CM156 Get another register
	HRROI B,REDPMT(A)	;CM156 Point to the standard prompt
	SKIPE PCLPMT(A)		;CM156 Is one provided by PCL?
	HRRO B,PCLPMT(A)	;CM156 Yes, point to that one
	MOVE A,B		;CM156
	MOVE B,CMDACS+1		;CM156
	RET			;CM156


***** CHANGE #5; PAGE 7, LINE 174; PAGE 7, LINE 178
		HRL A,CIJFN	;PCL
		MOVEM A,CMIOJ	;PCL
		MOVX A,OURNAM	;PCL Fix the system name
		MOVE B,A	;PCL
		SETSN		;PCL Since we are going back to TI state
		 JRST READ2	;PCL
		JRST READ2]	;PCL And start again
 ---------------------------------
		HRL A,CIJFN	;PCL
		MOVEM A,CMIOJ	;PCL
		MOVX A,OURNAM	;PCL Fix the system name
		MOVE B,A	;PCL
		SETSN		;PCL Since we are going back to TI state
		 TRN		;CM156
		CALL SETPMT	;CM156 Get the correct prompt string
		MOVEM A,CMRTY	;CM156 Set it up
		JRST READ2]	;PCL And start again

***** CHANGE #6; PAGE 11, LINE 26; PAGE 11, LINE 26
	MOVEM A,.JBUFP		;RESTORE JFN STACK FRAME
	CALL FLJFNS		;GET RID OF ANY JFN'S THAT WERE USED FOR COMMAND
	CALL DOECHO		;ECHOING MAY HAVE BEEN TURNED OFF FOR PASSWORD
	MOVSI 17,CMDACS		;MAKE BLT POINTER CMDACS,,0
	BLT 17,17		;RESTORE AC'S TO HOW THEY WERE WHEN THIS PART OF COMMAND STARTED
	SETZM PCLDCO		;PCL Clear original command flag
	JRSTF @REPARA		;RETURN TO BEGINNING OF COMMAND LINE
 ---------------------------------
	MOVEM A,.JBUFP		;RESTORE JFN STACK FRAME
	CALL FLJFNS		;GET RID OF ANY JFN'S THAT WERE USED FOR COMMAND
	CALL DOECHO		;ECHOING MAY HAVE BEEN TURNED OFF FOR PASSWORD
	MOVSI 17,CMDACS		;MAKE BLT POINTER CMDACS,,0
	BLT 17,17		;RESTORE AC'S TO HOW THEY WERE WHEN THIS PART OF COMMAND STARTED
;CM156	SETZM PCLDCO		;PCL Clear original command flag
	JRSTF @REPARA		;RETURN TO BEGINNING OF COMMAND LINE

***** CHANGE #7; PAGE 12, LINE 39; PAGE 12, LINE 39
	CAIN A,.NULIO		;PCL?
	CALL PCMPOS		;NO, POP COMMAND PROCEDURE CONTEXT
	CALL FIXIO
	HRRZ A,OLDJFS
	CAME A,COJFN		;DON'T CLOSE OUTPUT IF SAME!
	CLOSF			;CLOSE OUTPUT BUT NOT INPUT YET
 ---------------------------------
	CAIN A,.NULIO		;PCL?
	CALL PCMPOS		;NO, POP COMMAND PROCEDURE CONTEXT
	CALL FIXIO
	HRRZ A,OLDJFS
	CAME A,COJFN		;DON'T CLOSE OUTPUT IF SAME!
	TXNE A,.TTDES		;CM156 Don't close if a terminal designator
	TRNA			;CM156 Either same or PTY designator
	CLOSF			;CLOSE OUTPUT BUT NOT INPUT YET

***** CHANGE #8; PAGE 47, LINE 35; PAGE 47, LINE 35
	MOVE A,40
	MOVEM A,SAV40		;POSSIBLE UUO IN PROGRESS
	MOVEI A,.PRIOU		;ALWAYS DISPLAY OUTPUT TO PRIMARY,
	MOVEM A,COJFN		;SINCE THAT'S WHERE ^T WAS TYPED FROM.
	ETYPE < %A>		;START WITH CURRENT TIME
	SKIPE CIPF		;COMMAND IN PROGRESS?
 ---------------------------------
	MOVE A,40
	MOVEM A,SAV40		;POSSIBLE UUO IN PROGRESS
	MOVEI A,.PRIOU		;ALWAYS DISPLAY OUTPUT TO PRIMARY,
	MOVEM A,COJFN		;SINCE THAT'S WHERE ^T WAS TYPED FROM.
	ETYPE < %A>		;START WITH CURRENT TIME
	SKIPL PCCIPF		;CM156 PCL command in progress or
	SKIPE CIPF		;COMMAND IN PROGRESS?

***** CHANGE #9; PAGE 50, LINE 58; PAGE 50, LINE 58
;ARE HANDLED STANDARDLY.

EOFJER::CALL GETERR		;GET ERROR CODE
	CAIE A,IOX4		;END OF FILE?
	CALL CJERRE		;NO, TREAT AS UNEXPECTED ERROR
	CALL CMDINI		;RE-INIT COMND, TO PROTECT OURSELF
 ---------------------------------
;ARE HANDLED STANDARDLY.

EOFJER::CALL GETERR		;GET ERROR CODE
	CAIE A,IOX4		;END OF FILE?
	CALL CJERRE		;NO, TREAT AS UNEXPECTED ERROR
	SKIPN PCCURC		;CM156 Unless in a PCL
	CALL CMDINI		;RE-INIT COMND, TO PROTECT OURSELF

***** CHANGE #10; PAGE 53, LINE 76; PAGE 53, LINE 76
		 ETYPE<%_>
		 RET]
	MOVX Q1,FK%INT		;MARK INTERRUPTED
	SKIPE SLFTAB(A)
	IORM Q1,SLFTAB(A)
	SKIPN PCPRGR		;PCL If not controlled by PCL
	CALL RFTYMD		;READ FORK'S MODES
	TLZ Z,RUNF		;DON'T DO TTY MODES ON 2ND ^C!
CCDB3:	MOVEI Q1,ETTYMD		;CM236 SPR 14601
	SKIPN PCPRGR		;PCL If not controlled by PCL
	CALL LTTYMD		;SET UP OUR MODES, PROGRAM MAY HAVE CAUSED STRANGE STATE.
 ---------------------------------
		 ETYPE<%_>
		 RET]
	MOVX Q1,FK%INT		;MARK INTERRUPTED
	SKIPE SLFTAB(A)
	IORM Q1,SLFTAB(A)
	TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL
	CALL RFTYMD		;READ FORK'S MODES
	TLZ Z,RUNF		;DON'T DO TTY MODES ON 2ND ^C!
CCDB3:	MOVEI Q1,ETTYMD		;CM236 SPR 14601
	TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL
	CALL LTTYMD		;SET UP OUR MODES, PROGRAM MAY HAVE CAUSED STRANGE STATE.

***** CHANGE #11; PAGE 53, LINE 100; PAGE 53, LINE 100
	SETZM .JBUFP		;SAY FLUSH ALL JFN'S USED IN CURRENT COMMAND
	CALL CLRIO		;CHECK AND RELEASE EXEC IO
	 CALL CIOER1		;GET RID OF "TAKE" JFN
	SKIPE PCCURC		;PCL Command procedure in progress?
	CALL PCMPOP		;PCL Yes, pop context right now
	SKIPE MPENDF		;WARN IF ^C OUT OF MOUNT
 ---------------------------------
	SETZM .JBUFP		;SAY FLUSH ALL JFN'S USED IN CURRENT COMMAND
	CALL CLRIO		;CHECK AND RELEASE EXEC IO
	 CALL CIOER1		;GET RID OF "TAKE" JFN
	SKIPE PCCURC		;PCL Command procedure in progress?
	CALL PCMPOP		;PCL Yes, pop context right now
	SKIPE QTADSP		;CM156 Do we seem initialized?
	SETOM CINITF		;CM156 Yes, allow for ^C in Save/Exec
	SKIPE MPENDF		;WARN IF ^C OUT OF MOUNT

***** CHANGE #12; PAGE 54, LINE 20; PAGE 54, LINE 20
	MOVE A,FORK
	FFORK			;FREEZE THE WORLD
	MOVX Q1,FK%INT		;MARK INTERRUPTED
	SKIPE SLFTAB(A)
	IORM Q1,SLFTAB(A)
	SKIPN PCPRGR		;PCL If not controlled by PCL
	CALL RFTYMD		;READ FORK'S MODES
	TLZ Z,RUNF		;DON'T DO TTY MODES ON 2ND ^C!
TLMPS1:	MOVEI Q1,ETTYMD		;PUT EXEC'S TTY MODES INTO EFFECT.
	SKIPN PCPRGR		;PCL If not controlled by PCL
	CALL LTTYMD		;MUST ALWAYS BE DONE: EG GTJFN LEAVES THEM BAD.
 ---------------------------------
	MOVE A,FORK
	FFORK			;FREEZE THE WORLD
	MOVX Q1,FK%INT		;MARK INTERRUPTED
	SKIPE SLFTAB(A)
	IORM Q1,SLFTAB(A)
	TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL
	CALL RFTYMD		;READ FORK'S MODES
	TLZ Z,RUNF		;DON'T DO TTY MODES ON 2ND ^C!
TLMPS1:	MOVEI Q1,ETTYMD		;PUT EXEC'S TTY MODES INTO EFFECT.
	TMNN FK%INV,SLFTAB(A)	;CM156 If not controlled by PCL
	CALL LTTYMD		;MUST ALWAYS BE DONE: EG GTJFN LEAVES THEM BAD.

***** CHANGE #13; PAGE 56, LINE 9; PAGE 56, LINE 9

;USE "LERROR <TEXT>" TO PRINT ERROR MESSAGE AND RETURN.  SAME AS
;"ERROR <TEXT>" EXCEPT LATTER DOESN'T RETURN TO CALLER.

%LERRO:	TLZ Z,F1		;LOCAL ERROR HANDLER, RETURNS TO CALLER
	CALL ERRX		;PRINT ERROR MESSAGE
 ---------------------------------

;USE "LERROR <TEXT>" TO PRINT ERROR MESSAGE AND RETURN.  SAME AS
;"ERROR <TEXT>" EXCEPT LATTER DOESN'T RETURN TO CALLER.

%LERRO:	TLZ Z,F1		;LOCAL ERROR HANDLER, RETURNS TO CALLER
	PUSH P,A		;CM156 Save an AC to play with
	MOVE A,TAKLEN		;CM156 Get I/O stack pointer
	HLRZ A,TAKJFN-1(A)	;CM156 Get input designator (don't just look
				; at CIJFN because we didn't call FIXIO yet)
	CAIN A,.NULIO		;CM156 From PCL?
	 JRST ERRPCL		;CM156 Yes, return to Exec top level
	POP P,A			;CM156 Restore work AC
	CALL ERRX		;PRINT ERROR MESSAGE

***** CHANGE #14; PAGE 56, LINE 17; PAGE 56, LINE 24
	RET			;RETURN

%ERR: %$ERR: TLZ Z,F1
	CAIA
%.$ERR:	TLO Z,F1		;SAY DON'T CLEAR INBUF (ERFRS1)
	CALL ERRX		;PRINT ERROR MESSAGE
 ---------------------------------
	RET			;RETURN

%ERR: %$ERR: TLZ Z,F1
	CAIA
%.$ERR:	TLO Z,F1		;SAY DON'T CLEAR INBUF (ERFRS1)
	PUSH P,A		;CM156 Save an AC to play with
	MOVE A,TAKLEN		;CM156 Get I/O stack pointer
	HLRZ A,TAKJFN-1(A)	;CM156 Get input designator (don't just look
				; at CIJFN because we didn't call FIXIO yet)
	CAIE A,.NULIO		;CM156 From PCL?
	 JRST NOPCL		;CM156 No, do normal stuff
ERRPCL:	MOVEI A,RERET		;CM156 Get standard error return
	MOVEM A,CERET		;CM156 Say return to Exec top-level after error
				; is processed
NOPCL:	POP P,A			;CM156 Restore work AC
	CALL ERRX		;PRINT ERROR MESSAGE

***** CHANGE #15; PAGE 60, LINE 28; PAGE 60, LINE 28
	HRRZ C,(B)		;NO, EXAMINE NEXT JFN ON STACK
	ADJSP B,-1		;STEP BACK TO NEXT SLOT
	CAME C,A		;HAVE WE FOUND THE CORRECT ONE YET?
	JRST DG1		;NO, KEEP LOOKING.
	SETZM 1(B)		;YES, CLEAR THIS ENTRY SO EXEC DOESN'T TRY TO CLOSE IT
DG2:	DMOVE A,GETARG		;NOW DO THE GET JSYS
 ---------------------------------
	HRRZ C,(B)		;NO, EXAMINE NEXT JFN ON STACK
	ADJSP B,-1		;STEP BACK TO NEXT SLOT
	CAME C,A		;HAVE WE FOUND THE CORRECT ONE YET?
	JRST DG1		;NO, KEEP LOOKING.
	SETZM 1(B)		;YES, CLEAR THIS ENTRY SO EXEC DOESN'T TRY TO CLOSE IT
;*** I haven't the foggiest idea why this change is here, but it has been
;since time immemoriable - PA0B, 21-Nov-82 ***
	MOVE A,B		;CM156
	ADJSP A,1		;CM156 See where it came from
	CAMN A,JBUFP		;CM156 Was it the top of the stack?
	MOVEM B,JBUFP		;CM156 Yes, just forget it
DG2:	DMOVE A,GETARG		;NOW DO THE GET JSYS

***** CHANGE #16; PAGE 60, LINE 149; PAGE 60, LINE 155
;ROUTINE WHICH SKIPS IFF JFN IN A IS NOT AN EXEC COMMAND JFN.  CLOBBERS
;NOTHING

NOTIO::	ATSAVE			;DON'T CLOBBER ANY AC'S
	MOVE B,TAKLEN		;GET POINTER TO COMMAND JFN STACK
RJFNSA:	SOJL B,RSKP		;LEAVE LOOP WHEN ALL ENTRIES HAVE BEEN SCANNED
	HRRZ D,TAKJFN(B)	;GET OUTPUT JFN
 ---------------------------------
;ROUTINE WHICH SKIPS IFF JFN IN A IS NOT AN EXEC COMMAND JFN.  CLOBBERS
;NOTHING

NOTIO::	ATSAVE			;DON'T CLOBBER ANY AC'S
	MOVE B,TAKLEN		;GET POINTER TO COMMAND JFN STACK
RJFNSA:	SOJL B,NPCLIO		;CM156 When all entries have been scanned, see
				; if JFN in use by PCL
	HRRZ D,TAKJFN(B)	;GET OUTPUT JFN

   